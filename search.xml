<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数值型向量及其运算</title>
    <url>/2020/10/31/R-%E6%95%B0%E5%80%BC%E5%9E%8B%E5%90%91%E9%87%8F%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="数值型向量"><a href="#数值型向量" class="headerlink" title="数值型向量"></a>数值型向量</h2><p><strong>向量</strong>是将若干个基础类型相同的值存储在一起， 各个元素可以按序号访问。 如果将若干个数值存储在一起可以用序号访问， 就叫做一个数值型向量。</p>
<p>用c()函数把多个元素或向量组合成一个向量。如</p>
<pre><code>&gt; marks &lt;- c(10, 6, 4, 7, 8)
&gt; x &lt;- c(1:3, 10:13)
&gt; x1 &lt;- c(1, 2)
&gt; x2 &lt;- c(3, 4)
&gt; x &lt;- c(x1, x2)
&gt; x

运行结果
## [1] 1 2 3 4</code></pre>
<p>10:13这样的写法表示从10到13的整数组成的向量。</p>
<p>用print()函数显示向量或在命令行中显示向量时， 每行显示的行首会有方括号和数字序号， 代表该行显示的第一个向量元素的下标。如</p>
<pre><code>&gt; 12345678901:12345678920

运行结果：
##  [1] 12345678901 12345678902 12345678903 12345678904 12345678905 12345678906
##  [7] 12345678907 12345678908 12345678909 12345678910 12345678911 12345678912
## [13] 12345678913 12345678914 12345678915 12345678916 12345678917 12345678918
## [19] 12345678919 12345678920</code></pre>
<p>length(x)可以求x的长度。 长度为零的向量表示为numeric(0)。 numeric()函数可以用来初始化一个指定元素个数而元素都等于零的数值型向量， 如numeric(10)会生成元素为10个零的向量。</p>
<pre><code>&gt; x &lt;- numeric(10)
&gt; x
## [1] 0 0 0 0 0 0 0 0 0 0</code></pre>
<h2 id="向量运算"><a href="#向量运算" class="headerlink" title="向量运算"></a>向量运算</h2><p>###标量和标量运算</p>
<p>单个数值称为标量， R没有单独的标量类型， 标量实际是长度为1的向量。</p>
<p>R中四则运算用+ - * / ^表示(加、减、乘、除、乘方)，如</p>
<pre><code>&gt; 1.5 + 2.3 - 0.6 + 2.1*1.2 - 1.5/0.5 + 2^3

## [1] 10.72</code></pre>
<p>R中四则运算仍遵从通常的优先级规则， 可以用圆括号()改变运算的先后次序。 如</p>
<pre><code>&gt; 1.5 + 2.3 - (0.6 + 2.1)*1.2 - 1.5/0.5 + 2^3
## [1] 5.56</code></pre>
<p>除了加、减、乘、除、乘方， R还支持整除运算和求余运算。 用%/%表示整除，用%%表示求余。如</p>
<pre><code>&gt; 5 %/% 3

## [1] 1


&gt; 5 %% 3
## [1] 2

&gt; 5.1 %/% 2.5
## [1] 2


&gt; 5.1 %% 2.5
## [1] 0.1</code></pre>
<p>向量与标量运算<br>向量与标量的运算为每个元素与标量的运算, 如</p>
<pre><code>&gt; x &lt;c(1, 10)
&gt; x + 2

## [1]  3 12


&gt; x - 2

## [1] -1  8



&gt; x * 2


## [1]  2 20


&gt; x / 2


## [1] 0.5 5.0


x ^ 2


## [1]   1 100


2 / x


## [1] 2.0 0.2



 2 ^ x


## [1]2 1024</code></pre>
<p>一个向量乘以一个标量， 就是线性代数中的数乘运算。</p>
<p>四则运算时如果有缺失值，缺失元素参加的运算相应结果元素仍缺失。 如</p>
<pre><code>&gt; c(1, NA, 3) + 10
## [1] 11 NA 13</code></pre>
<h3 id="等长向量运算"><a href="#等长向量运算" class="headerlink" title="等长向量运算"></a>等长向量运算</h3><p>等长向量的运算为对应元素两两运算。 如</p>
<pre><code>&gt; x1 &lt;- c(1, 10)
&gt; x2 &lt;- c(4, 2)
&gt; x1 + x2
## [1]  5 12
&gt; x1 - x2
## [1] -3  8
&gt; x1 * x2
## [1]  4 20
&gt; x1 / x2
## [1] 0.25 5.00</code></pre>
<p>两个等长向量的加、减运算就是线性代数中两个向量的加、减运算。</p>
<h3 id="不等长向量的运算"><a href="#不等长向量的运算" class="headerlink" title="不等长向量的运算"></a>不等长向量的运算</h3><p>两个不等长向量的四则运算， 如果其长度为倍数关系，规则是每次从头重复利用短的一个。 如</p>
<pre><code>&gt; x1 &lt;- c(10, 20)
&gt; x2 &lt;- c(1, 3, 5, 7)

&gt; x1 + x2
## [1] 11 23 15 27

&gt; x1 * x2
## [1]  10  60  50 140</code></pre>
<p>不仅是四则运算，R中有两个或多个向量按照元素一一对应参与某种运算或函数调用时， 如果向量长度不同，一般都采用这样的规则。</p>
<p>如果两个向量的长度不是倍数关系，会给出警告信息。如</p>
<pre><code>c(1,2) + c(1,2,3)

## Warning in c(1, 2) + c(1, 2, 3): 长的对象长度不是短的对象长度的整倍数
## [1] 2 4 4</code></pre>
<h2 id="向量函数"><a href="#向量函数" class="headerlink" title="向量函数"></a>向量函数</h2><h3 id="向量化的函数"><a href="#向量化的函数" class="headerlink" title="向量化的函数"></a>向量化的函数</h3><p>R中的函数一般都是向量化的: 在R中， 如果普通的一元函数以向量为自变量，一般会对每个元素计算。 这样的函数包括sqrt, log10, log, exp, sin, cos, tan等许多。 如</p>
<pre><code>&gt; sqrt(c(1, 4, 6.25))
## [1] 1.0 2.0 2.5</code></pre>
<p>为了查看这些基础的数学函数的列表，运行命令help.start()， 点击链接“Search Engine and Keywords”， 找到“Mathematics”栏目， 浏览其中的“arith”和“math”链接中的说明。 常用的数学函数有：</p>
<ul>
<li>舍入：ceiling, floor, round, signif, trunc, zapsmall</li>
<li>符号函数 sign</li>
<li>绝对值 abs</li>
<li>平方根 sqrt</li>
<li>对数与指数函数 log, exp, log10, log2</li>
<li>三角函数 sin, cos, tan</li>
<li>反三角函数 asin, acos, atan, atan2</li>
<li>双曲函数 sinh, cosh, tanh</li>
<li>反双曲函数 asinh, acosh, atanh</li>
</ul>
<p>有一些不太常用的数学函数：</p>
<ul>
<li>贝塔函数 beta, lbeta</li>
<li>伽玛函数 gamma, lgamma, digamma, trigamma, tetragamma, pentagamma</li>
<li>组合数 choose, lchoose</li>
<li>富利叶变换和卷积 fft, mvfft, convolve</li>
<li>正交多项式 poly</li>
<li>求根 polyroot, uniroot</li>
<li>最优化 optimize, optim</li>
<li>Bessel函数 besselI, besselK, besselJ, besselY</li>
<li>样条插值 spline, splinefun</li>
<li>简单的微分 deriv</li>
</ul>
<p>如果自己编写的函数没有考虑向量化问题， 可以用Vectorize()函数将其转换成向量化版本。</p>
<h2 id="排序函数"><a href="#排序函数" class="headerlink" title="排序函数"></a>排序函数</h2><p>sort(x)返回排序结果。 rev(x)返回把各元素排列次序反转后的结果。 order(x)返回排序用的下标。如</p>
<pre><code>&gt; x &lt;- c(33, 55, 11)

&gt; sort(x)
## [1] 11 33 55

&gt; rev(sort(x))
## [1] 55 33 11

&gt; order(x)
## [1] 3 1 2

&gt; x[order(x)]
## [1] 11 33 55</code></pre>
<p>例子中， order(x)结果中3是x的最小元素11所在的位置下标， 1是x的第二小元素33所在的位置下标， 2是x的最大元素55所在的位置下标。</p>
<h2 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h2><p>sum(求和), mean(求平均值), var(求样本方差), sd(求样本标准差), min(求最小值), max(求最大值), range(求最小值和最大值)等函数称为统计函数， 把输入向量看作样本，计算样本统计量。 prod求所有元素的乘积。</p>
<p>cumsum和cumprod计算累加和累乘积。如</p>
<pre><code>&gt; cumsum(1:5)
## [1]  1  3  6 10 15
&gt; cumprod(1:5)
## [1]   1   2   6  24 120</code></pre>
<p>其它一些类似函数有pmax, pmin, cummax, cummin等。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><strong>1. 显示1到100的整数的平方根和立方根（提示：立方根就是三分之一次方）。</strong></p>
<pre><code>计算平方根
&gt; sqrt(seq(1:100))
  [1]  1.000000  1.414214  1.732051  2.000000  2.236068  2.449490  2.645751  2.828427
  [9]  3.000000  3.162278  3.316625  3.464102  3.605551  3.741657  3.872983  4.000000
 [17]  4.123106  4.242641  4.358899  4.472136  4.582576  4.690416  4.795832  4.898979
 [25]  5.000000  5.099020  5.196152  5.291503  5.385165  5.477226  5.567764  5.656854
 [33]  5.744563  5.830952  5.916080  6.000000  6.082763  6.164414  6.244998  6.324555
 [41]  6.403124  6.480741  6.557439  6.633250  6.708204  6.782330  6.855655  6.928203
 [49]  7.000000  7.071068  7.141428  7.211103  7.280110  7.348469  7.416198  7.483315
 [57]  7.549834  7.615773  7.681146  7.745967  7.810250  7.874008  7.937254  8.000000
 [65]  8.062258  8.124038  8.185353  8.246211  8.306624  8.366600  8.426150  8.485281
 [73]  8.544004  8.602325  8.660254  8.717798  8.774964  8.831761  8.888194  8.944272
 [81]  9.000000  9.055385  9.110434  9.165151  9.219544  9.273618  9.327379  9.380832
 [89]  9.433981  9.486833  9.539392  9.591663  9.643651  9.695360  9.746794  9.797959
 [97]  9.848858  9.899495  9.949874 10.000000

#计算立方根
&gt; sqrtn &lt;- function(x,n) x^(1/n)
&gt; sqrtn(seq(1:100),3)
  [1] 1.000000 1.259921 1.442250 1.587401 1.709976 1.817121 1.912931 2.000000 2.080084
 [10] 2.154435 2.223980 2.289428 2.351335 2.410142 2.466212 2.519842 2.571282 2.620741
 [19] 2.668402 2.714418 2.758924 2.802039 2.843867 2.884499 2.924018 2.962496 3.000000
 [28] 3.036589 3.072317 3.107233 3.141381 3.174802 3.207534 3.239612 3.271066 3.301927
 [37] 3.332222 3.361975 3.391211 3.419952 3.448217 3.476027 3.503398 3.530348 3.556893
 [46] 3.583048 3.608826 3.634241 3.659306 3.684031 3.708430 3.732511 3.756286 3.779763
 [55] 3.802952 3.825862 3.848501 3.870877 3.892996 3.914868 3.936497 3.957892 3.979057
 [64] 4.000000 4.020726 4.041240 4.061548 4.081655 4.101566 4.121285 4.140818 4.160168
 [73] 4.179339 4.198336 4.217163 4.235824 4.254321 4.272659 4.290840 4.308869 4.326749
 [82] 4.344481 4.362071 4.379519 4.396830 4.414005 4.431048 4.447960 4.464745 4.481405
 [91] 4.497941 4.514357 4.530655 4.546836 4.562903 4.578857 4.594701 4.610436 4.626065
[100] 4.641589</code></pre>
<p><strong>2. 设有10个人的小测验成绩为:</strong></p>
<blockquote>
<p>77 60 91 73 85 82 83 100 66 75</p>
</blockquote>
<ol>
<li>把这10个成绩存入变量x;</li>
<li>从小到大排序；</li>
<li>计算order(x)，解释order(x)结果中第3项代表的意义。</li>
<li>计算这些成绩的平均值、标准差、最小值、最大值、中位数。</li>
<li>生成区间上等间隔的100个格子点存入变量x中。</li>
</ol>
<p>解答：</p>
<pre><code>    &gt; x &lt;- c(77,60,91,73,85,82,83,100,66,75)
    &gt; sort(x)
     [1]  60  66  73  75  77  82  83  85  91 100
    &gt; order(x)
     [1]  2  9  4 10  1  6  7  5  3  8
    #第三项为4，指代的是按从小到大排序的话排第三位的是之前排第4位的数字，即75
    &gt; mean(x)
    [1] 79.2
    &gt; sd(x)
    [1] 11.69805
    &gt; min(x)
    [1] 60
    &gt; max(x)
    [1] 100
    &gt; median(x)
    [1] 79.5
    #产生100个【0,1】之间的浮点数
    &gt; x &lt;- seq(0,1,length.out = 100)
    &gt; x
      [1] 0.00000000 0.01010101 0.02020202 0.03030303 0.04040404 0.05050505 0.06060606
      [8] 0.07070707 0.08080808 0.09090909 0.10101010 0.11111111 0.12121212 0.13131313
     [15] 0.14141414 0.15151515 0.16161616 0.17171717 0.18181818 0.19191919 0.20202020
     [22] 0.21212121 0.22222222 0.23232323 0.24242424 0.25252525 0.26262626 0.27272727
     [29] 0.28282828 0.29292929 0.30303030 0.31313131 0.32323232 0.33333333 0.34343434
     [36] 0.35353535 0.36363636 0.37373737 0.38383838 0.39393939 0.40404040 0.41414141
     [43] 0.42424242 0.43434343 0.44444444 0.45454545 0.46464646 0.47474747 0.48484848
     [50] 0.49494949 0.50505051 0.51515152 0.52525253 0.53535354 0.54545455 0.55555556
     [57] 0.56565657 0.57575758 0.58585859 0.59595960 0.60606061 0.61616162 0.62626263
     [64] 0.63636364 0.64646465 0.65656566 0.66666667 0.67676768 0.68686869 0.69696970
     [71] 0.70707071 0.71717172 0.72727273 0.73737374 0.74747475 0.75757576 0.76767677
     [78] 0.77777778 0.78787879 0.79797980 0.80808081 0.81818182 0.82828283 0.83838384
     [85] 0.84848485 0.85858586 0.86868687 0.87878788 0.88888889 0.89898990 0.90909091
     [92] 0.91919192 0.92929293 0.93939394 0.94949495 0.95959596 0.96969697 0.97979798
     [99] 0.98989899 1.00000000</code></pre>
]]></content>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>字符型数据及处理</title>
    <url>/2020/11/01/%E5%AD%97%E7%AC%A6%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="字符型向量"><a href="#字符型向量" class="headerlink" title="字符型向量"></a>字符型向量</h2><p>字符型向量是元素为字符串的向量。 如</p>
<pre><code>&gt; s1 &lt;- c(&#39;abc&#39;, &#39;&#39;, &#39;a cat&#39;, NA, &#39;李明&#39;)</code></pre>
<p>注意空字符串并不能自动认为是缺失值， 字符型的缺失值仍用NA表示。</p>
<h2 id="paste-函数"><a href="#paste-函数" class="headerlink" title="paste()函数"></a>paste()函数</h2><p>针对字符型数据最常用的R函数是paste()函数。 paste()用来连接两个字符型向量， 元素一一对应连接， 默认用空格连接。 如paste(c(“ab”, “cd”), c(“ef”, “gh”)) 结果相当于c(“ab ef”, “cd gh”)。</p>
<p>paste()在连接两个字符型向量时采用R的一般向量间运算规则， 而且可以自动把数值型向量转换为字符型向量。 可以作一对多连接， 如paste(“x”, 1:3)结果相当于c(“x 1”, “x 2”, “x 3”)。</p>
<p>用sep=指定分隔符， 如paste(“x”, 1:3, sep=””)结果相当于c(“x1”, “x2”, “x3”)。</p>
<p>使用collapse=参数可以把字符型向量的各个元素连接成一个单一的字符串, 如paste(c(“a”, “b”, “c”), collapse=””)结果相当于”abc”。</p>
<h2 id="转换大小写"><a href="#转换大小写" class="headerlink" title="转换大小写"></a>转换大小写</h2><p>toupper()函数把字符型向量内容转为大写， tolower()函数转为小写。 比如，toupper(‘aB cd’)结果为”AB CD”， tolower(c(‘aB’, ‘cd’))结果相当于c(“ab” “cd”)。 这两个函数可以用于不区分大小写的比较， 比如，不论x的值是’JAN’, ‘Jan’还是’jan’， toupper(x)==’JAN’的结果都为TRUE。</p>
<h2 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h2><p>用nchar(x, type=’bytes’)计算字符型向量x中每个字符串的以字节为单位的长度，这一点对中英文是有差别的， 中文通常一个汉字占两个字节，英文字母、数字、标点占一个字节。 用nchar(x, type=’chars’)计算字符型向量x中每个字符串的以字符个数为单位的长度，这时一个汉字算一个单位。</p>
<p>在画图时可以用strwidth()函数计算某个字符串或表达式占用的空间大小。</p>
<h2 id="取子串"><a href="#取子串" class="headerlink" title="取子串"></a>取子串</h2><p>substr(x, start, stop)从字符串x中取出从第start个到第stop个的子串， 如</p>
<pre><code>&gt; substr(&#39;JAN07&#39;, 1, 3)
## [1] &quot;JAN&quot;</code></pre>
<p>如果x是一个字符型向量，substr将对每个元素取子串。如</p>
<pre><code>&gt; substr(c(&#39;JAN07&#39;, &#39;MAR66&#39;), 1, 3)
## [1] &quot;JAN&quot; &quot;MAR&quot;</code></pre>
<p>用substring(x, start)可以从字符串x中取出从第start个到末尾的子串。如</p>
<pre><code>&gt; substring(c(&#39;JAN07&#39;, &#39;MAR66&#39;), 4)
## [1] &quot;07&quot; &quot;66&quot;</code></pre>
<p>##类型转换##</p>
<p>用as.numeric()把内容是数字的字符型值转换为数值，如</p>
<pre><code>&gt; substr(&#39;JAN07&#39;, 4, 5)
## [1] &quot;07&quot;

&gt; substr(&#39;JAN07&#39;, 4, 5) + 2000
## Error in substr(&quot;JAN07&quot;, 4, 5) + 2000 : 
##   non-numeric argument to binary operator

&gt; as.numeric(substr(&#39;JAN07&#39;, 4, 5)) + 2000
## [1] 2007

&gt; as.numeric(substr(c(&#39;JAN07&#39;, &#39;MAR66&#39;), 4, 5))
## [1]  7 66</code></pre>
<p>as.numeric()是向量化的， 可以转换一个向量的每个元素为数值型。</p>
<p>用as.character()函数把数值型转换为字符型，如</p>
<pre><code>&gt; as.character((1:5)*5)
## [1] &quot;5&quot;  &quot;10&quot; &quot;15&quot; &quot;20&quot; &quot;25&quot;</code></pre>
<p>如果自变量本来已经是字符型则结果不变。</p>
<p>为了用指定的格式数值型转换成字符型， 可以使用sprintf()函数， 其用法与C语言的sprintf()函数相似， 只不过是向量化的。例如</p>
<pre><code>&gt; sprintf(&#39;file%03d.txt&#39;, c(1, 99, 100))
## [1] &quot;file001.txt&quot; &quot;file099.txt&quot; &quot;file100.txt&quot;</code></pre>
<h2 id="字符串拆分"><a href="#字符串拆分" class="headerlink" title="字符串拆分"></a>字符串拆分</h2><p>用strsplit()函数可以把一个字符串按照某种分隔符拆分开，例如</p>
<pre><code>&gt; x &lt;- &#39;10,8,7&#39;
&gt; strsplit(x, &#39;,&#39;, fixed=TRUE)[[1]]
## [1] &quot;10&quot; &quot;8&quot;  &quot;7&quot;

&gt; sum(as.numeric(strsplit(x, &#39;,&#39;, fixed=TRUE)[[1]]))
## [1] 25</code></pre>
<p>因为strsplit()的结果是一个列表， 这个函数延后再详细讲。</p>
<h2 id="字符串替换功能"><a href="#字符串替换功能" class="headerlink" title="字符串替换功能"></a>字符串替换功能</h2><p>用gsub()可以替换字符串中的子串， 这样的功能经常用在数据清理中。 比如，把数据中的中文标点改为英文标点， 去掉空格，等等。 如</p>
<pre><code>&gt; x &lt;- &#39;1, 3; 5&#39;
&gt; gsub(&#39;;&#39;, &#39;,&#39;, x, fixed=TRUE)
## [1] &quot;1, 3, 5&quot;

&gt; strsplit(gsub(&#39;;&#39;, &#39;,&#39;, x, fixed=TRUE), &#39;,&#39;)[[1]]
## [1] &quot;1&quot;  &quot; 3&quot; &quot; 5&quot;</code></pre>
<p>字符串x中分隔符既有逗号又有分号， 上面的程序用gsub()把分号都换成逗号。</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式(regular expression)是一种匹配某种字符串模式的方法。 用这样的方法，可以从字符串中查找某种模式的出现位置， 替换某种模式，等等。 这样的技术可以用于文本数据的预处理， 比如用网络爬虫下载的大量网页文本数据。 R中支持perl语言格式的正则表达式， grep()和grepl()函数从字符串中查询某个模式， sub()和gsub()替换某模式。 比如， 下面的程序把多于一个空格替换成一个空格</p>
<pre><code>&gt; gsub(&#39;[[:space:]]+&#39;, &#39; &#39;, &#39;a   cat  in a box&#39;, perl=TRUE)
## [1] &quot;a cat in a box&quot;</code></pre>
]]></content>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑型向量及其运算</title>
    <url>/2020/10/31/%E9%80%BB%E8%BE%91%E5%9E%8B%E5%90%91%E9%87%8F%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>逻辑型是R的基本数据类型之一，只有两个值TRUE和FALSE, 缺失时为NA。逻辑值一般产生自比较，如</p>
<pre><code>&gt; sele &lt;- (log10(15) &lt; 2)
&gt; print(sele)

## [1] TRUE</code></pre>
<p>向量比较结果为逻辑型向量。如</p>
<pre><code>&gt; c(1, 3, 5) &gt; 2
## [1] FALSE  TRUE  TRUE

&gt; (1:4) &gt;= (4:1)    
## [1] FALSE FALSE  TRUE  TRUE</code></pre>
<p>从例子可以看出，向量比较也遵从R的向量间运算的一般规则： 向量与标量的运算是向量每个元素与标量都分别运算一次， 等长向量的运算时对应元素的运算， 不等长但长度为倍数关系的向量运算是把短的从头重复利用。</p>
<p>与NA比较产生NA，如</p>
<pre><code>&gt; c(1, NA, 3) &gt; 2
## [1] FALSE    NA  TRUE

&gt; NA == NA
## [1] NA</code></pre>
<p>为了判断向量每个元素是否NA， 用is.na()函数，如</p>
<pre><code>&gt; is.na(c(1, NA, 3) &gt; 2)
## [1] FALSE  TRUE FALSE</code></pre>
<p>用**is.finite()**判断向量每个元素是否Inf值。</p>
<p>比较运算符包括</p>
<blockquote>
<p>&lt;   &lt;=  &gt;  &gt;=  ==  !=  %in%<br>分别表示小于、小于等于、大于、大于等于、等于、不等于、属于。 要注意等于比较用了两个等号。</p>
</blockquote>
<p>%in%是比较特殊的比较， x %in% y的运算把向量y看成集合， 运算结果是一个逻辑型向量， 第个元素的值为x的第元素是否属于y的逻辑型值。 如</p>
<pre><code>&gt; c(1,3) %in% c(2,3,4)
## [1] FALSE  TRUE

&gt; c(NA,3) %in% c(2,3,4)
## [1] FALSE  TRUE

&gt; c(1,3) %in% c(NA, 3, 4)
## [1] FALSE  TRUE

&gt; c(NA,3) %in% c(NA, 3, 4)
## [1] TRUE TRUE</code></pre>
<p>函数match(x, y)起到和x %in% y运算类似的作用， 但是其返回结果不是找到与否， 而是对x的每个元素， 找到其在y中首次出现的下标，找不到时取缺失值，如</p>
<pre><code>&gt; match(c(1, 3), c(2,3,4,3))
## [1] NA  2</code></pre>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><p>为了表达如“而且”, “或者”之类的复合比较， 需要使用逻辑运算把两个比较连接起来。 逻辑运算符为&amp;, |和!, 分别表示“同时成立”、“两者至少其一成立”、“条件的反面”。 比如，设age&lt;=3表示婴儿，sex==’女’表示女性，则 age&lt;=3 &amp; sex==’女’表示女婴, age&lt;=3 | sex==’女’表示婴儿或妇女, !(age&lt;=3 | sex==’女’)表示既非婴儿也非妇女。 为了确定运算的先后次序可以用圆括号()指定。</p>
<p>用xor(x, y)表示x与y的异或运算， 即值不相等时为真值，相等时为假值， 有缺失值参加运算时为缺失值。</p>
<p>逻辑向量与逻辑标量之间的逻辑运算， 两个逻辑向量之间的逻辑运算规则遵从一般R向量间运算规则。</p>
<p>在右运算符是缺失值时， 如果左运算符能够确定结果真假， 可以得到非缺失的结果。 例如，TRUE | NA为TRUE, FALSE &amp; NA为FALSE。 不能确定结果时返回NA， 比如， TRUE &amp; NA为NA, FALSE | NA为NA。</p>
<p>&amp;&amp;和||分别为短路的标量逻辑与和短路的标量逻辑或， 仅对两个标量进行运算，如果有向量也仅使用第一个元素。 一般用在if语句、while语句中， 且只要第一个比较已经决定最终结果就不计算第二个比较。 例如</p>
<pre><code>&gt; if(TRUE || sqrt(-1)&gt;0) 3+2 

## [1] 5</code></pre>
<p>其中的sqrt(-1)部分不会执行。</p>
<p>这里结果为TRUE, 第二部分没有参加计算， 否则第二部分的计算会发生函数自变量范围错误。</p>
<h2 id="逻辑运算函数"><a href="#逻辑运算函数" class="headerlink" title="逻辑运算函数"></a>逻辑运算函数</h2><p>因为R中比较与逻辑运算都支持向量之间、向量与标量之间的运算， 所以在需要一个标量结果时要特别注意， 后面讲到的if结构、while结构都需要逻辑标量而且不能是缺失值。 这时，应该对缺失值结果单独考虑。</p>
<p>若cond是逻辑向量， 用all(cond)测试cond的所有元素为真； 用any(cond)测试cond至少一个元素为真。 cond中允许有缺失值，结果可能为缺失值。 如</p>
<pre><code>&gt; c(1, NA, 3) &gt; 2
## [1] FALSE    NA  TRUE

&gt; all(c(1, NA, 3) &gt; 2)
## [1] FALSE

&gt; any(c(1, NA, 3) &gt; 2)
## [1] TRUE

&gt; all(NA)
## [1] NA

&gt; any(NA)
## [1] NA</code></pre>
<p>函数which()返回真值对应的所有下标，如</p>
<pre><code>&gt; which(c(FALSE, TRUE, TRUE, FALSE, NA))
## [1] 2 3

&gt; which((11:15) &gt; 12)
## [1] 3 4 5</code></pre>
<p>函数identical(x,y)比较两个R对象x与y的内容是否完全相同， 结果只会取标量TRUE与FALSE两种。 如</p>
<pre><code>&gt; identical(c(1,2,3), c(1,2,NA))
## [1] FALSE

&gt; identical(c(1L,2L,3L), c(1,2,3))
## [1] FALSE</code></pre>
<p>其中第二个结果假值是因为前一向量是整数型， 后一向量是实数型。</p>
<p>函数all.equal()与identical()类似， 但是在比较数值型时不区分整数型与实数型， 而且相同时返回标量TRUE， 但是不同时会返回一个说明有何不同的字符串。如</p>
<pre><code>&gt; all.equal(c(1,2,3), c(1,2,NA))
## [1] &quot;&#39;is.NA&#39; value mismatch: 1 in current 0 in target&quot;

&gt; all.equal(c(1L,2L,3L), c(1,2,3))
## [1] TRUE</code></pre>
<p>函数duplicated()返回每个元素是否为重复值的结果，如：</p>
<pre><code>&gt; duplicated(c(1,2,1,3,NA,4,NA))
## [1] FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE</code></pre>
<p>用函数unique()可以返回去掉重复值的结果。</p>
]]></content>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>R向量下标和子集</title>
    <url>/2020/11/02/R%E5%90%91%E9%87%8F%E4%B8%8B%E6%A0%87%E5%92%8C%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<h2 id="正整数下标"><a href="#正整数下标" class="headerlink" title="正整数下标"></a>正整数下标</h2><p>对向量x, 在后面加方括号和下标可以访问向量的元素和子集。</p>
<p>设x &lt;- c(1, 4, 6.25)。 x[2]取出第二个元素； x[2] &lt;- 99修改第二个元素。 x[c(1,3)]取出第1、3号元素； x[c(1,3)] &lt;- c(11, 13)修改第1、3号元素。 下标可重复。 例如</p>
<pre><code>&gt; x &lt;- c(1, 4, 6.25)
&gt; x[2]
## [1] 4

&gt; x[2] &lt;- 99; x
## [1]  1.00 99.00  6.25

&gt; x[c(1,3)]
## [1] 1.00 6.25

&gt; x[c(1,3)] &lt;- c(11, 13); x
## [1] 11 99 13

&gt; x[c(1,3,1)]
## [1] 11 13 11</code></pre>
<h2 id="负整数下标"><a href="#负整数下标" class="headerlink" title="负整数下标"></a>负整数下标</h2><p>负下标表示扣除相应的元素后的子集，如</p>
<pre><code>&gt; x &lt;- c(1,4,6.25)
&gt; x[-2]
## [1] 1.00 6.25
&gt; x[-c(1,3)]
## [1] 4</code></pre>
<p>负整数下标不能与正整数下标同时用来从某一向量中取子集， 比如，x[c(1,-2)]没有意义。</p>
<h2 id="空下标与零下标"><a href="#空下标与零下标" class="headerlink" title="空下标与零下标"></a>空下标与零下标</h2><p>x[]表示取x的全部元素作为子集。 这与x本身不同，比如</p>
<pre><code>&gt; x &lt;- c(1,4,6.25)
&gt; x[] &lt;- 999
&gt; x
## [1] 999 999 999

&gt; x &lt;- c(1,4,6.25)
&gt; x &lt;- 999
&gt; x
## [1] 999</code></pre>
<p>x[0]是一种少见的做法， 结果返回类型相同、长度为零的向量， 如numeric(0)。 相当于空集。</p>
<p>当与正整数下标一起使用时会被忽略。 当0与负整数下标一起使用时也会被忽略。</p>
<h2 id="下标超界"><a href="#下标超界" class="headerlink" title="下标超界"></a>下标超界</h2><p>设向量x长度为, 则使用正整数下标时下标应在中取值。 如果使用大于的下标， 读取时返回缺失值，并不出错。 给超出的下标元素赋值， 则向量自动变长， 中间没有赋值的元素为缺失值。 例如</p>
<pre><code>&gt; x &lt;- c(1,4,6.25)
&gt; x[5]
## [1] NA

&gt; x
## [1] 1.00 4.00 6.25

&gt; x[5] &lt;- 9
&gt; x
## [1] 1.00 4.00 6.25   NA 9.00</code></pre>
<p>虽然R的语法对下标超界不视作错误， 但是这样的做法往往来自不良的程序思路， 而且对程序效率有影响， 所以实际编程中应避免下标超界。</p>
<h2 id="逻辑下标"><a href="#逻辑下标" class="headerlink" title="逻辑下标"></a>逻辑下标</h2><p>下标可以是与向量等长的逻辑表达式， 一般是关于本向量或者与本向量等长的其它向量的比较结果，如</p>
<pre><code>x &lt;- c(1,4,6.25)
x[x &gt; 3]
## [1] 4.00 6.25</code></pre>
<p>取出x的大于3的元素组成的子集。</p>
<p>要注意的是，如果逻辑下标中有缺失值， 对应结果也是缺失值。 所以，在用逻辑下标作子集选择时， 一定要考虑到缺失值问题。正确的做法是加上!is.na前提， 如</p>
<pre><code>&gt; x &lt;- c(1, 4, 6.25, NA)
&gt; x[x &gt; 2]
## [1] 4.00 6.25   NA

&gt; x[!is.na(x) &amp; x &gt; 2]
## [1] 4.00 6.25</code></pre>
<h2 id="which-、which-min-、which-max-函数"><a href="#which-、which-min-、which-max-函数" class="headerlink" title="which()、which.min()、which.max()函数"></a>which()、which.min()、which.max()函数</h2><p>函数<strong>which()**可以用来</strong>找到满足条件的下标**， 如</p>
<pre><code>&gt; x &lt;- c(3, 4, 3, 5, 7, 5, 9)
&gt; which(x &gt; 5)
## [1] 5 7

&gt; seq(along=x)[x &gt; 5]
## [1] 5 7</code></pre>
<p>这里seq(along=x)会生成由x的下标组成的向量。 用which.min()、which.max求最小值的下标和最大值的下标， 不唯一时只取第一个。如</p>
<pre><code>&gt; which.min(x)
## [1] 1

&gt; which.max(x)
## [1] 7</code></pre>
<h2 id="元素名"><a href="#元素名" class="headerlink" title="元素名"></a>元素名</h2><p>向量可以为每个元素命名。如</p>
<pre><code>&gt; ages &lt;- c(&quot;李明&quot;=25,&quot;田晓霞&quot;=21,&quot;孙少平&quot;=22)
&gt; ages
## 李明 田晓霞 孙少平 
    25     21     22</code></pre>
<p> 或者</p>
<pre><code>&gt; ages &lt;- c(25,21,22)
&gt; names(ages)&lt;- c(&quot;李明&quot;,&quot;田晓霞&quot;,&quot;孙少平&quot;)
&gt; ages
## 李明 田晓霞 孙少平 
    25     21     22 </code></pre>
<p>或者</p>
<pre><code>&gt; ages &lt;- setNames(c(25,21,22),c(&quot;李明&quot;,&quot;田晓霞&quot;,&quot;孙少平&quot;))
&gt; ages
## 李明 田晓霞 孙少平 
    25     21     22 </code></pre>
<p>这时可以用元素名或元素名向量作为向量的下标，如</p>
<pre><code>&gt; ages[&quot;李明&quot;]
## 李明 
  25

&gt; ages[&quot;李明&quot;] &lt;- 11
&gt; ages
## 李明 田晓霞 孙少平 
    11     21     22 </code></pre>
<p>这实际上建立了字符串到数值的映射表。</p>
<p>用字符串作为下标时， 如果该字符串不在向量的元素名中， 读取时返回缺失值结果， 赋值时该向量会增加一个元素并以该字符串为元素名。</p>
<p>带有元素名的向量也可以是字符型或其它基本类型，如</p>
<pre><code>&gt; sex &lt;- c(&quot;孙少平&quot;=&quot;男&quot;,&quot;田晓霞&quot;=&quot;女&quot;)
&gt; sex
## 孙少平 田晓霞 
  &quot;男&quot;   &quot;女&quot; </code></pre>
<p>除了给向量元素命名外， 在矩阵和数据框中还可以给行、列命名， 这会使得程序的扩展更为容易和安全。</p>
<p>R允许仅给部分元素命名， 这时其它元素名字为空字符串。 不同元素的元素名一般应该是不同的， 否则在使用元素作为下标时会发生误读， 但是R语法允许存在重名。</p>
<p>用unname(x)返回去掉了元素名的x的副本， 用names(x) &lt;- NULL可以去掉x的元素</p>
<pre><code>&gt; unname(ages)
## [1] 11 21 22

&gt; ages
## 李明 田晓霞 孙少平 
    11     21     22 

&gt; names(ages) &lt;- NULL
&gt; ages
## [1] 11 21 22</code></pre>
<h2 id="用R向量下标作映射"><a href="#用R向量下标作映射" class="headerlink" title="用R向量下标作映射"></a>用R向量下标作映射</h2><p>R在使用整数作为向量下标时，允许使用重复下标， 这样可以把数组x看成一个的整数到 x[1], x[2], , x[n]的一个映射表, 其中是x的长度。 比如，某商店有三种礼品，编号为1,2,3， 价格分别为68, 88和168。令</p>
<pre><code>&gt; price.map &lt;- c(68, 88, 168)</code></pre>
<p>设某个收银员在一天内分别售出礼品编号为3,2,1,1,2,2,3， 可以用如下的映射方式获得售出的这些礼品对应的价格：</p>
<pre><code>&gt; items &lt;- c(3,2,1,1,2,2,3)
&gt; y &lt;- price.map[items]; print(y)
## [1] 168  88  68  68  88  88 168</code></pre>
<p>R向量可以用字符型向量作下标， 字符型下标也允许重复， 所以可以把带有元素名的R向量看成是元素名到元素值的映射表。 比如，设sex为10个学生的性别（男、女）</p>
<pre><code>&gt; sex &lt;- c(&quot;男&quot;, &quot;男&quot;, &quot;女&quot;, &quot;女&quot;, &quot;男&quot;, &quot;女&quot;, &quot;女&quot;, &quot;女&quot;, &quot;女&quot;, &quot;男&quot;)</code></pre>
<p>希望把每个学生按照性别分别对应到蓝色和红色。 首先建立一个R向量当作映射</p>
<pre><code>&gt; sex.color &lt;- c(&quot;男&quot;=&quot;blue&quot;, &quot;女&quot;=&quot;red&quot;)</code></pre>
<p>用R向量sex.color当作映射，可以获得每个学生对应的颜色</p>
<pre><code>&gt; cols &lt;- sex.color[sex]; print(cols)
##     男     男     女     女     男     女     女     女     女     男 
## &quot;blue&quot; &quot;blue&quot;  &quot;red&quot;  &quot;red&quot; &quot;blue&quot;  &quot;red&quot;  &quot;red&quot;  &quot;red&quot;  &quot;red&quot; &quot;blue&quot;</code></pre>
<p>这样的映射结果中带有不必要的元素名， 用unname()函数可以去掉元素名，如</p>
<pre><code>&gt; unname(cols)
##  [1] &quot;blue&quot; &quot;blue&quot; &quot;red&quot;  &quot;red&quot;  &quot;blue&quot; &quot;red&quot;  &quot;red&quot;  &quot;red&quot;  &quot;red&quot;  &quot;blue&quot;</code></pre>
<h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><p>可以把向量x看成一个集合，但是其中的元素允许有重复。 用unique(x)可以获得x的所有不同值。如</p>
<pre><code>&gt; unique(c(1, 5, 2, 5))
## [1] 1 5 2</code></pre>
<p>用a %in% x判断a的每个元素是否属于向量x，如</p>
<pre><code>&gt; 5 %in% c(1,5,2)
## [1] TRUE

&gt; c(5,6) %in% c(1,5,2)
## [1]  TRUE FALSE</code></pre>
<p>与%in运算符类似， 函数match(x, table)对向量x的每个元素， 从向量table中查找其首次出现位置并返回这些位置。 没有匹配到的元素位置返回NA_integer_(整数型缺失值)。 如</p>
<pre><code>&gt; match(5, c(1,5,2))
## [1] 2

&gt; match(5, c(1,5,2,5))
## [1] 2

&gt; match(c(2,5), c(1,5,2,5))
## [1] 3 2

&gt; match(c(2,5,0), c(1,5,2,5))
## [1]  3  2 NA</code></pre>
<p>用intersect(x,y)求交集，结果中不含重复元素，如</p>
<pre><code>&gt; intersect(c(5, 7), c(1, 5, 2, 5))
## [1] 5</code></pre>
<p>用union(x,y)求并集，结果中不含重复元素，如</p>
<pre><code>&gt; union(c(5, 7), c(1, 5, 2, 5))
## [1] 5 7 1 2</code></pre>
<p>用setdiff(x,y)求差集，即x的元素中不属于y的元素组成的集合， 结果中不含重复元素，如</p>
<pre><code>&gt; setdiff(c(5, 7), c(1, 5, 2, 5))
## [1] 7</code></pre>
<p>用setequal(x,y)判断两个集合是否相等， 不受次序与重复元素的影响，如</p>
<pre><code>&gt; setequal(c(1,5,2), c(2,5,1))
## [1] TRUE

&gt; setequal(c(1,5,2), c(2,5,1,5))
## [1] TRUE</code></pre>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>设文件class.csv内容如下:</p>
<p>name,sex,age,height,weight<br>Alice,F,13,56.5,84<br>Becka,F,13,65.3,98<br>Gail,F,14,64.3,90<br>Karen,F,12,56.3,77<br>Kathy,F,12,59.8,84.5<br>Mary,F,15,66.5,112<br>Sandy,F,11,51.3,50.5<br>Sharon,F,15,62.5,112.5<br>Tammy,F,14,62.8,102.5<br>Alfred,M,14,69,112.5<br>Duke,M,14,63.5,102.5<br>Guido,M,15,67,133<br>James,M,12,57.3,83<br>Jeffrey,M,13,62.5,84<br>John,M,12,59,99.5<br>Philip,M,16,72,150<br>Robert,M,12,64.8,128<br>Thomas,M,11,57.5,85<br>William,M,15,66.5,112</p>
<p>用如下程序可以把上述文件读入为R数据框d.class, 并取出其中的name和age列到变量name和age中：</p>
<pre><code>&gt; d.class &lt;- read.csv(&quot;class.csv&quot;, header=TRUE, stringsAsFactors=FALSE)
&gt; name &lt;- d.class[,&quot;name&quot;]
&gt; age &lt;- d.class[,&quot;age&quot;]
&gt; age
 [1] 13 13 14 12 12 15 11 15 14 14 14 15 12 13 12 16 12 11 15
&gt; d.class
      name sex age height weight
1    Alice   F  13   56.5   84.0
2    Becka   F  13   65.3   98.0
3     Gail   F  14   64.3   90.0
4    Karen   F  12   56.3   77.0
5    Kathy   F  12   59.8   84.5
6     Mary   F  15   66.5  112.0
7    Sandy   F  11   51.3   50.5
8   Sharon   F  15   62.5  112.5
9    Tammy   F  14   62.8  102.5
10  Alfred   M  14   69.0  112.5
11    Duke   M  14   63.5  102.5
12   Guido   M  15   67.0  133.0
13   James   M  12   57.3   83.0
14 Jeffrey   M  13   62.5   84.0
15    John   M  12   59.0   99.5
16  Philip   M  16   72.0  150.0
17  Robert   M  12   64.8  128.0
18  Thomas   M  11   57.5   85.0
19 William   M  15   66.5  112.0</code></pre>
<ol>
<li><p>求出age中第3, 5, 7号的值；</p>
<pre><code> &gt; age[c(3,5,7)]
 ## [1] 14 12 11</code></pre>
</li>
<li><p>用变量age, 求出达到15岁及以上的那些值；</p>
<pre><code> &gt; age[age&gt;=15]
 ## [1] 15 15 15 16 15 </code></pre>
</li>
<li><p>用变量name和age, 求出Mary与James的年龄。</p>
<pre><code> &gt; set &lt;- setNames(age,name)
 &gt; set[match(c(&quot;Mary&quot;,&quot;James&quot;),name)]
  Mary James 
    15    12 </code></pre>
</li>
<li><p>求age中除Mary与James这两人之外的那些人的年龄值，保存到变量age1中。</p>
</li>
</ol>
<pre><code>    &gt; a &lt;- match(c(&quot;Mary&quot;,&quot;James&quot;),name)
    &gt; b &lt;- (1:length(name))

    &gt; a
    [1]  6 13
    &gt; b
     [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19

    &gt; age1 &lt;- set[setdiff(b,a)]
    &gt; age1
      Alice   Becka    Gail   Karen   Kathy   Sandy  Sharon   Tammy  Alfred    Duke   Guido 
         13      13      14      12      12      11      15      14      14      14      15 
    Jeffrey    John  Philip  Robert  Thomas William 
         13      12      16      12      11      15 </code></pre>
]]></content>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型及性质</title>
    <url>/2020/11/05/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%80%A7%E8%B4%A8/</url>
    <content><![CDATA[<h2 id="存储模式与基本类型"><a href="#存储模式与基本类型" class="headerlink" title="存储模式与基本类型"></a>存储模式与基本类型</h2><p>R的变量可以存储多种不同的数据类型， 可以用typeof()函数来返回一个变量或表达式的类型。比如</p>
<pre><code>&gt; typeof(1:3)
## [1] &quot;integer&quot;

&gt; typeof(c(1,2,3))
## [1] &quot;double&quot;

&gt; typeof(c(1, 2.1, 3))
## [1] &quot;double&quot;

&gt; typeof(c(TRUE, NA, FALSE))
## [1] &quot;logical&quot;

&gt; typeof(&#39;Abc&#39;)
## [1] &quot;character&quot;

&gt; typeof(factor(c(&#39;F&#39;, &#39;M&#39;, &#39;M&#39;, &#39;F&#39;)))
## [1] &quot;integer&quot;</code></pre>
<p>*<em>注意**</em>因子的结果是integer而不是因子。*</p>
<p>R还有两个函数mode()和storage.mode()起到与typeof()类似的作用， 这是为了提供与S语言兼容所遗留的， 应停止使用。</p>
<p>R中数据的最基本的类型包括logical, integer, double, character, complex, raw, 其它数据类型都是由基本类型组合或转变得到的。 character类型就是字符串类型， raw类型是直接使用其二进制内容的类型。 为了判断某个向量x保存的基本类型， 可以用is.xxx()类函数， 如is.integer(x), is.double(x), is.numeric(x), is.logical(x), is.character(x), is.complex(x), is.raw(x)。 其中<strong>is.numeric(x)对integer和double内容都返回真值。</strong></p>
<p>在R语言中数值一般看作double, 如果需要明确表明某些数值是整数， 可以在数值后面附加字母L，如</p>
<pre><code>&gt; is.integer(c(1, -3))
## [1] FALSE

&gt; is.integer(c(1L, -3L))
## [1] TRUE</code></pre>
<p>整数型的缺失值是NA， 而double型的特殊值除了NA外， 还包括Inf, -Inf和NaN， 其中NaN也算是缺失值, Inf和-Inf不算是缺失值。 如:</p>
<pre><code>&gt; c(-1, 0, 1)/0
## [1] -Inf  NaN  Inf

&gt; is.na(c(-1, 0, 1)/0)
## [1] FALSE  TRUE FALSE</code></pre>
<p>对double类型，可以用<strong>is.finite()判断是否有限值</strong>， NA、Inf, -Inf和NaN都不是有限值； 用is.infinite()判断是否Inf或-Inf； is.na()判断是否NA或NaN； is.nan()判断是否NaN。</p>
<p>严格说来， NA表示逻辑型缺失值， 但是当作其它类型缺失值时一般能自动识别。 NA_integer_是整数型缺失值， NA_real是double型缺失值， NA_character_是字符型缺失值。</p>
<p>在R的向量类型中， integer类型、double类型、logical类型、character类型、还有complex类型和raw类型称为原子类型(atomic types)， 原子类型的向量中元素都是同一基本类型的。 比如， double型向量的元素都是double或者缺失值。</p>
<p>除了原子类型的向量， 在R语言的定义中， 向量还包括后面要讲到的列表（list）， 列表的元素不需要属于相同的基本类型， 而且列表的元素可以不是单一基本类型元素。 用typeof()函数可以返回向量的类型， 列表返回结果为”list”:</p>
<pre><code>&gt; typeof(list(&quot;a&quot;, 1L, 1.5))
## [1] &quot;list&quot;</code></pre>
<p>原子类型的各个元素除了基本类型相同， 还不包含任何嵌套结构，如：</p>
<pre><code>&gt; c(1, c(2,3, c(4,5)))
## [1] 1 2 3 4 5</code></pre>
<p>R有一个特殊的NULL类型， 这个类型只有唯一的一个NULL值， 表示不存在。 <strong>NULL长度为0， 不能有任何属性值</strong>。 用is.null()函数判断某个变量是否取NULL。</p>
<p><strong>NULL值可以用来表示类型未知的零长度向量</strong>， 如c()没有自变量时返回值就是NULL； 也经常用作函数缺省值， 在函数内用is.null()判断其缺省后再用一定的计算逻辑得到真正的缺省情况下的数值。</p>
<p>要把NULL与NA区分开来， <strong>NA是有类型的（integer、double、logical、character等)</strong>, <strong>NA表示存在但是未知</strong>。 数据库管理系统中的NULL值相当于R中的NA值。</p>
<h2 id="类型转换与类型升档"><a href="#类型转换与类型升档" class="headerlink" title="类型转换与类型升档"></a>类型转换与类型升档</h2><p>可以用as.xxx()类的函数在不同类型之间进行强制转换。 如</p>
<pre><code>&gt; as.numeric(c(FALSE, TRUE))
## [1] 0 1

&gt; as.character(sqrt(1:4))
## [1] &quot;1&quot;                &quot;1.4142135623731&quot;  &quot;1.73205080756888&quot; &quot;2&quot;</code></pre>
<p>类型转换也可能是隐含的，比如， <strong>四则运算中数值会被统一转换为double类型</strong>， 逻辑运算中运算元素会被统一转换为logical类型。 逻辑值转换成数值时，TRUE转换成1， FALSE转换成0。</p>
<p>在用c()函数合并若干元素时， <strong>如果元素基本类型不同， 将统一转换成最复杂的一个</strong>，复杂程度从简单到复杂依次为： <strong>logical&lt;integer&lt;double&lt;character</strong>。 这种做法称为类型升档，如</p>
<pre><code>&gt; c(FALSE, 1L, 2.5, &quot;3.6&quot;)
## [1] &quot;FALSE&quot; &quot;1&quot;     &quot;2.5&quot;   &quot;3.6&quot;</code></pre>
<p>不同类型参与要求类型相同的运算时， 也会统一转换为最复杂的类型， 也称为类型升档， 如：</p>
<pre><code>&gt; TRUE + 10
## [1] 11

&gt; paste(&quot;abc&quot;, 1)
## [1] &quot;abc 1&quot;</code></pre>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>除了NULL以外， R的变量都可以看成是对象， 都可以有属性。 在R语言中， 属性是把变量看成对象后， 除了其存储内容（如元素）之外的其它附加信息， 如维数、类属等。 R对象一般都有length和mode两个属性。</p>
<p>常用属性有<strong>names, dim，class</strong>等。</p>
<h3 id="attributes函数"><a href="#attributes函数" class="headerlink" title="attributes函数"></a>attributes函数</h3><p>对象x的所有属性可以用attributes()读取， 如</p>
<pre><code>&gt; x &lt;- table(c(1,2,1,3,2,1)); print(x)
## 
## 1 2 3 
## 3 2 1

&gt; attributes(x)
## $dim
## [1] 3
## 
## $dimnames
## $dimnames[[1]]
## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot;
## 
## 
## $class
## [1] &quot;table&quot;</code></pre>
<p><em>table()</em> 函数用了输出其自变量中每个不同值的出现次数，称为<strong>频数</strong>。 从上例可以看出， table()函数的结果有三个属性，前两个是dim和dimnames, 这是数组(array)具有的属性； 另一个是class属性，值为”table”。 因为x是数组，可以访问如</p>
<pre><code>&gt; x[1]
## 1 
## 3

&gt; x[&quot;3&quot;]
## 3 
## 1</code></pre>
<p>也可以用attributes()函数修改属性， 如</p>
<pre><code>&gt; attributes(x) &lt;- NULL
&gt; x
## [1] 3 2 1</code></pre>
<p>如上修改后x不再是数组，也不是table。</p>
<h3 id="attr函数"><a href="#attr函数" class="headerlink" title="attr函数"></a>attr函数</h3><p>可以用attr(x, “属性名”)的格式读取或定义x的属性。 如：</p>
<pre><code>&gt; x &lt;- c(1,3,5)
&gt; attr(x, &quot;theta&quot;) &lt;- c(0, 1)
&gt; print(x)

## [1] 1 3 5
## attr(,&quot;theta&quot;)
## [1] 0 1</code></pre>
<p>可以让向量x额外地保存一个theta属性， 这样的属性常常成为“元数据”(meta data)， 比如， 用来保存数据的说明、模拟数据的真实模型参数，等等。</p>
<h3 id="names属性"><a href="#names属性" class="headerlink" title="names属性"></a>names属性</h3><p>有元素名的向量、列表、数据框等都有names属性， 许多R函数的输出本质上也是列表， 所以也有names属性。 用names(x)的格式读取或设定。 如：</p>
<pre><code>&gt; x &lt;- 1:5
&gt; y &lt;- x^2
&gt; lmr &lt;- lm(y ~ x)
&gt; print(names(lmr))

##  [1] &quot;coefficients&quot;  &quot;residuals&quot;     &quot;effects&quot;       &quot;rank&quot;         
##  [5] &quot;fitted.values&quot; &quot;assign&quot;        &quot;qr&quot;            &quot;df.residual&quot;  
##  [9] &quot;xlevels&quot;       &quot;call&quot;          &quot;terms&quot;         &quot;model&quot;</code></pre>
<p>对于没有元素名的向量x，names(x)的返回值是NULL。</p>
<h3 id="dim属性"><a href="#dim属性" class="headerlink" title="dim属性"></a>dim属性</h3><p>dim属性的存在表明对象是矩阵或一维、多维数组。 如：</p>
<pre><code>&gt; x &lt;- matrix(1:12, nrow=3, ncol=4)
&gt; attr(x, &quot;dim&quot;) # 等同于dim(x)

## [1] 3 4</code></pre>
<p>修改dim属性就将向量转换成矩阵（数组）， 或修改了矩阵的性质， 元素按列次序重排填入新的矩阵。如：</p>
<pre><code>&gt; x &lt;- 1:10
&gt; dim(x) &lt;- c(2,5)
&gt; x

##   [,1] [,2] [,3] [,4] [,5]
[1,]    1    3    5    7    9
[2,]    2    4    6    8   10</code></pre>
<p>R允许dim仅有一个元素， 这对应于一维向量， 与普通的没有dim属性的向量有区别。 另外要注意， <strong>取矩阵子集时如果结果仅有一列或一行， 除非用了drop=FALSE选项， 结果不再有dim属性， 退化成了普通向量</strong>。</p>
<h3 id="str-函数"><a href="#str-函数" class="headerlink" title="str()函数"></a>str()函数</h3><p>用print()函数可以显示对象内容。 如果内容很多， 显示行数可能也很多。 用str()函数可以显示对象的类型和主要结构及典型内容。例如</p>
<pre><code>&gt; s &lt;- 101:200
&gt; attr(s,&#39;author&#39;) &lt;- &#39;李小明&#39;
&gt; attr(s,&#39;date&#39;) &lt;- &#39;2016-09-12&#39;

&gt; str(s)

## int [1:100] 101 102 103 104 105 106 107 108 109 110 ...
 - attr(*, &quot;author&quot;)= chr &quot;李小明&quot;
 - attr(*, &quot;date&quot;)= chr &quot;2016-09-12&quot;

&gt; print(s)

## [1] 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120
 [21] 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140
 [41] 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160
 [61] 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180
 [81] 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200
attr(,&quot;author&quot;)
[1] &quot;李小明&quot;
attr(,&quot;date&quot;)
[1] &quot;2016-09-12&quot;</code></pre>
]]></content>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>R因子类型</title>
    <url>/2020/11/09/R%E5%9B%A0%E5%AD%90%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="R因子类型"><a href="#R因子类型" class="headerlink" title="R因子类型"></a>R因子类型</h2><h3 id="因子"><a href="#因子" class="headerlink" title="因子"></a>因子</h3><p>R中用<strong>因子代表数据中分类变量</strong>, 如性别、省份、职业。 有序因子代表有序量度，如打分结果，疾病严重程度等。</p>
<p>用factor()函数把字符型向量转换成因子，如</p>
<pre><code>&gt; x &lt;- c(&quot;男&quot;,&quot;女&quot;,&quot;女&quot;,&quot;男&quot;)
&gt; sex &lt;- factor(x)
&gt; sex
[1] 男 女 女 男
Levels: 男 女</code></pre>
<p>因子有class属性，取值为”factor”</p>
<pre><code>&gt; attributes(sex)
$levels
[1] &quot;男&quot; &quot;女&quot;

$class
[1] &quot;factor&quot;</code></pre>
<p>还有一个levels(水平值)属性， 此属性可以用levels()函数访问，如</p>
<pre><code>&gt; levels(sex)
[1] &quot;男&quot; &quot;女&quot;</code></pre>
<p>因子的levels属性可以看成是一个映射， 把整数值1,2,映射成这些水平值， 因子在保存时会保存成整数值1,2,等与水平值对应的编号。 这样可以节省存储空间， 在建模计算的程序中也比较有利于进行数学运算。</p>
<p>事实上， <strong>read.csv()**函数的默认操作会把输入文件的字符型列</strong>自动转换成因子**,这对于性别、职业、地名这样的列是合适的， 但是对于姓名、日期、详细地址这样的列则不合适。</p>
<p>所以，在read.csv()调用中经常加选项<strong>stringsAsFactors=FALSE</strong>选项禁止这样的自动转换，还可以用colClasses选项逐个指定每列的类型。</p>
<p>用**as.numeric()**可以把因子转换为纯粹的整数值，如</p>
<pre><code>&gt; as.numeric(sex)
[1] 1 2 2 1</code></pre>
<p>因为因子实际保存为整数值， 所以对因子进行一些字符型操作可能导致错误。 用as.character()可以把因子转换成原来的字符型，如</p>
<pre><code>&gt; as.character(sex)
[1] &quot;男&quot; &quot;女&quot; &quot;女&quot; &quot;男&quot;</code></pre>
<p>为了对因子执行字符型操作（如取子串）， 保险的做法是先用as.character()函数强制转换为字符型。</p>
<ul>
<li>factor()函数的一般形式为</li>
</ul>
<pre><code>    factor(x, levels = sort(unique(x), na.last = TRUE), 
           labels, exclude = NA, ordered = FALSE)</code></pre>
<p>可以用选项labels指定各水平的标签, 不指定时用各水平值的对应字符串。ordered取真值时表示因子水平是有次序的(按编码次序)。</p>
<p>在使用factor()函数定义因子时，如果知道自变量元素的所有可能取值，应尽可能使用levels=参数指定这些不同可能取值，这样，即使某个取值没有出现，此变量代表的含义和频数信息也是完整的。 自己指定levels=的另一好处是可以按正确的次序显示因子的分类统计值。</p>
<p>因为一个因子的levels属性是该因子独有的， 所以合并两个因子有可能造成错误。如</p>
<pre><code>&gt; li1 &lt;- factor(c(&#39;男&#39;, &#39;女&#39;))
&gt; li2 &lt;- factor(c(&#39;男&#39;, &#39;男&#39;))
&gt; c(li1, li2)
[1] 1 2 1 1</code></pre>
<p>结果不再是因子。 正确的做法是</p>
<pre><code>&gt; factor(c(as.character(li1), as.character(li2)))
[1] 男 女 男 男
Levels: 男 女</code></pre>
<p>即恢复成字符型后合并， 然后再转换为因子。 在合并两个数据框时也存在这样的问题。 当然，如果在定义li1和li2 时都用了levels=c(‘男’, ‘女’)选项， c(li1, li2)也能给出正确结果。</p>
<h2 id="tapply-函数"><a href="#tapply-函数" class="headerlink" title="tapply()函数"></a>tapply()函数</h2><p>可以按照因子分组然后每组计算另一变量的概括统计。 如</p>
<pre><code>&gt; h &lt;- c(165, 170, 168, 172)
&gt; tapply(h,sex,mean)
   男    女 
168.5 169.0 </code></pre>
<p>这里第一自变量h与与第二自变量sex是等长的， 对应元素分别为同一人的身高和性别， tapply()函数分男女两组计算了身高平均值。</p>
<h2 id="forcats包的因子函数"><a href="#forcats包的因子函数" class="headerlink" title="forcats包的因子函数"></a>forcats包的因子函数</h2><pre><code>&gt; library(forcats)</code></pre>
<p>在分类变量类数较多时，往往需要对因子水平另外排序、合并等， forcats包提供了一些针对因子的方便函数。</p>
<p>forcats::fct_reorder()可以根据不同因子水平分成的组中另一数值型变量的统计量值排序。 如：</p>
<pre><code>&gt; library(forcats)
&gt; set.seed(1)
&gt; fac &lt;- sample(c(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;),size = 30,replace = T)
&gt; fac
 [1] &quot;red&quot;   &quot;green&quot; &quot;blue&quot;  &quot;green&quot; &quot;blue&quot;  &quot;blue&quot; 
 [7] &quot;green&quot; &quot;blue&quot;  &quot;red&quot;   &quot;green&quot; &quot;red&quot;   &quot;red&quot;  
[13] &quot;red&quot;   &quot;red&quot;   &quot;red&quot;   &quot;red&quot;   &quot;green&quot; &quot;green&quot;
[19] &quot;red&quot;   &quot;green&quot; &quot;blue&quot;  &quot;green&quot; &quot;blue&quot;  &quot;green&quot;
[25] &quot;blue&quot;  &quot;red&quot;   &quot;blue&quot;  &quot;blue&quot;  &quot;green&quot; &quot;blue&quot; </code></pre>
<p>用 attribute() 函数查看此时fac的属性</p>
<pre><code>&gt; attributes(fac)
NULL</code></pre>
<p>显示，此时fac 并不是一个factor,利用factor函数对fac进行转化为factor</p>
<pre><code>&gt; fac &lt;- factor(x = fac,labels = c(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;))
&gt; attributes(fac)
$levels
[1] &quot;red&quot;   &quot;green&quot; &quot;blue&quot; 

$class
[1] &quot;factor&quot;</code></pre>
<p>转化完成之后，用rt()函数生成服从T分布生成伪随机数，并赋值给x</p>
<pre><code>&gt; x &lt;- round(100*(10+rt(30,2)))
&gt; res1 &lt;- tapply(x, fac, sd)
&gt; res1
##       red     green      blue 
##  370.9222  138.3185 1129.2587

&gt; barplot(res1)</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/prog-type-fact_files/figure-html/prog-type-fact22-1.png"></p>
<p>如果希望按照统计量次序对因子排序， 可以用forcats::fct_reorder()函数， 如</p>
<pre><code>&gt; fac2 &lt;- fct_reorder(fac,x,sd)
&gt; res2 &lt;- tapply(X = x,INDEX = fac2,FUN = sd)
&gt; barplot(res2)</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/prog-type-fact_files/figure-html/prog-type-fact23-1.png"></p>
<p>新的因子fac2的因子水平次序已经按照变量x的标准差从小到大排列。</p>
]]></content>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
</search>
