<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数值型向量及其运算</title>
    <url>/2020/10/31/R-%E6%95%B0%E5%80%BC%E5%9E%8B%E5%90%91%E9%87%8F%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="数值型向量"><a href="#数值型向量" class="headerlink" title="数值型向量"></a>数值型向量</h2><p><strong>向量</strong>是将若干个基础类型相同的值存储在一起， 各个元素可以按序号访问。 如果将若干个数值存储在一起可以用序号访问， 就叫做一个数值型向量。</p>
<p>用c()函数把多个元素或向量组合成一个向量。如</p>
<pre><code>&gt; marks &lt;- c(10, 6, 4, 7, 8)
&gt; x &lt;- c(1:3, 10:13)
&gt; x1 &lt;- c(1, 2)
&gt; x2 &lt;- c(3, 4)
&gt; x &lt;- c(x1, x2)
&gt; x

运行结果
## [1] 1 2 3 4</code></pre>
<p>10:13这样的写法表示从10到13的整数组成的向量。</p>
<p>用print()函数显示向量或在命令行中显示向量时， 每行显示的行首会有方括号和数字序号， 代表该行显示的第一个向量元素的下标。如</p>
<pre><code>&gt; 12345678901:12345678920

运行结果：
##  [1] 12345678901 12345678902 12345678903 12345678904 12345678905 12345678906
##  [7] 12345678907 12345678908 12345678909 12345678910 12345678911 12345678912
## [13] 12345678913 12345678914 12345678915 12345678916 12345678917 12345678918
## [19] 12345678919 12345678920</code></pre>
<p>length(x)可以求x的长度。 长度为零的向量表示为numeric(0)。 numeric()函数可以用来初始化一个指定元素个数而元素都等于零的数值型向量， 如numeric(10)会生成元素为10个零的向量。</p>
<pre><code>&gt; x &lt;- numeric(10)
&gt; x
## [1] 0 0 0 0 0 0 0 0 0 0</code></pre>
<h2 id="向量运算"><a href="#向量运算" class="headerlink" title="向量运算"></a>向量运算</h2><p>###标量和标量运算</p>
<p>单个数值称为标量， R没有单独的标量类型， 标量实际是长度为1的向量。</p>
<p>R中四则运算用+ - * / ^表示(加、减、乘、除、乘方)，如</p>
<pre><code>&gt; 1.5 + 2.3 - 0.6 + 2.1*1.2 - 1.5/0.5 + 2^3

## [1] 10.72</code></pre>
<p>R中四则运算仍遵从通常的优先级规则， 可以用圆括号()改变运算的先后次序。 如</p>
<pre><code>&gt; 1.5 + 2.3 - (0.6 + 2.1)*1.2 - 1.5/0.5 + 2^3
## [1] 5.56</code></pre>
<p>除了加、减、乘、除、乘方， R还支持整除运算和求余运算。 用%/%表示整除，用%%表示求余。如</p>
<pre><code>&gt; 5 %/% 3

## [1] 1


&gt; 5 %% 3
## [1] 2

&gt; 5.1 %/% 2.5
## [1] 2


&gt; 5.1 %% 2.5
## [1] 0.1</code></pre>
<p>向量与标量运算<br>向量与标量的运算为每个元素与标量的运算, 如</p>
<pre><code>&gt; x &lt;c(1, 10)
&gt; x + 2

## [1]  3 12


&gt; x - 2

## [1] -1  8



&gt; x * 2


## [1]  2 20


&gt; x / 2


## [1] 0.5 5.0


x ^ 2


## [1]   1 100


2 / x


## [1] 2.0 0.2



 2 ^ x


## [1]2 1024</code></pre>
<p>一个向量乘以一个标量， 就是线性代数中的数乘运算。</p>
<p>四则运算时如果有缺失值，缺失元素参加的运算相应结果元素仍缺失。 如</p>
<pre><code>&gt; c(1, NA, 3) + 10
## [1] 11 NA 13</code></pre>
<h3 id="等长向量运算"><a href="#等长向量运算" class="headerlink" title="等长向量运算"></a>等长向量运算</h3><p>等长向量的运算为对应元素两两运算。 如</p>
<pre><code>&gt; x1 &lt;- c(1, 10)
&gt; x2 &lt;- c(4, 2)
&gt; x1 + x2
## [1]  5 12
&gt; x1 - x2
## [1] -3  8
&gt; x1 * x2
## [1]  4 20
&gt; x1 / x2
## [1] 0.25 5.00</code></pre>
<p>两个等长向量的加、减运算就是线性代数中两个向量的加、减运算。</p>
<h3 id="不等长向量的运算"><a href="#不等长向量的运算" class="headerlink" title="不等长向量的运算"></a>不等长向量的运算</h3><p>两个不等长向量的四则运算， 如果其长度为倍数关系，规则是每次从头重复利用短的一个。 如</p>
<pre><code>&gt; x1 &lt;- c(10, 20)
&gt; x2 &lt;- c(1, 3, 5, 7)

&gt; x1 + x2
## [1] 11 23 15 27

&gt; x1 * x2
## [1]  10  60  50 140</code></pre>
<p>不仅是四则运算，R中有两个或多个向量按照元素一一对应参与某种运算或函数调用时， 如果向量长度不同，一般都采用这样的规则。</p>
<p>如果两个向量的长度不是倍数关系，会给出警告信息。如</p>
<pre><code>c(1,2) + c(1,2,3)

## Warning in c(1, 2) + c(1, 2, 3): 长的对象长度不是短的对象长度的整倍数
## [1] 2 4 4</code></pre>
<h2 id="向量函数"><a href="#向量函数" class="headerlink" title="向量函数"></a>向量函数</h2><h3 id="向量化的函数"><a href="#向量化的函数" class="headerlink" title="向量化的函数"></a>向量化的函数</h3><p>R中的函数一般都是向量化的: 在R中， 如果普通的一元函数以向量为自变量，一般会对每个元素计算。 这样的函数包括sqrt, log10, log, exp, sin, cos, tan等许多。 如</p>
<pre><code>&gt; sqrt(c(1, 4, 6.25))
## [1] 1.0 2.0 2.5</code></pre>
<p>为了查看这些基础的数学函数的列表，运行命令help.start()， 点击链接“Search Engine and Keywords”， 找到“Mathematics”栏目， 浏览其中的“arith”和“math”链接中的说明。 常用的数学函数有：</p>
<ul>
<li>舍入：ceiling, floor, round, signif, trunc, zapsmall</li>
<li>符号函数 sign</li>
<li>绝对值 abs</li>
<li>平方根 sqrt</li>
<li>对数与指数函数 log, exp, log10, log2</li>
<li>三角函数 sin, cos, tan</li>
<li>反三角函数 asin, acos, atan, atan2</li>
<li>双曲函数 sinh, cosh, tanh</li>
<li>反双曲函数 asinh, acosh, atanh</li>
</ul>
<p>有一些不太常用的数学函数：</p>
<ul>
<li>贝塔函数 beta, lbeta</li>
<li>伽玛函数 gamma, lgamma, digamma, trigamma, tetragamma, pentagamma</li>
<li>组合数 choose, lchoose</li>
<li>富利叶变换和卷积 fft, mvfft, convolve</li>
<li>正交多项式 poly</li>
<li>求根 polyroot, uniroot</li>
<li>最优化 optimize, optim</li>
<li>Bessel函数 besselI, besselK, besselJ, besselY</li>
<li>样条插值 spline, splinefun</li>
<li>简单的微分 deriv</li>
</ul>
<p>如果自己编写的函数没有考虑向量化问题， 可以用Vectorize()函数将其转换成向量化版本。</p>
<h2 id="排序函数"><a href="#排序函数" class="headerlink" title="排序函数"></a>排序函数</h2><p>sort(x)返回排序结果。 rev(x)返回把各元素排列次序反转后的结果。 order(x)返回排序用的下标。如</p>
<pre><code>&gt; x &lt;- c(33, 55, 11)

&gt; sort(x)
## [1] 11 33 55

&gt; rev(sort(x))
## [1] 55 33 11

&gt; order(x)
## [1] 3 1 2

&gt; x[order(x)]
## [1] 11 33 55</code></pre>
<p>例子中， order(x)结果中3是x的最小元素11所在的位置下标， 1是x的第二小元素33所在的位置下标， 2是x的最大元素55所在的位置下标。</p>
<h2 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h2><p>sum(求和), mean(求平均值), var(求样本方差), sd(求样本标准差), min(求最小值), max(求最大值), range(求最小值和最大值)等函数称为统计函数， 把输入向量看作样本，计算样本统计量。 prod求所有元素的乘积。</p>
<p>cumsum和cumprod计算累加和累乘积。如</p>
<pre><code>&gt; cumsum(1:5)
## [1]  1  3  6 10 15
&gt; cumprod(1:5)
## [1]   1   2   6  24 120</code></pre>
<p>其它一些类似函数有pmax, pmin, cummax, cummin等。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><strong>1. 显示1到100的整数的平方根和立方根（提示：立方根就是三分之一次方）。</strong></p>
<pre><code>计算平方根
&gt; sqrt(seq(1:100))
  [1]  1.000000  1.414214  1.732051  2.000000  2.236068  2.449490  2.645751  2.828427
  [9]  3.000000  3.162278  3.316625  3.464102  3.605551  3.741657  3.872983  4.000000
 [17]  4.123106  4.242641  4.358899  4.472136  4.582576  4.690416  4.795832  4.898979
 [25]  5.000000  5.099020  5.196152  5.291503  5.385165  5.477226  5.567764  5.656854
 [33]  5.744563  5.830952  5.916080  6.000000  6.082763  6.164414  6.244998  6.324555
 [41]  6.403124  6.480741  6.557439  6.633250  6.708204  6.782330  6.855655  6.928203
 [49]  7.000000  7.071068  7.141428  7.211103  7.280110  7.348469  7.416198  7.483315
 [57]  7.549834  7.615773  7.681146  7.745967  7.810250  7.874008  7.937254  8.000000
 [65]  8.062258  8.124038  8.185353  8.246211  8.306624  8.366600  8.426150  8.485281
 [73]  8.544004  8.602325  8.660254  8.717798  8.774964  8.831761  8.888194  8.944272
 [81]  9.000000  9.055385  9.110434  9.165151  9.219544  9.273618  9.327379  9.380832
 [89]  9.433981  9.486833  9.539392  9.591663  9.643651  9.695360  9.746794  9.797959
 [97]  9.848858  9.899495  9.949874 10.000000

#计算立方根
&gt; sqrtn &lt;- function(x,n) x^(1/n)
&gt; sqrtn(seq(1:100),3)
  [1] 1.000000 1.259921 1.442250 1.587401 1.709976 1.817121 1.912931 2.000000 2.080084
 [10] 2.154435 2.223980 2.289428 2.351335 2.410142 2.466212 2.519842 2.571282 2.620741
 [19] 2.668402 2.714418 2.758924 2.802039 2.843867 2.884499 2.924018 2.962496 3.000000
 [28] 3.036589 3.072317 3.107233 3.141381 3.174802 3.207534 3.239612 3.271066 3.301927
 [37] 3.332222 3.361975 3.391211 3.419952 3.448217 3.476027 3.503398 3.530348 3.556893
 [46] 3.583048 3.608826 3.634241 3.659306 3.684031 3.708430 3.732511 3.756286 3.779763
 [55] 3.802952 3.825862 3.848501 3.870877 3.892996 3.914868 3.936497 3.957892 3.979057
 [64] 4.000000 4.020726 4.041240 4.061548 4.081655 4.101566 4.121285 4.140818 4.160168
 [73] 4.179339 4.198336 4.217163 4.235824 4.254321 4.272659 4.290840 4.308869 4.326749
 [82] 4.344481 4.362071 4.379519 4.396830 4.414005 4.431048 4.447960 4.464745 4.481405
 [91] 4.497941 4.514357 4.530655 4.546836 4.562903 4.578857 4.594701 4.610436 4.626065
[100] 4.641589</code></pre>
<p><strong>2. 设有10个人的小测验成绩为:</strong></p>
<blockquote>
<p>77 60 91 73 85 82 83 100 66 75</p>
</blockquote>
<ol>
<li>把这10个成绩存入变量x;</li>
<li>从小到大排序；</li>
<li>计算order(x)，解释order(x)结果中第3项代表的意义。</li>
<li>计算这些成绩的平均值、标准差、最小值、最大值、中位数。</li>
<li>生成区间上等间隔的100个格子点存入变量x中。</li>
</ol>
<p>解答：</p>
<pre><code>    &gt; x &lt;- c(77,60,91,73,85,82,83,100,66,75)
    &gt; sort(x)
     [1]  60  66  73  75  77  82  83  85  91 100
    &gt; order(x)
     [1]  2  9  4 10  1  6  7  5  3  8
    #第三项为4，指代的是按从小到大排序的话排第三位的是之前排第4位的数字，即75
    &gt; mean(x)
    [1] 79.2
    &gt; sd(x)
    [1] 11.69805
    &gt; min(x)
    [1] 60
    &gt; max(x)
    [1] 100
    &gt; median(x)
    [1] 79.5
    #产生100个【0,1】之间的浮点数
    &gt; x &lt;- seq(0,1,length.out = 100)
    &gt; x
      [1] 0.00000000 0.01010101 0.02020202 0.03030303 0.04040404 0.05050505 0.06060606
      [8] 0.07070707 0.08080808 0.09090909 0.10101010 0.11111111 0.12121212 0.13131313
     [15] 0.14141414 0.15151515 0.16161616 0.17171717 0.18181818 0.19191919 0.20202020
     [22] 0.21212121 0.22222222 0.23232323 0.24242424 0.25252525 0.26262626 0.27272727
     [29] 0.28282828 0.29292929 0.30303030 0.31313131 0.32323232 0.33333333 0.34343434
     [36] 0.35353535 0.36363636 0.37373737 0.38383838 0.39393939 0.40404040 0.41414141
     [43] 0.42424242 0.43434343 0.44444444 0.45454545 0.46464646 0.47474747 0.48484848
     [50] 0.49494949 0.50505051 0.51515152 0.52525253 0.53535354 0.54545455 0.55555556
     [57] 0.56565657 0.57575758 0.58585859 0.59595960 0.60606061 0.61616162 0.62626263
     [64] 0.63636364 0.64646465 0.65656566 0.66666667 0.67676768 0.68686869 0.69696970
     [71] 0.70707071 0.71717172 0.72727273 0.73737374 0.74747475 0.75757576 0.76767677
     [78] 0.77777778 0.78787879 0.79797980 0.80808081 0.81818182 0.82828283 0.83838384
     [85] 0.84848485 0.85858586 0.86868687 0.87878788 0.88888889 0.89898990 0.90909091
     [92] 0.91919192 0.92929293 0.93939394 0.94949495 0.95959596 0.96969697 0.97979798
     [99] 0.98989899 1.00000000</code></pre>
]]></content>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>R向量下标和子集</title>
    <url>/2020/11/02/R%E5%90%91%E9%87%8F%E4%B8%8B%E6%A0%87%E5%92%8C%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<h2 id="正整数下标"><a href="#正整数下标" class="headerlink" title="正整数下标"></a>正整数下标</h2><p>对向量x, 在后面加方括号和下标可以访问向量的元素和子集。</p>
<p>设x &lt;- c(1, 4, 6.25)。 x[2]取出第二个元素； x[2] &lt;- 99修改第二个元素。 x[c(1,3)]取出第1、3号元素； x[c(1,3)] &lt;- c(11, 13)修改第1、3号元素。 下标可重复。 例如</p>
<pre><code>&gt; x &lt;- c(1, 4, 6.25)
&gt; x[2]
## [1] 4

&gt; x[2] &lt;- 99; x
## [1]  1.00 99.00  6.25

&gt; x[c(1,3)]
## [1] 1.00 6.25

&gt; x[c(1,3)] &lt;- c(11, 13); x
## [1] 11 99 13

&gt; x[c(1,3,1)]
## [1] 11 13 11</code></pre>
<h2 id="负整数下标"><a href="#负整数下标" class="headerlink" title="负整数下标"></a>负整数下标</h2><p>负下标表示扣除相应的元素后的子集，如</p>
<pre><code>&gt; x &lt;- c(1,4,6.25)
&gt; x[-2]
## [1] 1.00 6.25
&gt; x[-c(1,3)]
## [1] 4</code></pre>
<p>负整数下标不能与正整数下标同时用来从某一向量中取子集， 比如，x[c(1,-2)]没有意义。</p>
<h2 id="空下标与零下标"><a href="#空下标与零下标" class="headerlink" title="空下标与零下标"></a>空下标与零下标</h2><p>x[]表示取x的全部元素作为子集。 这与x本身不同，比如</p>
<pre><code>&gt; x &lt;- c(1,4,6.25)
&gt; x[] &lt;- 999
&gt; x
## [1] 999 999 999

&gt; x &lt;- c(1,4,6.25)
&gt; x &lt;- 999
&gt; x
## [1] 999</code></pre>
<p>x[0]是一种少见的做法， 结果返回类型相同、长度为零的向量， 如numeric(0)。 相当于空集。</p>
<p>当与正整数下标一起使用时会被忽略。 当0与负整数下标一起使用时也会被忽略。</p>
<h2 id="下标超界"><a href="#下标超界" class="headerlink" title="下标超界"></a>下标超界</h2><p>设向量x长度为, 则使用正整数下标时下标应在中取值。 如果使用大于的下标， 读取时返回缺失值，并不出错。 给超出的下标元素赋值， 则向量自动变长， 中间没有赋值的元素为缺失值。 例如</p>
<pre><code>&gt; x &lt;- c(1,4,6.25)
&gt; x[5]
## [1] NA

&gt; x
## [1] 1.00 4.00 6.25

&gt; x[5] &lt;- 9
&gt; x
## [1] 1.00 4.00 6.25   NA 9.00</code></pre>
<p>虽然R的语法对下标超界不视作错误， 但是这样的做法往往来自不良的程序思路， 而且对程序效率有影响， 所以实际编程中应避免下标超界。</p>
<h2 id="逻辑下标"><a href="#逻辑下标" class="headerlink" title="逻辑下标"></a>逻辑下标</h2><p>下标可以是与向量等长的逻辑表达式， 一般是关于本向量或者与本向量等长的其它向量的比较结果，如</p>
<pre><code>x &lt;- c(1,4,6.25)
x[x &gt; 3]
## [1] 4.00 6.25</code></pre>
<p>取出x的大于3的元素组成的子集。</p>
<p>要注意的是，如果逻辑下标中有缺失值， 对应结果也是缺失值。 所以，在用逻辑下标作子集选择时， 一定要考虑到缺失值问题。正确的做法是加上!is.na前提， 如</p>
<pre><code>&gt; x &lt;- c(1, 4, 6.25, NA)
&gt; x[x &gt; 2]
## [1] 4.00 6.25   NA

&gt; x[!is.na(x) &amp; x &gt; 2]
## [1] 4.00 6.25</code></pre>
<h2 id="which-、which-min-、which-max-函数"><a href="#which-、which-min-、which-max-函数" class="headerlink" title="which()、which.min()、which.max()函数"></a>which()、which.min()、which.max()函数</h2><p>函数<strong>which()**可以用来</strong>找到满足条件的下标**， 如</p>
<pre><code>&gt; x &lt;- c(3, 4, 3, 5, 7, 5, 9)
&gt; which(x &gt; 5)
## [1] 5 7

&gt; seq(along=x)[x &gt; 5]
## [1] 5 7</code></pre>
<p>这里seq(along=x)会生成由x的下标组成的向量。 用which.min()、which.max求最小值的下标和最大值的下标， 不唯一时只取第一个。如</p>
<pre><code>&gt; which.min(x)
## [1] 1

&gt; which.max(x)
## [1] 7</code></pre>
<h2 id="元素名"><a href="#元素名" class="headerlink" title="元素名"></a>元素名</h2><p>向量可以为每个元素命名。如</p>
<pre><code>&gt; ages &lt;- c(&quot;李明&quot;=25,&quot;田晓霞&quot;=21,&quot;孙少平&quot;=22)
&gt; ages
## 李明 田晓霞 孙少平 
    25     21     22</code></pre>
<p> 或者</p>
<pre><code>&gt; ages &lt;- c(25,21,22)
&gt; names(ages)&lt;- c(&quot;李明&quot;,&quot;田晓霞&quot;,&quot;孙少平&quot;)
&gt; ages
## 李明 田晓霞 孙少平 
    25     21     22 </code></pre>
<p>或者</p>
<pre><code>&gt; ages &lt;- setNames(c(25,21,22),c(&quot;李明&quot;,&quot;田晓霞&quot;,&quot;孙少平&quot;))
&gt; ages
## 李明 田晓霞 孙少平 
    25     21     22 </code></pre>
<p>这时可以用元素名或元素名向量作为向量的下标，如</p>
<pre><code>&gt; ages[&quot;李明&quot;]
## 李明 
  25

&gt; ages[&quot;李明&quot;] &lt;- 11
&gt; ages
## 李明 田晓霞 孙少平 
    11     21     22 </code></pre>
<p>这实际上建立了字符串到数值的映射表。</p>
<p>用字符串作为下标时， 如果该字符串不在向量的元素名中， 读取时返回缺失值结果， 赋值时该向量会增加一个元素并以该字符串为元素名。</p>
<p>带有元素名的向量也可以是字符型或其它基本类型，如</p>
<pre><code>&gt; sex &lt;- c(&quot;孙少平&quot;=&quot;男&quot;,&quot;田晓霞&quot;=&quot;女&quot;)
&gt; sex
## 孙少平 田晓霞 
  &quot;男&quot;   &quot;女&quot; </code></pre>
<p>除了给向量元素命名外， 在矩阵和数据框中还可以给行、列命名， 这会使得程序的扩展更为容易和安全。</p>
<p>R允许仅给部分元素命名， 这时其它元素名字为空字符串。 不同元素的元素名一般应该是不同的， 否则在使用元素作为下标时会发生误读， 但是R语法允许存在重名。</p>
<p>用unname(x)返回去掉了元素名的x的副本， 用names(x) &lt;- NULL可以去掉x的元素</p>
<pre><code>&gt; unname(ages)
## [1] 11 21 22

&gt; ages
## 李明 田晓霞 孙少平 
    11     21     22 

&gt; names(ages) &lt;- NULL
&gt; ages
## [1] 11 21 22</code></pre>
<h2 id="用R向量下标作映射"><a href="#用R向量下标作映射" class="headerlink" title="用R向量下标作映射"></a>用R向量下标作映射</h2><p>R在使用整数作为向量下标时，允许使用重复下标， 这样可以把数组x看成一个的整数到 x[1], x[2], , x[n]的一个映射表, 其中是x的长度。 比如，某商店有三种礼品，编号为1,2,3， 价格分别为68, 88和168。令</p>
<pre><code>&gt; price.map &lt;- c(68, 88, 168)</code></pre>
<p>设某个收银员在一天内分别售出礼品编号为3,2,1,1,2,2,3， 可以用如下的映射方式获得售出的这些礼品对应的价格：</p>
<pre><code>&gt; items &lt;- c(3,2,1,1,2,2,3)
&gt; y &lt;- price.map[items]; print(y)
## [1] 168  88  68  68  88  88 168</code></pre>
<p>R向量可以用字符型向量作下标， 字符型下标也允许重复， 所以可以把带有元素名的R向量看成是元素名到元素值的映射表。 比如，设sex为10个学生的性别（男、女）</p>
<pre><code>&gt; sex &lt;- c(&quot;男&quot;, &quot;男&quot;, &quot;女&quot;, &quot;女&quot;, &quot;男&quot;, &quot;女&quot;, &quot;女&quot;, &quot;女&quot;, &quot;女&quot;, &quot;男&quot;)</code></pre>
<p>希望把每个学生按照性别分别对应到蓝色和红色。 首先建立一个R向量当作映射</p>
<pre><code>&gt; sex.color &lt;- c(&quot;男&quot;=&quot;blue&quot;, &quot;女&quot;=&quot;red&quot;)</code></pre>
<p>用R向量sex.color当作映射，可以获得每个学生对应的颜色</p>
<pre><code>&gt; cols &lt;- sex.color[sex]; print(cols)
##     男     男     女     女     男     女     女     女     女     男 
## &quot;blue&quot; &quot;blue&quot;  &quot;red&quot;  &quot;red&quot; &quot;blue&quot;  &quot;red&quot;  &quot;red&quot;  &quot;red&quot;  &quot;red&quot; &quot;blue&quot;</code></pre>
<p>这样的映射结果中带有不必要的元素名， 用unname()函数可以去掉元素名，如</p>
<pre><code>&gt; unname(cols)
##  [1] &quot;blue&quot; &quot;blue&quot; &quot;red&quot;  &quot;red&quot;  &quot;blue&quot; &quot;red&quot;  &quot;red&quot;  &quot;red&quot;  &quot;red&quot;  &quot;blue&quot;</code></pre>
<h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><p>可以把向量x看成一个集合，但是其中的元素允许有重复。 用unique(x)可以获得x的所有不同值。如</p>
<pre><code>&gt; unique(c(1, 5, 2, 5))
## [1] 1 5 2</code></pre>
<p>用a %in% x判断a的每个元素是否属于向量x，如</p>
<pre><code>&gt; 5 %in% c(1,5,2)
## [1] TRUE

&gt; c(5,6) %in% c(1,5,2)
## [1]  TRUE FALSE</code></pre>
<p>与%in运算符类似， 函数match(x, table)对向量x的每个元素， 从向量table中查找其首次出现位置并返回这些位置。 没有匹配到的元素位置返回NA_integer_(整数型缺失值)。 如</p>
<pre><code>&gt; match(5, c(1,5,2))
## [1] 2

&gt; match(5, c(1,5,2,5))
## [1] 2

&gt; match(c(2,5), c(1,5,2,5))
## [1] 3 2

&gt; match(c(2,5,0), c(1,5,2,5))
## [1]  3  2 NA</code></pre>
<p>用intersect(x,y)求交集，结果中不含重复元素，如</p>
<pre><code>&gt; intersect(c(5, 7), c(1, 5, 2, 5))
## [1] 5</code></pre>
<p>用union(x,y)求并集，结果中不含重复元素，如</p>
<pre><code>&gt; union(c(5, 7), c(1, 5, 2, 5))
## [1] 5 7 1 2</code></pre>
<p>用setdiff(x,y)求差集，即x的元素中不属于y的元素组成的集合， 结果中不含重复元素，如</p>
<pre><code>&gt; setdiff(c(5, 7), c(1, 5, 2, 5))
## [1] 7</code></pre>
<p>用setequal(x,y)判断两个集合是否相等， 不受次序与重复元素的影响，如</p>
<pre><code>&gt; setequal(c(1,5,2), c(2,5,1))
## [1] TRUE

&gt; setequal(c(1,5,2), c(2,5,1,5))
## [1] TRUE</code></pre>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>设文件class.csv内容如下:</p>
<p>name,sex,age,height,weight<br>Alice,F,13,56.5,84<br>Becka,F,13,65.3,98<br>Gail,F,14,64.3,90<br>Karen,F,12,56.3,77<br>Kathy,F,12,59.8,84.5<br>Mary,F,15,66.5,112<br>Sandy,F,11,51.3,50.5<br>Sharon,F,15,62.5,112.5<br>Tammy,F,14,62.8,102.5<br>Alfred,M,14,69,112.5<br>Duke,M,14,63.5,102.5<br>Guido,M,15,67,133<br>James,M,12,57.3,83<br>Jeffrey,M,13,62.5,84<br>John,M,12,59,99.5<br>Philip,M,16,72,150<br>Robert,M,12,64.8,128<br>Thomas,M,11,57.5,85<br>William,M,15,66.5,112</p>
<p>用如下程序可以把上述文件读入为R数据框d.class, 并取出其中的name和age列到变量name和age中：</p>
<pre><code>&gt; d.class &lt;- read.csv(&quot;class.csv&quot;, header=TRUE, stringsAsFactors=FALSE)
&gt; name &lt;- d.class[,&quot;name&quot;]
&gt; age &lt;- d.class[,&quot;age&quot;]
&gt; age
 [1] 13 13 14 12 12 15 11 15 14 14 14 15 12 13 12 16 12 11 15
&gt; d.class
      name sex age height weight
1    Alice   F  13   56.5   84.0
2    Becka   F  13   65.3   98.0
3     Gail   F  14   64.3   90.0
4    Karen   F  12   56.3   77.0
5    Kathy   F  12   59.8   84.5
6     Mary   F  15   66.5  112.0
7    Sandy   F  11   51.3   50.5
8   Sharon   F  15   62.5  112.5
9    Tammy   F  14   62.8  102.5
10  Alfred   M  14   69.0  112.5
11    Duke   M  14   63.5  102.5
12   Guido   M  15   67.0  133.0
13   James   M  12   57.3   83.0
14 Jeffrey   M  13   62.5   84.0
15    John   M  12   59.0   99.5
16  Philip   M  16   72.0  150.0
17  Robert   M  12   64.8  128.0
18  Thomas   M  11   57.5   85.0
19 William   M  15   66.5  112.0</code></pre>
<ol>
<li><p>求出age中第3, 5, 7号的值；</p>
<pre><code> &gt; age[c(3,5,7)]
 ## [1] 14 12 11</code></pre>
</li>
<li><p>用变量age, 求出达到15岁及以上的那些值；</p>
<pre><code> &gt; age[age&gt;=15]
 ## [1] 15 15 15 16 15 </code></pre>
</li>
<li><p>用变量name和age, 求出Mary与James的年龄。</p>
<pre><code> &gt; set &lt;- setNames(age,name)
 &gt; set[match(c(&quot;Mary&quot;,&quot;James&quot;),name)]
  Mary James 
    15    12 </code></pre>
</li>
<li><p>求age中除Mary与James这两人之外的那些人的年龄值，保存到变量age1中。</p>
</li>
</ol>
<pre><code>    &gt; a &lt;- match(c(&quot;Mary&quot;,&quot;James&quot;),name)
    &gt; b &lt;- (1:length(name))

    &gt; a
    [1]  6 13
    &gt; b
     [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19

    &gt; age1 &lt;- set[setdiff(b,a)]
    &gt; age1
      Alice   Becka    Gail   Karen   Kathy   Sandy  Sharon   Tammy  Alfred    Duke   Guido 
         13      13      14      12      12      11      15      14      14      14      15 
    Jeffrey    John  Philip  Robert  Thomas William 
         13      12      16      12      11      15 </code></pre>
]]></content>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>R因子类型</title>
    <url>/2020/11/09/R%E5%9B%A0%E5%AD%90%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="R因子类型"><a href="#R因子类型" class="headerlink" title="R因子类型"></a>R因子类型</h2><h3 id="因子"><a href="#因子" class="headerlink" title="因子"></a>因子</h3><p>R中用<strong>因子代表数据中分类变量</strong>, 如性别、省份、职业。 有序因子代表有序量度，如打分结果，疾病严重程度等。</p>
<p>用factor()函数把字符型向量转换成因子，如</p>
<pre><code>&gt; x &lt;- c(&quot;男&quot;,&quot;女&quot;,&quot;女&quot;,&quot;男&quot;)
&gt; sex &lt;- factor(x)
&gt; sex
[1] 男 女 女 男
Levels: 男 女</code></pre>
<p>因子有class属性，取值为”factor”</p>
<pre><code>&gt; attributes(sex)
$levels
[1] &quot;男&quot; &quot;女&quot;

$class
[1] &quot;factor&quot;</code></pre>
<p>还有一个levels(水平值)属性， 此属性可以用levels()函数访问，如</p>
<pre><code>&gt; levels(sex)
[1] &quot;男&quot; &quot;女&quot;</code></pre>
<p>因子的levels属性可以看成是一个映射， 把整数值1,2,映射成这些水平值， 因子在保存时会保存成整数值1,2,等与水平值对应的编号。 这样可以节省存储空间， 在建模计算的程序中也比较有利于进行数学运算。</p>
<p>事实上， <strong>read.csv()**函数的默认操作会把输入文件的字符型列</strong>自动转换成因子**,这对于性别、职业、地名这样的列是合适的， 但是对于姓名、日期、详细地址这样的列则不合适。</p>
<p>所以，在read.csv()调用中经常加选项<strong>stringsAsFactors=FALSE</strong>选项禁止这样的自动转换，还可以用colClasses选项逐个指定每列的类型。</p>
<p>用**as.numeric()**可以把因子转换为纯粹的整数值，如</p>
<pre><code>&gt; as.numeric(sex)
[1] 1 2 2 1</code></pre>
<p>因为因子实际保存为整数值， 所以对因子进行一些字符型操作可能导致错误。 用as.character()可以把因子转换成原来的字符型，如</p>
<pre><code>&gt; as.character(sex)
[1] &quot;男&quot; &quot;女&quot; &quot;女&quot; &quot;男&quot;</code></pre>
<p>为了对因子执行字符型操作（如取子串）， 保险的做法是先用as.character()函数强制转换为字符型。</p>
<ul>
<li>factor()函数的一般形式为</li>
</ul>
<pre><code>    factor(x, levels = sort(unique(x), na.last = TRUE), 
           labels, exclude = NA, ordered = FALSE)</code></pre>
<p>可以用选项labels指定各水平的标签, 不指定时用各水平值的对应字符串。ordered取真值时表示因子水平是有次序的(按编码次序)。</p>
<p>在使用factor()函数定义因子时，如果知道自变量元素的所有可能取值，应尽可能使用levels=参数指定这些不同可能取值，这样，即使某个取值没有出现，此变量代表的含义和频数信息也是完整的。 自己指定levels=的另一好处是可以按正确的次序显示因子的分类统计值。</p>
<p>因为一个因子的levels属性是该因子独有的， 所以合并两个因子有可能造成错误。如</p>
<pre><code>&gt; li1 &lt;- factor(c(&#39;男&#39;, &#39;女&#39;))
&gt; li2 &lt;- factor(c(&#39;男&#39;, &#39;男&#39;))
&gt; c(li1, li2)
[1] 1 2 1 1</code></pre>
<p>结果不再是因子。 正确的做法是</p>
<pre><code>&gt; factor(c(as.character(li1), as.character(li2)))
[1] 男 女 男 男
Levels: 男 女</code></pre>
<p>即恢复成字符型后合并， 然后再转换为因子。 在合并两个数据框时也存在这样的问题。 当然，如果在定义li1和li2 时都用了levels=c(‘男’, ‘女’)选项， c(li1, li2)也能给出正确结果。</p>
<h2 id="tapply-函数"><a href="#tapply-函数" class="headerlink" title="tapply()函数"></a>tapply()函数</h2><p>可以按照因子分组然后每组计算另一变量的概括统计。 如</p>
<pre><code>&gt; h &lt;- c(165, 170, 168, 172)
&gt; tapply(h,sex,mean)
   男    女 
168.5 169.0 </code></pre>
<p>这里第一自变量h与与第二自变量sex是等长的， 对应元素分别为同一人的身高和性别， tapply()函数分男女两组计算了身高平均值。</p>
<h2 id="forcats包的因子函数"><a href="#forcats包的因子函数" class="headerlink" title="forcats包的因子函数"></a>forcats包的因子函数</h2><pre><code>&gt; library(forcats)</code></pre>
<p>在分类变量类数较多时，往往需要对因子水平另外排序、合并等， forcats包提供了一些针对因子的方便函数。</p>
<p>forcats::fct_reorder()可以根据不同因子水平分成的组中另一数值型变量的统计量值排序。 如：</p>
<pre><code>&gt; library(forcats)
&gt; set.seed(1)
&gt; fac &lt;- sample(c(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;),size = 30,replace = T)
&gt; fac
 [1] &quot;red&quot;   &quot;green&quot; &quot;blue&quot;  &quot;green&quot; &quot;blue&quot;  &quot;blue&quot; 
 [7] &quot;green&quot; &quot;blue&quot;  &quot;red&quot;   &quot;green&quot; &quot;red&quot;   &quot;red&quot;  
[13] &quot;red&quot;   &quot;red&quot;   &quot;red&quot;   &quot;red&quot;   &quot;green&quot; &quot;green&quot;
[19] &quot;red&quot;   &quot;green&quot; &quot;blue&quot;  &quot;green&quot; &quot;blue&quot;  &quot;green&quot;
[25] &quot;blue&quot;  &quot;red&quot;   &quot;blue&quot;  &quot;blue&quot;  &quot;green&quot; &quot;blue&quot; </code></pre>
<p>用 attribute() 函数查看此时fac的属性</p>
<pre><code>&gt; attributes(fac)
NULL</code></pre>
<p>显示，此时fac 并不是一个factor,利用factor函数对fac进行转化为factor</p>
<pre><code>&gt; fac &lt;- factor(x = fac,labels = c(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;))
&gt; attributes(fac)
$levels
[1] &quot;red&quot;   &quot;green&quot; &quot;blue&quot; 

$class
[1] &quot;factor&quot;</code></pre>
<p>转化完成之后，用rt()函数生成服从T分布生成伪随机数，并赋值给x</p>
<pre><code>&gt; x &lt;- round(100*(10+rt(30,2)))
&gt; res1 &lt;- tapply(x, fac, sd)
&gt; res1
##       red     green      blue 
##  370.9222  138.3185 1129.2587

&gt; barplot(res1)</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/prog-type-fact_files/figure-html/prog-type-fact22-1.png"></p>
<p>如果希望按照统计量次序对因子排序， 可以用forcats::fct_reorder()函数， 如</p>
<pre><code>&gt; fac2 &lt;- fct_reorder(fac,x,sd)
&gt; res2 &lt;- tapply(X = x,INDEX = fac2,FUN = sd)
&gt; barplot(res2)</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/prog-type-fact_files/figure-html/prog-type-fact23-1.png"></p>
<p>新的因子fac2的因子水平次序已经按照变量x的标准差从小到大排列。</p>
<p>有时在因子水平数较多时仅想将特定的一个或几个水平次序放到因子水平最前面， 可以用forcats::fct_relevel()函数， 如：</p>
<pre><code>&gt; fac3 &lt;- fct_relevel(fac,&quot;blue&quot;)

&gt; levels(fac3)
[1] &quot;blue&quot;  &quot;red&quot;   &quot;green&quot;</code></pre>
<p>fct_relevel()第一个参数是要修改次序的因子， 后续可以有多个字符型参数表示要提前的水平。</p>
<p>forcats::fct_recode()可以修改每个水平的名称， 如：</p>
<pre><code>&gt; fac4 &lt;- fct_recode(fac,&quot;红&quot;=&quot;red&quot;,&quot;蓝&quot;=&quot;blue&quot;,&quot;绿&quot;=&quot;green&quot;)
&gt; attributes(fac4)
$levels
[1] &quot;红&quot; &quot;绿&quot; &quot;蓝&quot;

$class
[1] &quot;factor&quot;</code></pre>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>设文件<a href="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/class.csv">class.csv</a>中包含如下内容:</p>
<pre><code>name,sex,age,height,weight
Alice,F,13,56.5,84
Becka,F,13,65.3,98
Gail,F,14,64.3,90
Karen,F,12,56.3,77
Kathy,F,12,59.8,84.5
Mary,F,15,66.5,112
Sandy,F,11,51.3,50.5
Sharon,F,15,62.5,112.5
Tammy,F,14,62.8,102.5
Alfred,M,14,69,112.5
Duke,M,14,63.5,102.5
Guido,M,15,67,133
James,M,12,57.3,83
Jeffrey,M,13,62.5,84
John,M,12,59,99.5
Philip,M,16,72,150
Robert,M,12,64.8,128
Thomas,M,11,57.5,85
William,M,15,66.5,112</code></pre>
<p>用如下程序把该文件读入为R数据框d.class, 其中的sex列已经自动转换为因子。 取出其中的sex和age列到变量sex和age中</p>
<pre><code>&gt; d.class &lt;- read.csv(&#39;class.csv&#39;, header=TRUE)
&gt; sex &lt;- d.class[,&#39;sex&#39;]
&gt; age &lt;- d.class[,&#39;age&#39;]</code></pre>
<ol>
<li><p>统计并显示列出sex的不同值频数；</p>
</li>
<li><p>分男女两组分别求年龄最大值；</p>
</li>
<li><p>把sex变量转换为一个新的因子，F显示成“Female”，M显示成“Male”。</p>
</li>
</ol>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>1.</p>
<pre><code>&gt; table(sex)
sex
 F  M 
 9 10 </code></pre>
<p>2.</p>
<pre><code>&gt; tapply(age, sex, max)
 F  M 
15 16 </code></pre>
<p>3.</p>
<pre><code>&gt; sex
 [1] F F F F F F F F F M M M M M M M M M M
Levels: F M
&gt; sex2 &lt;- fct_recode(sex,&quot;Female&quot;=&quot;F&quot;,&quot;Male&quot;=&quot;M&quot;)
&gt; sex2
 [1] Female Female Female Female Female Female Female
 [8] Female Female Male   Male   Male   Male   Male  
[15] Male   Male   Male   Male   Male  
Levels: Female Male</code></pre>
]]></content>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>R输入输出</title>
    <url>/2020/11/18/R%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h2 id="输入输出的简单方法"><a href="#输入输出的简单方法" class="headerlink" title="输入输出的简单方法"></a>输入输出的简单方法</h2><h3 id="简单的输出"><a href="#简单的输出" class="headerlink" title="简单的输出"></a>简单的输出</h3><p>用print()函数显示某个变量或表达式的值， 如</p>
<pre><code>&gt; x &lt;- 1.234
&gt; print(x)
## [1] 1.234

&gt; y &lt;- c(1,3,5)
&gt; print(y[2:3])
## [1] 3 5</code></pre>
<p>在命令行使用R时， 直接以变量名或表达式作为命令可以起到用print()函数显示的相同效果。</p>
<p><strong>用cat()函数把字符串、变量、表达式连接起来显示</strong>， 其中变量和表达式的类型一般是标量或向量，不能是矩阵、列表等复杂数据。 如</p>
<pre><code>&gt; cat(&quot;x =&quot;, x, &quot;\n&quot;)
x = 1.234</code></pre>
<p>注意cat()显示中需要换行需要在自变量中包含字符串”\n”， 即换行符。</p>
<p>cat()默认显示在命令行窗口， 为了写入指定文件中， 在cat()调用中用file=选项， 这时如果已有文件会把原有内容覆盖， 为了在已有文件时不覆盖原有内容而是在末尾添加， 在cat()中使用append=TRUE选项。 如:</p>
<pre><code>&gt; cat(&quot;=== 结果文件 ===\n&quot;, file=&quot;res.txt&quot;)
&gt; cat(&quot;x =&quot;, x, &quot;\n&quot;, file=&quot;res.txt&quot;, append=TRUE)</code></pre>
<p>R命令行环境中定义的变量、函数会保存在工作空间中，并在退出R会话时可以保存到硬盘文件中。 用save()命令要求把指定的若干个变量（直接用名字，不需要表示成字符串）保存到用file=指定的文件中， 随后可以用load()命令恢复到工作空间中。</p>
<p>虽然允许保存多个变量到同一文件中， 但尽可能仅保存一个变量， 而且使用变量名作为文件名。 用save()保存的R特殊格式的文件是通用的， 不依赖于硬件和操作系统。 如</p>
<pre><code>&gt; save(scores, file=&quot;scores.RData&quot;)
&gt; load(&quot;scores.RData&quot;)</code></pre>
<p>保存多个变量，如x, zeta，命令如：</p>
<pre><code>save(x, zeta, file=&quot;myvars20200315.RData&quot;)</code></pre>
<p>或</p>
<pre><code>save(list = c(&quot;x&quot;, &quot;zeta&quot;), file=&quot;myvars20200315.RData&quot;)</code></pre>
<p>对于一个数据框， 可以用**write.csv()或readr::write_csv()**将其保存为逗号分隔的文本文件， 这样的文件可以很容易地被其它软件识别访问， 如Microsoft Excel软件可以很容易地把这样的文件读成电子表格。 用如</p>
<pre><code>&gt; library(tidyverse)
&gt; da &lt;- tibble(&quot;name&quot;=c(&quot;李明&quot;, &quot;刘颖&quot;, &quot;张浩&quot;),
+              &quot;age&quot;=c(15, 17, 16))
&gt; da
# A tibble: 3 x 2
  name    age
  &lt;chr&gt; &lt;dbl&gt;
1 李明     15
2 刘颖     17
3 张浩     16
&gt; write_csv(da,&quot;mydata.csv&quot;)</code></pre>
<p>结果生成的mydata.csv文件内容如下：</p>
<pre><code>name,age
李明,15
刘颖,17
张浩,16</code></pre>
<p>但是，在Microsoft的中文版Windows操作系统中， 默认编码是GB编码， 用write_csv()生成的CSV文件总是使用UTF-8编码， 系统中的MS Office 软件不能自动识别这样编码的CSV文件， 可以改用write_csv_excel()函数； 基本R的write.csv()函数不存在这个问题。</p>
<h2 id="CSV格式"><a href="#CSV格式" class="headerlink" title="CSV格式"></a>CSV格式</h2><p>对于保存在文本文件中的电子表格数据， R可以用read.csv(), read.table(), read.delim(), read.fwf()等函数读入, 但是建议在readr包的支持下用**read_csv(), read_table2(), read_delim(), read_fwf()**等函数读入， 这些将读入的数据框保存为tibble类型， tibble是数据框的一个变种， 改善了数据框的一些不适当的设计。 readr的读入速度比基本R软件的read.csv()等函数的速度快得多， 速度可以相差10倍， 也不自动将字符型列转换成因子， 不自动修改变量名为合法变量名， 不设置行名。</p>
<p>对于中小规模的数据， CSV格式作为文件交换格式比较合适， 兼容性强， 各种数据管理软件与统计软件都可以很容易地读入和生成这样格式的文件， 但是特别大型的数据读入效率很低。</p>
<p>CSV格式的文件用逗号分隔开同一行的数据项， 一般第一行是各列的列名（变量名）。 对于数值型数据， 只要表示成数值常量形式即可。 对于字符型数据， 可以用双撇号包围起来， 也可以不用撇号包围。 但是， 如果数据项本身包含逗号， 就需要用双撇号包围。 例如，下面是一个名为testcsv.csv的文件内容， 其中演示了内容中有逗号、有双撇号的情况。</p>
<pre><code>id,words
1,&quot;PhD&quot;
2,Master&#39;s degree 
3,&quot;Bond,James&quot;
4,&quot;A &quot;&quot;special&quot;&quot; gift&quot;</code></pre>
<p>为读入上面的内容，只要用如下程序:</p>
<pre><code>&gt; d &lt;- read_csv(&quot;testcsv.csv&quot;)</code></pre>
<p>读入的数据框显示如下:</p>
<pre><code># A tibble: 4 × 2
     id            words
  &lt;int&gt;            &lt;chr&gt;
1     1              PhD
2     2  Master&#39;s degree
3     3       Bond,James
4     4 A &quot;special&quot; gift</code></pre>
<h2 id="从字符串读入"><a href="#从字符串读入" class="headerlink" title="从字符串读入"></a>从字符串读入</h2><p>read_csv()还可以从字符串读入一个数据框，如</p>
<pre><code>&gt; d.small &lt;- read_csv(&quot;name,x,y
John, 33, 95
Kim, 21, 64
Sandy, 49, 100
&quot;)

&gt; d.small

## # A tibble: 3 x 3
##   name      x     y
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 John     33    95
## 2 Kim      21    64
## 3 Sandy    49   100</code></pre>
<h2 id="read-csv选项"><a href="#read-csv选项" class="headerlink" title="read_csv选项"></a>read_csv选项</h2><p>read_csv()的skip=选项跳过开头的若干行。 当数据不包含列名时， 只要指定col_names=FALSE， 变量将自动命名为X1, X2, …， 也可以用col_names=指定各列的名字，如</p>
<pre><code>&gt; d.small &lt;- read_csv(&quot;John, 33, 95
Kim, 21, 64
Sandy, 49, 100
&quot;, col_names=c(&quot;name&quot;, &quot;x&quot;, &quot;y&quot;) )

&gt; d.small
## # A tibble: 3 x 3
##   name      x     y
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 John     33    95
## 2 Kim      21    64
## 3 Sandy    49   100</code></pre>
<h2 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a>文件访问</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>输入输出可以针对命令行，针对文件，R支持扩展的文件类型， 称为“连接(connection)”。</p>
<p>函数file()生成到一个普通文件的连接， 函数url()生成一个到指定的URL的连接， 函数gzfile, bzfile, xzfile, unz支持对 压缩过的文件的访问（不是压缩包，只对一个文件压缩）。这些函数大概的用法如下：</p>
<pre><code>file(&quot;path&quot;, open=&quot;&quot;, blocking=T,
     encoding = getOption(&quot;encoding&quot;), 
     raw = FALSE)

url(description, open = &quot;&quot;, blocking = TRUE,
    encoding = getOption(&quot;encoding&quot;))

textConnection(description, open=&quot;r&quot;, 
    local = FALSE,
    encoding = c(&quot;&quot;, &quot;bytes&quot;, &quot;UTF-8&quot;))

gzfile(description, open = &quot;&quot;, 
       encoding = getOption(&quot;encoding&quot;),
       compression = 6)

bzfile(description, open = &quot;&quot;, 
       encoding = getOption(&quot;encoding&quot;),
       compression = 9)

xzfile(description, open = &quot;&quot;, 
       encoding = getOption(&quot;encoding&quot;),
       compression = 6)

unz(description, filename, open = &quot;&quot;,
    encoding = getOption(&quot;encoding&quot;))</code></pre>
<p>生成连接的函数不自动打开连接。 给定一个未打开的连接， 读取函数从中读取时会自动打开连接， 函数结束时自动关闭连接。 用open()函数打开连接，返回一个句柄； 生成连接时可以用open参数要求打开连接。 要多次从一个连接读取时就应该先打开连接， 读取完毕用close函数关闭。</p>
<p>函数textConnection()打开一个字符串用于读写。</p>
<p>在生成连接与打开连接的函数中用open参数指定打开方式， 取值为：</p>
<ul>
<li>r—文本型只读;</li>
<li>w—文本型只写;</li>
<li>a—文本型末尾添加;</li>
<li>rb—二进制只读;</li>
<li>wb—二进制只写;</li>
<li>ab—二进制末尾添加;</li>
<li>r+或r+b—允许读和写;</li>
<li>w+或w+b—允许读和写，但刚打开时清空文件;</li>
<li>a+或a+b—末尾添加并允许读。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>列表</title>
    <url>/2020/11/11/%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>R中列表(list)类型来保存<strong>不同类型</strong>的数据。 一个主要目的是提供R分析结果输出包装： 输出一个变量， 这个变量包括回归系数、预测值、残差、检验结果等等一系列不能放到规则形状数据结构中的内容。 实际上，数据框也是列表的一种， 但是<u>数据框要求各列等长， 而列表不要求</u>。</p>
<p>列表可以有多个元素， 但是与向量不同的是， 列表的不同元素的类型可以不同， 比如， 一个元素是数值型向量， 一个元素是字符串， 一个元素是标量， 一个元素是另一个列表。</p>
<p>定义列表用函数list(), 如</p>
<pre><code>&gt; rec &lt;- list(name=&quot;李明&quot;, age=30,
+scores=c(85, 76, 90))
&gt; rec</code></pre>
<p><br>执行结果：</p>
<pre><code>$name
[1] &quot;李明&quot;

$age
[1] 30

$scores
[1] 85 76 90</code></pre>
<p>用typeof()函数判断一个列表， 返回结果为list。 可以用is.list()函数判断某个对象是否列表类型。</p>
<pre><code>&gt; typeof(rec)


[1] &quot;list&quot;</code></pre>
<h2 id="列表元素访问"><a href="#列表元素访问" class="headerlink" title="列表元素访问"></a>列表元素访问</h2><p>列表的一个元素也可以称为列表的一个“变量”， 单个列表元素必须用两重方括号格式访问，如</p>
<pre><code>&gt; rec[[3]][2]
[1] 76

&gt; rec[[&quot;age&quot;]]
[1] 30
&gt; rec[[&quot;scores&quot;]]
[1] 85 76 90</code></pre>
<p>列表的单个元素也可以用$格式访问，如</p>
<pre><code>&gt; rec$age
[1] 30</code></pre>
<p>如果使用单重方括号对列表取子集， 结果还是列表而不是列表元素，如</p>
<pre><code>&gt; rec[3]
$scores
[1] 85 76 90

&gt; typeof(rec[3])
[1] &quot;list&quot;</code></pre>
<p>列表一般都应该有元素名， 元素名可以看成是变量名， 列表中的每个元素看成一个变量。 用names()函数查看和修改元素名。 如</p>
<pre><code>&gt; names(rec)
[1] &quot;name&quot;   &quot;age&quot;    &quot;scores&quot;

&gt; typeof(names(rec))
[1] &quot;character&quot;

&gt; names(rec)[names(rec)==&quot;scores&quot;] &lt;- &quot;三科分数&quot;
&gt; names(rec)
[1] &quot;name&quot;     &quot;age&quot;      &quot;三科分数&quot;

&gt; rec[[&quot;三科分数&quot;]]
[1] 85 76 90</code></pre>
<p>可以修改列表元素内容。 如</p>
<pre><code>&gt; rec$三科分数[2] &lt;- 0
&gt; rec
$name
[1] &quot;李明&quot;

$age
[1] 30

$三科分数
[1] 85  0 90</code></pre>
<p>直接给列表<strong>不存在的元素名定义元素值就添加了新元素</strong>， 而且不同于使用向量，对于列表而言这是很正常的做法，比如</p>
<pre><code>&gt; rec[&quot;身高&quot;] &lt;- 183
&gt; rec
$name
[1] &quot;李明&quot;

$age
[1] 30

$三科分数
[1] 85  0 90

$身高
[1] 183</code></pre>
<p>把某个列表元素赋值为NULL就删掉这个元素。 如</p>
<pre><code>&gt; rec$三科分数 &lt;- NULL
&gt; rec
$name
[1] &quot;李明&quot;

$age
[1] 30

$身高
[1] 183</code></pre>
<p>在list()函数中允许定义元素为NULL，这样的元素是存在的，如：</p>
<pre><code>&gt; li &lt;- list(a=120, b=&quot;F&quot;, c=NULL)
&gt; li
$a
[1] 120

$b
[1] &quot;F&quot;

$c
NULL</code></pre>
<p>但是，要把已经存在的元素修改为NULL值而不是删除此元素， 或者给列表增加一个取值为NULL的元素， 这时需要用单重的方括号取子集， 这样的子集会保持其列表类型， 给这样的子列表赋值为list(NULL)，如：</p>
<pre><code>&gt; li[&quot;b&quot;] &lt;- list(NULL)
&gt; li
$a
[1] 120

$b
NULL

$c
NULL</code></pre>
<h2 id="列表类型转换"><a href="#列表类型转换" class="headerlink" title="列表类型转换"></a>列表类型转换</h2><p>用as.list()把一个其它类型的对象转换成列表； 如</p>
<pre><code>&gt; li1 &lt;- as.list(li1)

&gt; li1    </code></pre>
<br>

<pre><code>[[1]]
[1] 1

[[2]]
[1] 2

[[3]]
[1] 3</code></pre>
<p>用unlist()函数把列表转换成基本向量</p>
<pre><code>&gt; li2 &lt;- list(x=1, y=c(2,3))
&gt; li2
$x
[1] 1

$y
[1] 2 3

&gt; unlist(li2)
 x y1 y2 
 1  2  3 </code></pre>
<h2 id="返回列表的函数示例–-strsplit"><a href="#返回列表的函数示例–-strsplit" class="headerlink" title="返回列表的函数示例– strsplit()"></a>返回列表的函数示例– strsplit()</h2><p>strsplit()输入一个字符型向量并指定一个分隔符， 返回一个项数与字符型向量元素个数相同的列表， 列表每项对应于字符型向量中一个元素的拆分结果。 如</p>
<pre><code>&gt; x &lt;- c(&quot;10, 8, 7&quot;, &quot;5, 2, 2&quot;, &quot;3, 7, 8&quot;, &quot;8, 8, 9&quot;)
&gt; res &lt;- strsplit(x, &quot;,&quot;); res
[[1]]
[1] &quot;10&quot; &quot; 8&quot; &quot; 7&quot;

[[2]]
[1] &quot;5&quot;  &quot; 2&quot; &quot; 2&quot;

[[3]]
[1] &quot;3&quot;  &quot; 7&quot; &quot; 8&quot;

[[4]]
[1] &quot;8&quot;  &quot; 8&quot; &quot; 9&quot;</code></pre>
]]></content>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>字符型数据及处理</title>
    <url>/2020/11/01/%E5%AD%97%E7%AC%A6%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="字符型向量"><a href="#字符型向量" class="headerlink" title="字符型向量"></a>字符型向量</h2><p>字符型向量是元素为字符串的向量。 如</p>
<pre><code>&gt; s1 &lt;- c(&#39;abc&#39;, &#39;&#39;, &#39;a cat&#39;, NA, &#39;李明&#39;)</code></pre>
<p>注意空字符串并不能自动认为是缺失值， 字符型的缺失值仍用NA表示。</p>
<h2 id="paste-函数"><a href="#paste-函数" class="headerlink" title="paste()函数"></a>paste()函数</h2><p>针对字符型数据最常用的R函数是paste()函数。 paste()用来连接两个字符型向量， 元素一一对应连接， 默认用空格连接。 如paste(c(“ab”, “cd”), c(“ef”, “gh”)) 结果相当于c(“ab ef”, “cd gh”)。</p>
<p>paste()在连接两个字符型向量时采用R的一般向量间运算规则， 而且可以自动把数值型向量转换为字符型向量。 可以作一对多连接， 如paste(“x”, 1:3)结果相当于c(“x 1”, “x 2”, “x 3”)。</p>
<p>用sep=指定分隔符， 如paste(“x”, 1:3, sep=””)结果相当于c(“x1”, “x2”, “x3”)。</p>
<p>使用collapse=参数可以把字符型向量的各个元素连接成一个单一的字符串, 如paste(c(“a”, “b”, “c”), collapse=””)结果相当于”abc”。</p>
<h2 id="转换大小写"><a href="#转换大小写" class="headerlink" title="转换大小写"></a>转换大小写</h2><p>toupper()函数把字符型向量内容转为大写， tolower()函数转为小写。 比如，toupper(‘aB cd’)结果为”AB CD”， tolower(c(‘aB’, ‘cd’))结果相当于c(“ab” “cd”)。 这两个函数可以用于不区分大小写的比较， 比如，不论x的值是’JAN’, ‘Jan’还是’jan’， toupper(x)==’JAN’的结果都为TRUE。</p>
<h2 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h2><p>用nchar(x, type=’bytes’)计算字符型向量x中每个字符串的以字节为单位的长度，这一点对中英文是有差别的， 中文通常一个汉字占两个字节，英文字母、数字、标点占一个字节。 用nchar(x, type=’chars’)计算字符型向量x中每个字符串的以字符个数为单位的长度，这时一个汉字算一个单位。</p>
<p>在画图时可以用strwidth()函数计算某个字符串或表达式占用的空间大小。</p>
<h2 id="取子串"><a href="#取子串" class="headerlink" title="取子串"></a>取子串</h2><p>substr(x, start, stop)从字符串x中取出从第start个到第stop个的子串， 如</p>
<pre><code>&gt; substr(&#39;JAN07&#39;, 1, 3)
## [1] &quot;JAN&quot;</code></pre>
<p>如果x是一个字符型向量，substr将对每个元素取子串。如</p>
<pre><code>&gt; substr(c(&#39;JAN07&#39;, &#39;MAR66&#39;), 1, 3)
## [1] &quot;JAN&quot; &quot;MAR&quot;</code></pre>
<p>用substring(x, start)可以从字符串x中取出从第start个到末尾的子串。如</p>
<pre><code>&gt; substring(c(&#39;JAN07&#39;, &#39;MAR66&#39;), 4)
## [1] &quot;07&quot; &quot;66&quot;</code></pre>
<p>##类型转换##</p>
<p>用as.numeric()把内容是数字的字符型值转换为数值，如</p>
<pre><code>&gt; substr(&#39;JAN07&#39;, 4, 5)
## [1] &quot;07&quot;

&gt; substr(&#39;JAN07&#39;, 4, 5) + 2000
## Error in substr(&quot;JAN07&quot;, 4, 5) + 2000 : 
##   non-numeric argument to binary operator

&gt; as.numeric(substr(&#39;JAN07&#39;, 4, 5)) + 2000
## [1] 2007

&gt; as.numeric(substr(c(&#39;JAN07&#39;, &#39;MAR66&#39;), 4, 5))
## [1]  7 66</code></pre>
<p>as.numeric()是向量化的， 可以转换一个向量的每个元素为数值型。</p>
<p>用as.character()函数把数值型转换为字符型，如</p>
<pre><code>&gt; as.character((1:5)*5)
## [1] &quot;5&quot;  &quot;10&quot; &quot;15&quot; &quot;20&quot; &quot;25&quot;</code></pre>
<p>如果自变量本来已经是字符型则结果不变。</p>
<p>为了用指定的格式数值型转换成字符型， 可以使用sprintf()函数， 其用法与C语言的sprintf()函数相似， 只不过是向量化的。例如</p>
<pre><code>&gt; sprintf(&#39;file%03d.txt&#39;, c(1, 99, 100))
## [1] &quot;file001.txt&quot; &quot;file099.txt&quot; &quot;file100.txt&quot;</code></pre>
<h2 id="字符串拆分"><a href="#字符串拆分" class="headerlink" title="字符串拆分"></a>字符串拆分</h2><p>用strsplit()函数可以把一个字符串按照某种分隔符拆分开，例如</p>
<pre><code>&gt; x &lt;- &#39;10,8,7&#39;
&gt; strsplit(x, &#39;,&#39;, fixed=TRUE)[[1]]
## [1] &quot;10&quot; &quot;8&quot;  &quot;7&quot;

&gt; sum(as.numeric(strsplit(x, &#39;,&#39;, fixed=TRUE)[[1]]))
## [1] 25</code></pre>
<p>因为strsplit()的结果是一个列表， 这个函数延后再详细讲。</p>
<h2 id="字符串替换功能"><a href="#字符串替换功能" class="headerlink" title="字符串替换功能"></a>字符串替换功能</h2><p>用gsub()可以替换字符串中的子串， 这样的功能经常用在数据清理中。 比如，把数据中的中文标点改为英文标点， 去掉空格，等等。 如</p>
<pre><code>&gt; x &lt;- &#39;1, 3; 5&#39;
&gt; gsub(&#39;;&#39;, &#39;,&#39;, x, fixed=TRUE)
## [1] &quot;1, 3, 5&quot;

&gt; strsplit(gsub(&#39;;&#39;, &#39;,&#39;, x, fixed=TRUE), &#39;,&#39;)[[1]]
## [1] &quot;1&quot;  &quot; 3&quot; &quot; 5&quot;</code></pre>
<p>字符串x中分隔符既有逗号又有分号， 上面的程序用gsub()把分号都换成逗号。</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式(regular expression)是一种匹配某种字符串模式的方法。 用这样的方法，可以从字符串中查找某种模式的出现位置， 替换某种模式，等等。 这样的技术可以用于文本数据的预处理， 比如用网络爬虫下载的大量网页文本数据。 R中支持perl语言格式的正则表达式， grep()和grepl()函数从字符串中查询某个模式， sub()和gsub()替换某模式。 比如， 下面的程序把多于一个空格替换成一个空格</p>
<pre><code>&gt; gsub(&#39;[[:space:]]+&#39;, &#39; &#39;, &#39;a   cat  in a box&#39;, perl=TRUE)
## [1] &quot;a cat in a box&quot;</code></pre>
]]></content>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>数据框</title>
    <url>/2020/11/15/%E6%95%B0%E6%8D%AE%E6%A1%86/</url>
    <content><![CDATA[<h2 id="数据框"><a href="#数据框" class="headerlink" title="数据框"></a>数据框</h2><p>统计分析中最常见的原始数据形式是类似于数据库表或Excel数据表的形式。 这样形式的数据在R中叫做数据框(data.frame)。 数据框类似于一个矩阵，有n行、p列， 但各列允许有不同类型：数值型向量、因子、字符型向量、日期时间向量。 同一列的数据类型相同。 在R中数据框是一个特殊的列表， 其每个列表元素都是一个长度相同的向量。 事实上，数据框还允许一个元素是一个矩阵， 但这样会使得某些读入数据框的函数发生错误。</p>
<p>函数data.frame()可以生成数据框，如</p>
<pre><code>&gt; d &lt;- data.frame(
+     name=c(&quot;李明&quot;, &quot;张聪&quot;, &quot;王建&quot;), 
+     age=c(30, 35, 28), 
+     height=c(180, 162, 175),
+     stringsAsFactors=FALSE)

&gt; d
  name age height
1 李明  30    180
2 张聪  35    162
3 王建  28    175</code></pre>
<p>data.frame()函数会将字符型列转换成因子， 加选项<strong>stringsAsFactors=FALSE</strong>可以避免这样的转换.</p>
<pre><code>&gt; nrow(d)
[1] 3

&gt; names(d)
[1] &quot;name&quot;   &quot;age&quot;    &quot;height&quot;</code></pre>
<p>用as.data.frame(x)可以把x转换成数据框。 如果x是一个向量， 转换结果是以x为唯一一列的数据框。 如果x是一个列表并且列表元素都是长度相同的向量， 转换结果中每个列表变成数据框的一列。 如果x是一个矩阵，转换结果把矩阵的每列变成数据框的一列。</p>
<h2 id="数据框内容访问"><a href="#数据框内容访问" class="headerlink" title="数据框内容访问"></a>数据框内容访问</h2><p>数据框可以用矩阵格式访问，如</p>
<pre><code>&gt; d[2,3]
[1] 162</code></pre>
<p>访问单个元素。</p>
<pre><code>&gt; d[[2]]
[1] 30 35 28</code></pre>
<p>访问第二列，结果为向量。</p>
<pre><code>&gt; class(d[,2])
[1] &quot;numeric&quot;

&gt; d[[&quot;age&quot;]]
[1] 30 35 28

&gt; d[,&quot;age&quot;]
[1] 30 35 28

&gt; d$age
[1] 30 35 28</code></pre>
<p>因为数据框的一行不一定是相同数据类型， 所以数据框的一行作为子集， 结果还是数据框，而不是向量。如</p>
<pre><code>&gt; d[2,]
  name age height
2 张聪  35    162

&gt; class(d[2,])
[1] &quot;data.frame&quot;</code></pre>
<p>可以同时取行子集和列子集，如</p>
<pre><code>&gt; d[1:2, &quot;age&quot;]
[1] 30 35

&gt; d[1:2, c(&quot;age&quot;, &quot;height&quot;)]
  age height
1  30    180
2  35    162

&gt; d[d[&quot;height&quot;]&gt;=170,]
  name age height
1 李明  30    180
3 王建  28    175</code></pre>
<p>与矩阵类似地是， 用如d[,”age”], d[,2]这样的方法取出的数据框的单个列是向量而不再是数据框。 但是，如果取出两列或者两列以上， 结果则是数据框。 如果取列子集时不能预先知道取出的列个数， 则子集结果有可能是向量也有可能是数据框， 容易造成后续程序错误。 对一般的数据框， 可以在取子集的方括号内加上drop=FALSE选项， 确保取列子集的结果总是数据框。 数据框的改进类型tibble在取出列子集时保持为tibble格式。</p>
<p>对数据框变量名按照字符串与集合进行操作可以实现复杂的列子集筛选。</p>
<h2 id="数据框的行名"><a href="#数据框的行名" class="headerlink" title="数据框的行名"></a>数据框的行名</h2><p>数据框每一行可以有行名， 这在原始的S语言和传统的R语言中是重要的技术， 但是在改进类型tibble中则取消了行名， 需要用列名实现功能一般改用left_join()函数实现。</p>
<p>比如，每一行定义行名为身份证号，则可以唯一识别各行。 下面的例子以姓名作为行名:</p>
<pre><code>&gt; rownames(d) &lt;- d$name
&gt; d$name &lt;- NULL
&gt; d
     age height
李明  30    180
张聪  35    162
王建  28    17</code></pre>
<p>用数据框的行名可以建立一个值到多个值的对应表。 比如，有如下的数据框：</p>
<pre><code>&gt; dm &lt;- data.frame(
+     &quot;年级&quot;=1:6,
+     &quot;出游&quot;=c(0, 2, 2, 2, 2, 1),
+     &quot;疫苗&quot;=c(T, F, F, F, T, F)
+ )

&gt; dm
  年级 出游  疫苗
1    1    0  TRUE
2    2    2 FALSE
3    3    2 FALSE
4    4    2 FALSE
5    5    2  TRUE
6    6    1 FALSE</code></pre>
<p>其中“出游”是每个年级安排的出游次数， “疫苗”是该年级有全体无计划免疫注射。 把年级变成行名，可以建立年级到出游次数与疫苗注射的对应表：</p>
<pre><code>&gt; dm[[&quot;年级&quot;]] &lt;- NULL
&gt; dm
  出游  疫苗
1    0  TRUE
2    2 FALSE
3    2 FALSE
4    2 FALSE
5    2  TRUE
6    1 FALSE</code></pre>
<p>这样，假设某个社区的小学中抽取的4个班的年级为 c(2,1,3)， 其对应的出游和疫苗注射信息可查询如下：</p>
<pre><code>&gt; ind &lt;- c(2,1,3)
&gt; dm[as.character(ind),]
  出游  疫苗
2    2 FALSE
1    0  TRUE
3    2 FALSE</code></pre>
<p>实际上，这个例子可以不用行名而是用match()函数实现。 match(x, table)对x的每个元素返回其在table中出现的位置序号。 找不到的元素返回NA。 如：</p>
<pre><code>&gt; match(c(12, 15), 11:14)
[1]  2 NA</code></pre>
<p>对于上面的学校年级信息查询的例子， 可以首先查找每个班对应的年级在数据框中的行序号， 然后再返回这些行组成的数据框：</p>
<pre><code>&gt; dm &lt;- data.frame(
+   &quot;年级&quot;=1:6,
+   &quot;出游&quot;=c(0, 2, 2, 2, 2, 1),
+   &quot;疫苗&quot;=c(T, F, F, F, T, F)
+ )

&gt; ind &lt;- match(c(2,1,3),dm[[&quot;年级&quot;]])
&gt; ind
[1] 2 1 3

&gt; dm[ind,]
  年级 出游  疫苗
2    2    2 FALSE
1    1    0  TRUE
3    3    2 FALSE</code></pre>
<p>实际上，这个例子可以不用行名而是用match()函数实现。 match(x, table)对x的每个元素返回其在table中出现的位置序号。 找不到的元素返回NA。 如：</p>
<pre><code>&gt; match(c(12, 15), 11:14)
[1]  2 NA</code></pre>
<p>对于上面的学校年级信息查询的例子， 可以首先查找每个班对应的年级在数据框中的行序号， 然后再返回这些行组成的数据框：</p>
<pre><code>&gt; dm &lt;- data.frame(
+   &quot;年级&quot;=1:6,
+   &quot;出游&quot;=c(0, 2, 2, 2, 2, 1),
+   &quot;疫苗&quot;=c(T, F, F, F, T, F)
+ )

&gt; ind &lt;- match(c(2,1,3),dm[[&quot;年级&quot;]])
&gt; ind
[1] 2 1 3

&gt; dm[ind,]
  年级 出游  疫苗
2    2    2 FALSE
1    1    0  TRUE
3    3    2 FALSE</code></pre>
<p>对于代替数据框的tibble类型， 如果要实现行名的功能， 可以将行名作为单独的一列， 然后用dplyr包的inner_join()、left_join()、full_join()等函数横向合并数据集。</p>
<h2 id="数据框与矩阵的区别"><a href="#数据框与矩阵的区别" class="headerlink" title="数据框与矩阵的区别"></a>数据框与矩阵的区别</h2><p>数据框不能作为矩阵参加矩阵运算。 需要时，可以用as.matrix()函数转换数据框或数据框的子集为矩阵。 如</p>
<pre><code>&gt; d2 &lt;- as.matrix(d[,c(&quot;height&quot;,&quot;age&quot;)])
&gt; d2
     height age
[1,]    180  30
[2,]    162  35
[3,]    175  28

&gt; d4 &lt;- tidyr::expand_grid(
+     group=1:3,
+     subgroup=1:2,
+     obs=1:2)</code></pre>
<p>结果的数据框d有三个变量: group是大组，共分3个大组，每组4个观测； subgroup是子组，在每个大组内分为2个子组，每个子组2个观测。 共有个观测3x2x2=12（行）。</p>
<pre><code>&gt; print(d4)
# A tibble: 12 x 3
   group subgroup   obs
   &lt;int&gt;    &lt;int&gt; &lt;int&gt;
 1     1        1     1
 2     1        1     2
 3     1        2     1
 4     1        2     2
 5     2        1     1
 6     2        1     2
 7     2        2     1
 8     2        2     2
 9     3        1     1
10     3        1     2
11     3        2     1
12     3        2     2</code></pre>
<h2 id="tibble类型"><a href="#tibble类型" class="headerlink" title="tibble类型"></a>tibble类型</h2><p>tibble类型是一种改进的数据框。 readr包的read_csv()函数是read.csv()函数的一个改进版本， 它将CSV文件读入为tibble类型，如文件<a href="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/class.csv">class.csv</a>的读入:</p>
<pre><code>&gt; library(tibble)

载入程辑包：&#39;tibble&#39;

The following object is masked from &#39;package:ShortRead&#39;:

    view

&gt; library(readr)
&gt; t.class &lt;- read_csv(&quot;class.csv&quot;)

-- Column specification --------------------------------
cols(
  name = col_character(),
  sex = col_character(),
  age = col_double(),
  height = col_double(),
  weight = col_double()
)

&gt; t.class
# A tibble: 19 x 5
   name    sex     age height weight
   &lt;chr&gt;   &lt;chr&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
 1 Alice   F        13   56.5   84  
 2 Becka   F        13   65.3   98  
 3 Gail    F        14   64.3   90  
 4 Karen   F        12   56.3   77  
 5 Kathy   F        12   59.8   84.5
 6 Mary    F        15   66.5  112  
 7 Sandy   F        11   51.3   50.5
 8 Sharon  F        15   62.5  112. 
 9 Tammy   F        14   62.8  102. 
10 Alfred  M        14   69    112. 
11 Duke    M        14   63.5  102. 
12 Guido   M        15   67    133  
13 James   M        12   57.3   83  
14 Jeffrey M        13   62.5   84  
15 John    M        12   59     99.5
16 Philip  M        16   72    150  
17 Robert  M        12   64.8  128  
18 Thomas  M        11   57.5   85  
19 William M        15   66.5  112 </code></pre>
<p>tibble类型的类属依次为tbl_df, tbl, data.frame：</p>
<pre><code>&gt; class(t.class)
[1] &quot;spec_tbl_df&quot; &quot;tbl_df&quot;      &quot;tbl&quot;        
[4] &quot;data.frame&quot; </code></pre>
<p>实际上，旧式数据框支持行名，有如下的缺点：</p>
<ol>
<li><p>行名本身往往也是有效的数据，如身份证号， 将有效数据以数据框中的列和行名两种不同形式保存， 增加了复杂度；</p>
</li>
<li><p>为了使用某些变量辨识不同的行（观测）， 行名也具有局限性： 行名必须是相互不同的， 必须是字符型， 而用来区分各个观测的变量有可能有多个， 也可能不是字符型。</p>
</li>
<li><p>行名要求互不相同是有局限性的， 如果用来辨识各行的变量有重复值， 就可以构成对各行的一种自然的分组。</p>
</li>
</ol>
<p>tibble类型允许其中的列是列表类型， 这样， 该列的每个元素就可以是复杂类型， 比如建模结果（列表）， 元素之间可以保存不等长的值。 如：</p>
<pre><code>&gt; tibble(x = 1:3,
+        y = list(1, 1:2, 1:3))
# A tibble: 3 x 2
      x y        
  &lt;int&gt; &lt;list&gt;   
1     1 &lt;dbl [1]&gt;
2     2 &lt;int [2]&gt;
3     3 &lt;int [3]&gt;</code></pre>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>假设<a href="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/class.csv">class.csv</a>已经读入为R数据框d.class, 其中的sex列已经自动转换为因子。</p>
<ol>
<li><p>显示d.class中年龄至少为15的行子集；</p>
</li>
<li><p>显示女生且年龄至少为15的学生姓名和年龄；</p>
</li>
<li><p>取出数据框中的age变量赋给变量x。</p>
</li>
</ol>
<h2 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h2><p>###1.</p>
<pre><code>&gt; d.class[d.class[[&quot;age&quot;]]&gt;=15,]
      name sex age height weight
6     Mary   F  15   66.5  112.0
8   Sharon   F  15   62.5  112.5
12   Guido   M  15   67.0  133.0
16  Philip   M  16   72.0  150.0
19 William   M  15   66.5  112.0</code></pre>
<p>###2.</p>
<p>我采取的办法有些笨，相当于一步一步来解决这个问题。首先因为第二题是在第一题的基础上来解决的。所以我先将上一题筛选的子集独立保存为一个data frame,命名为fliter_d.class,接着依旧安装上一题的思路，再增加一个筛选项。</p>
<pre><code>&gt; fliter_d.class &lt;- d.class[d.class[[&quot;age&quot;]]&gt;=15,]
&gt; fliter_d.class
      name sex age height weight
6     Mary   F  15   66.5  112.0
8   Sharon   F  15   62.5  112.5
12   Guido   M  15   67.0  133.0
16  Philip   M  16   72.0  150.0
19 William   M  15   66.5  112.0

&gt; fliter_d.class[fliter_d.class[[&quot;sex&quot;]]==&quot;F&quot;,]
    name sex age height weight
6   Mary   F  15   66.5  112.0
8 Sharon   F  15   62.5  112.5</code></pre>
<p>最后因为要看只姓名和年龄</p>
<pre><code>&gt; fliter_d.class[fliter_d.class[[&quot;sex&quot;]]==&quot;F&quot;,][,c(1,3)]
    name age
6   Mary  15
8 Sharon  15</code></pre>
<p>当然也可以直接使用dplyr包下的fliter()函数</p>
<pre><code>&gt; d.class %&gt;%
+     filter(sex==&quot;F&quot;, age&gt;=15) %&gt;%
+     knitr::kable()


|name   |sex | age| height| weight|
|:------|:---|---:|------:|------:|
|Mary   |F   |  15|   66.5|  112.0|
|Sharon |F   |  15|   62.5|  112.5|</code></pre>
<p>或者更加直接一点</p>
<pre><code>&gt; filter(d.class,sex == &quot;F&quot;, age &gt;= 15)
    name sex age height weight
1   Mary   F  15   66.5  112.0
2 Sharon   F  15   62.5  112.5</code></pre>
<p>###3.</p>
<pre><code>&gt; x &lt;- d.class[[&quot;age&quot;]]
&gt; x
 [1] 13 13 14 12 12 15 11 15 14 14 14 15 12 13 12 16 12
[18] 11 15</code></pre>
]]></content>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型及性质</title>
    <url>/2020/11/05/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%80%A7%E8%B4%A8/</url>
    <content><![CDATA[<h2 id="存储模式与基本类型"><a href="#存储模式与基本类型" class="headerlink" title="存储模式与基本类型"></a>存储模式与基本类型</h2><p>R的变量可以存储多种不同的数据类型， 可以用typeof()函数来返回一个变量或表达式的类型。比如</p>
<pre><code>&gt; typeof(1:3)
## [1] &quot;integer&quot;

&gt; typeof(c(1,2,3))
## [1] &quot;double&quot;

&gt; typeof(c(1, 2.1, 3))
## [1] &quot;double&quot;

&gt; typeof(c(TRUE, NA, FALSE))
## [1] &quot;logical&quot;

&gt; typeof(&#39;Abc&#39;)
## [1] &quot;character&quot;

&gt; typeof(factor(c(&#39;F&#39;, &#39;M&#39;, &#39;M&#39;, &#39;F&#39;)))
## [1] &quot;integer&quot;</code></pre>
<p>*<em>注意**</em>因子的结果是integer而不是因子。*</p>
<p>R还有两个函数mode()和storage.mode()起到与typeof()类似的作用， 这是为了提供与S语言兼容所遗留的， 应停止使用。</p>
<p>R中数据的最基本的类型包括logical, integer, double, character, complex, raw, 其它数据类型都是由基本类型组合或转变得到的。 character类型就是字符串类型， raw类型是直接使用其二进制内容的类型。 为了判断某个向量x保存的基本类型， 可以用is.xxx()类函数， 如is.integer(x), is.double(x), is.numeric(x), is.logical(x), is.character(x), is.complex(x), is.raw(x)。 其中<strong>is.numeric(x)对integer和double内容都返回真值。</strong></p>
<p>在R语言中数值一般看作double, 如果需要明确表明某些数值是整数， 可以在数值后面附加字母L，如</p>
<pre><code>&gt; is.integer(c(1, -3))
## [1] FALSE

&gt; is.integer(c(1L, -3L))
## [1] TRUE</code></pre>
<p>整数型的缺失值是NA， 而double型的特殊值除了NA外， 还包括Inf, -Inf和NaN， 其中NaN也算是缺失值, Inf和-Inf不算是缺失值。 如:</p>
<pre><code>&gt; c(-1, 0, 1)/0
## [1] -Inf  NaN  Inf

&gt; is.na(c(-1, 0, 1)/0)
## [1] FALSE  TRUE FALSE</code></pre>
<p>对double类型，可以用<strong>is.finite()判断是否有限值</strong>， NA、Inf, -Inf和NaN都不是有限值； 用is.infinite()判断是否Inf或-Inf； is.na()判断是否NA或NaN； is.nan()判断是否NaN。</p>
<p>严格说来， NA表示逻辑型缺失值， 但是当作其它类型缺失值时一般能自动识别。 NA_integer_是整数型缺失值， NA_real是double型缺失值， NA_character_是字符型缺失值。</p>
<p>在R的向量类型中， integer类型、double类型、logical类型、character类型、还有complex类型和raw类型称为原子类型(atomic types)， 原子类型的向量中元素都是同一基本类型的。 比如， double型向量的元素都是double或者缺失值。</p>
<p>除了原子类型的向量， 在R语言的定义中， 向量还包括后面要讲到的列表（list）， 列表的元素不需要属于相同的基本类型， 而且列表的元素可以不是单一基本类型元素。 用typeof()函数可以返回向量的类型， 列表返回结果为”list”:</p>
<pre><code>&gt; typeof(list(&quot;a&quot;, 1L, 1.5))
## [1] &quot;list&quot;</code></pre>
<p>原子类型的各个元素除了基本类型相同， 还不包含任何嵌套结构，如：</p>
<pre><code>&gt; c(1, c(2,3, c(4,5)))
## [1] 1 2 3 4 5</code></pre>
<p>R有一个特殊的NULL类型， 这个类型只有唯一的一个NULL值， 表示不存在。 <strong>NULL长度为0， 不能有任何属性值</strong>。 用is.null()函数判断某个变量是否取NULL。</p>
<p><strong>NULL值可以用来表示类型未知的零长度向量</strong>， 如c()没有自变量时返回值就是NULL； 也经常用作函数缺省值， 在函数内用is.null()判断其缺省后再用一定的计算逻辑得到真正的缺省情况下的数值。</p>
<p>要把NULL与NA区分开来， <strong>NA是有类型的（integer、double、logical、character等)</strong>, <strong>NA表示存在但是未知</strong>。 数据库管理系统中的NULL值相当于R中的NA值。</p>
<h2 id="类型转换与类型升档"><a href="#类型转换与类型升档" class="headerlink" title="类型转换与类型升档"></a>类型转换与类型升档</h2><p>可以用as.xxx()类的函数在不同类型之间进行强制转换。 如</p>
<pre><code>&gt; as.numeric(c(FALSE, TRUE))
## [1] 0 1

&gt; as.character(sqrt(1:4))
## [1] &quot;1&quot;                &quot;1.4142135623731&quot;  &quot;1.73205080756888&quot; &quot;2&quot;</code></pre>
<p>类型转换也可能是隐含的，比如， <strong>四则运算中数值会被统一转换为double类型</strong>， 逻辑运算中运算元素会被统一转换为logical类型。 逻辑值转换成数值时，TRUE转换成1， FALSE转换成0。</p>
<p>在用c()函数合并若干元素时， <strong>如果元素基本类型不同， 将统一转换成最复杂的一个</strong>，复杂程度从简单到复杂依次为： <strong>logical&lt;integer&lt;double&lt;character</strong>。 这种做法称为类型升档，如</p>
<pre><code>&gt; c(FALSE, 1L, 2.5, &quot;3.6&quot;)
## [1] &quot;FALSE&quot; &quot;1&quot;     &quot;2.5&quot;   &quot;3.6&quot;</code></pre>
<p>不同类型参与要求类型相同的运算时， 也会统一转换为最复杂的类型， 也称为类型升档， 如：</p>
<pre><code>&gt; TRUE + 10
## [1] 11

&gt; paste(&quot;abc&quot;, 1)
## [1] &quot;abc 1&quot;</code></pre>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>除了NULL以外， R的变量都可以看成是对象， 都可以有属性。 在R语言中， 属性是把变量看成对象后， 除了其存储内容（如元素）之外的其它附加信息， 如维数、类属等。 R对象一般都有length和mode两个属性。</p>
<p>常用属性有<strong>names, dim，class</strong>等。</p>
<h3 id="attributes函数"><a href="#attributes函数" class="headerlink" title="attributes函数"></a>attributes函数</h3><p>对象x的所有属性可以用attributes()读取， 如</p>
<pre><code>&gt; x &lt;- table(c(1,2,1,3,2,1)); print(x)
## 
## 1 2 3 
## 3 2 1

&gt; attributes(x)
## $dim
## [1] 3
## 
## $dimnames
## $dimnames[[1]]
## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot;
## 
## 
## $class
## [1] &quot;table&quot;</code></pre>
<p><em>table()</em> 函数用了输出其自变量中每个不同值的出现次数，称为<strong>频数</strong>。 从上例可以看出， table()函数的结果有三个属性，前两个是dim和dimnames, 这是数组(array)具有的属性； 另一个是class属性，值为”table”。 因为x是数组，可以访问如</p>
<pre><code>&gt; x[1]
## 1 
## 3

&gt; x[&quot;3&quot;]
## 3 
## 1</code></pre>
<p>也可以用attributes()函数修改属性， 如</p>
<pre><code>&gt; attributes(x) &lt;- NULL
&gt; x
## [1] 3 2 1</code></pre>
<p>如上修改后x不再是数组，也不是table。</p>
<h3 id="attr函数"><a href="#attr函数" class="headerlink" title="attr函数"></a>attr函数</h3><p>可以用attr(x, “属性名”)的格式读取或定义x的属性。 如：</p>
<pre><code>&gt; x &lt;- c(1,3,5)
&gt; attr(x, &quot;theta&quot;) &lt;- c(0, 1)
&gt; print(x)

## [1] 1 3 5
## attr(,&quot;theta&quot;)
## [1] 0 1</code></pre>
<p>可以让向量x额外地保存一个theta属性， 这样的属性常常成为“元数据”(meta data)， 比如， 用来保存数据的说明、模拟数据的真实模型参数，等等。</p>
<h3 id="names属性"><a href="#names属性" class="headerlink" title="names属性"></a>names属性</h3><p>有元素名的向量、列表、数据框等都有names属性， 许多R函数的输出本质上也是列表， 所以也有names属性。 用names(x)的格式读取或设定。 如：</p>
<pre><code>&gt; x &lt;- 1:5
&gt; y &lt;- x^2
&gt; lmr &lt;- lm(y ~ x)
&gt; print(names(lmr))

##  [1] &quot;coefficients&quot;  &quot;residuals&quot;     &quot;effects&quot;       &quot;rank&quot;         
##  [5] &quot;fitted.values&quot; &quot;assign&quot;        &quot;qr&quot;            &quot;df.residual&quot;  
##  [9] &quot;xlevels&quot;       &quot;call&quot;          &quot;terms&quot;         &quot;model&quot;</code></pre>
<p>对于没有元素名的向量x，names(x)的返回值是NULL。</p>
<h3 id="dim属性"><a href="#dim属性" class="headerlink" title="dim属性"></a>dim属性</h3><p>dim属性的存在表明对象是矩阵或一维、多维数组。 如：</p>
<pre><code>&gt; x &lt;- matrix(1:12, nrow=3, ncol=4)
&gt; attr(x, &quot;dim&quot;) # 等同于dim(x)

## [1] 3 4</code></pre>
<p>修改dim属性就将向量转换成矩阵（数组）， 或修改了矩阵的性质， 元素按列次序重排填入新的矩阵。如：</p>
<pre><code>&gt; x &lt;- 1:10
&gt; dim(x) &lt;- c(2,5)
&gt; x

##   [,1] [,2] [,3] [,4] [,5]
[1,]    1    3    5    7    9
[2,]    2    4    6    8   10</code></pre>
<p>R允许dim仅有一个元素， 这对应于一维向量， 与普通的没有dim属性的向量有区别。 另外要注意， <strong>取矩阵子集时如果结果仅有一列或一行， 除非用了drop=FALSE选项， 结果不再有dim属性， 退化成了普通向量</strong>。</p>
<h3 id="str-函数"><a href="#str-函数" class="headerlink" title="str()函数"></a>str()函数</h3><p>用print()函数可以显示对象内容。 如果内容很多， 显示行数可能也很多。 用str()函数可以显示对象的类型和主要结构及典型内容。例如</p>
<pre><code>&gt; s &lt;- 101:200
&gt; attr(s,&#39;author&#39;) &lt;- &#39;李小明&#39;
&gt; attr(s,&#39;date&#39;) &lt;- &#39;2016-09-12&#39;

&gt; str(s)

## int [1:100] 101 102 103 104 105 106 107 108 109 110 ...
 - attr(*, &quot;author&quot;)= chr &quot;李小明&quot;
 - attr(*, &quot;date&quot;)= chr &quot;2016-09-12&quot;

&gt; print(s)

## [1] 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120
 [21] 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140
 [41] 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160
 [61] 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180
 [81] 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200
attr(,&quot;author&quot;)
[1] &quot;李小明&quot;
attr(,&quot;date&quot;)
[1] &quot;2016-09-12&quot;</code></pre>
]]></content>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵和数组</title>
    <url>/2020/11/14/%E7%9F%A9%E9%98%B5%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="R矩阵"><a href="#R矩阵" class="headerlink" title="R矩阵"></a>R矩阵</h2><p>矩阵用matrix函数定义，实际存储成一个向量，根据保存的行数和列数对应到矩阵的元素， 存储次序为按列存储。 定义如</p>
<pre><code>&gt; A &lt;- matrix(11:16, nrow=3, ncol=2)
&gt; print(A)
     [,1] [,2]
[1,]   11   14
[2,]   12   15
[3,]   13   16

&gt; B &lt;- matrix(c(1,-1, 1,1), nrow=2, ncol=2, byrow=TRUE)
&gt; B
     [,1] [,2]
[1,]    1   -1
[2,]    1    1</code></pre>
<p>matrix()函数把矩阵元素以一个<strong>向量的形式输入</strong>， 用nrow和ncol规定行数和列数，向量元素填入矩阵的缺省次序是按列填入， 用byrow=TRUE选项可以转换成按行填入。</p>
<pre><code>&gt; nrow(A)
[1] 3
&gt; ncol(A)
[1] 2</code></pre>
<p>矩阵有一个dim属性，内容是两个元素的向量， 两个元素分别为矩阵的行数和列数。dim属性可以用dim()函数访问。如</p>
<pre><code>&gt; attributes(A)
$dim
[1] 3 2

&gt; dim(A)
[1] 3 2</code></pre>
<p>函数<strong>t(A)**返回</strong>A的转置**。</p>
<pre><code>&gt; t(A)
     [,1] [,2] [,3]
[1,]   11   12   13
[2,]   14   15   16</code></pre>
<h2 id="矩阵子集"><a href="#矩阵子集" class="headerlink" title="矩阵子集"></a>矩阵子集</h2><p>用A[1,]取出A的第一行，变成一个普通向量。 用A[,1]取出A的第一列，变成一个普通向量。 用A[c(1,3),1:2]取出指定行、列对应的子矩阵。 如</p>
<pre><code>&gt; A[1,1:2]
[1] 11 14

&gt; A[c(1,3),1:2]
     [,1] [,2]
[1,]   11   14
[2,]   13   16</code></pre>
<p>用colnames()函数可以给矩阵每列命名， 也可以访问矩阵列名， 用rownames()函数可以给矩阵每行命名， 也可以访问矩阵行名。如</p>
<pre><code>&gt; colnames(A) &lt;- c(&quot;A&quot;,&quot;C&quot;)
&gt; rownames(A)&lt;- c(&quot;B&quot;,&quot;D&quot;,&quot;F&quot;)
&gt; A
   A  C
B 11 14
D 12 15
F 13 16</code></pre>
<p>有了列名、行名后，矩阵下标可以用字符型向量， 如</p>
<pre><code>&gt; A[,&quot;A&quot;]
 B  D  F 
11 12 13 

&gt; A[&quot;B&quot;,]
 A  C 
11 14

&gt; A[c(&quot;B&quot;,&quot;D&quot;),&quot;A&quot;]
 B  D 
11 12 </code></pre>
<p>注意在对矩阵取子集时， 如果<strong>取出的子集仅有一行或仅有一列， 结果就不再是矩阵而是变成了R向量</strong>， R向量既不是行向量也不是列向量。 如果想避免这样的规则起作用，需要在方括号下标中加选项<strong>drop=FALSE</strong>， 如</p>
<pre><code>&gt; A[A[,1]&gt;=12,&#39;C&#39;]
 D  F 
15 16 </code></pre>
<p>矩阵本质上是一个向量添加了dim属性， 实际保存还是保存成一个向量， 其中元素的保存次序是<strong>按列填入</strong>，所以也可以向对一个向量取子集那样， 仅用一个正整数向量的矩阵取子集。如</p>
<pre><code>&gt; A[c(1,3,5)]
[1] 11 13 15</code></pre>
<p>用c(A)或A[]返回矩阵A的所有元素。 如果要修改矩阵A的所有元素， 可以对A[]赋值。</p>
<pre><code>#c(A)返回所有元素的方式是以列表的形式
&gt; c(A)
[1] 11 12 13 14 15 16

# A[]的返回所有元素的方式是以矩阵的形式
&gt; A[]
   A  C
B 11 14
D 12 15
F 13 16</code></pre>
<p>对矩阵A，diag(A)访问A的主对角线元素组成的向量。 另外，若x为正整数值标量，diag(x)返回x阶单位阵； 若x为长度大于1的向量， diag(x)返回以x的元素为主对角线元素的对角矩阵。</p>
<pre><code>&gt; diag(A)
[1] 11 15</code></pre>
<h2 id="cbind-和rbind-函数"><a href="#cbind-和rbind-函数" class="headerlink" title="cbind()和rbind()函数"></a>cbind()和rbind()函数</h2><p>若x是向量，<strong>cbind(x)把x变成列向量</strong>， 即列数为1的矩阵， <strong>rbind(x)把x变成行向量</strong>。</p>
<p>若x1, x2, x3是等长的向量， cbind(x1, x2, x3)把它们看成列向量并在一起组成一个矩阵。 cbind()的自变量可以同时包含向量与矩阵，向量的长度必须与矩阵行数相等。 如</p>
<pre><code>&gt; cbind(c(1,2), c(3,4), c(5,6))
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6


&gt; cbind(A, c(1,-1,10))
   A  C   
B 11 14  1
D 12 15 -1
F 13 16 10</code></pre>
<p>**cbind()**的自变量中也允许有标量， 这时此标量被重复使用。 如</p>
<pre><code>&gt; cbind(1,c(1,-1,10))
     [,1] [,2]
[1,]    1    1
[2,]    1   -1
[3,]    1   10</code></pre>
<p>**rbind()**用法类似， 可以等长的向量看成行向量上下摞在一起， 可以是矩阵与长度等于矩阵列数的向量上下摞在一起， 向量长度为1也可以。</p>
<pre><code>&gt; rbind(c(1,2), c(3,4), c(5,6))
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6</code></pre>
<h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><p>矩阵可以与标量作四则运算，结果<strong>为每个元素进行相应运算</strong>，如</p>
<pre><code>&gt; c1 &lt;- A-1
&gt; c1
   A  C
B 10 13
D 11 14
F 12 15

&gt; c2 &lt;- A / 2
&gt; c2
    A   C
B 5.5 7.0
D 6.0 7.5
F 6.5 8.0</code></pre>
<p>两个同形状的矩阵进行加、减运算， 即对应元素相加、相减， 用A + B，A - B表示，如</p>
<pre><code>&gt; c1+c2
     A    C
B 15.5 20.0
D 17.0 21.5
F 18.5 23.0</code></pre>
<p>这就是线性代数中矩阵的加、减运算。</p>
<p>对两个同形状的矩阵， 用*表示两个矩阵对应元素相乘(注意这不是线性代数中的矩阵乘法)， 用/表示两个矩阵对应元素相除。 如</p>
<pre><code>&gt; c1 * c2
   A   C
B 55  91
D 66 105
F 78 120</code></pre>
<h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p>用<code>%*%</code>表示矩阵乘法而不是用<code>*</code>表示， 注意矩阵乘法要求左边的矩阵的列数等于右边的矩阵的行数。 如</p>
<pre><code>&gt; B &lt;- cbind(c(1,1),c(-1,1))
&gt; A%*%B
  [,1] [,2]
B   25    3
D   27    3
F   29    3</code></pre>
<h2 id="向量与矩阵相乘"><a href="#向量与矩阵相乘" class="headerlink" title="向量与矩阵相乘"></a>向量与矩阵相乘</h2><p>矩阵与向量进行乘法运算时， 向量按需要解释成列向量或行向量。 当向量左乘矩阵时，看成行向量； 当向量右乘矩阵时，看成列向量。 如</p>
<pre><code>&gt; B
     [,1] [,2]
[1,]    1   -1
[2,]    1    1

&gt; c(1,1) %*% B
     [,1] [,2]
[1,]    2    0

&gt; B %*% c(1,1)
     [,1]
[1,]    0
[2,]    2</code></pre>
<p><strong>apply()函数</strong></p>
<p>apply(A, 2, FUN)把矩阵A的每一列分别输入到函数FUN中， 得到对应于每一列的结果，如</p>
<pre><code>&gt; D &lt;- matrix(c(6,2,3,5,4,1), nrow=3, ncol=2)
&gt; D
     [,1] [,2]
[1,]    6    5
[2,]    2    4
[3,]    3    1

&gt; apply(D, 2, sum)
[1] 11 10</code></pre>
<p>apply(A, 1, FUN)把矩阵A的每一行分别输入到函数FUN中， 得到与每一行对应的结果，如</p>
<pre><code>&gt; apply(D, 1, mean)
[1] 5.5 3.0 2.0</code></pre>
<p>如果函数FUN返回多个结果， 则apply(A, 2, FUN)结果为矩阵， 矩阵的每一列是输入矩阵相应列输入到FUN的结果， 结果列数等于A的列数。如</p>
<pre><code>&gt; apply(D, 2, range)
     [,1] [,2]
[1,]    2    1
[2,]    6    5</code></pre>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组的一般定义语法为</p>
<blockquote>
<p>数组名 &lt;- array(数组元素,<br>  dim=c(第一下标个数, 第二下标个数, …, 第s下标个数))</p>
</blockquote>
<p>其中数组元素的填入次序是第一下标变化最快， 第二下标次之， 最后一个下标是变化最慢的。 这种次序称为FORTRAN次序。</p>
<p>下面是一个三维数组定义例子。</p>
<pre><code>&gt; ara &lt;- array(1:24, dim=c(2,3,4))
&gt; ara
, , 1

     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6

, , 2

     [,1] [,2] [,3]
[1,]    7    9   11
[2,]    8   10   12

, , 3

     [,1] [,2] [,3]
[1,]   13   15   17
[2,]   14   16   18

, , 4

     [,1] [,2] [,3]
[1,]   19   21   23
[2,]   20   22   24</code></pre>
<p>三维数组ara可以看成是4个2x3矩阵。 取出其中一个如ara[,,2]<br>(取出第二个矩阵)</p>
<pre><code>&gt; ara[,,2]
     [,1] [,2] [,3]
[1,]    7    9   11
[2,]    8   10   12</code></pre>
<p>多维数组可以利用下标进行一般的子集操作</p>
<pre><code>&gt; ara[,2,2:3]
     [,1] [,2]
[1,]    9   15
[2,]   10   16</code></pre>
<p>多维数组在取子集时如果某一维下标是标量， 则结果维数会减少， 可以在方括号内用drop=FALSE选项避免这样的规则发生作用。</p>
<pre><code>&gt; ara[,2,2:3,drop=FALSE]
, , 1

     [,1]
[1,]    9
[2,]   10

, , 2

     [,1]
[1,]   15
[2,]   16</code></pre>
<p>类似于矩阵， 多维数组可以用一个矩阵作为下标， 如果是三维数组，矩阵就需要有3列， 四维数组需要用4列矩阵。 下标矩阵的每行对应于一个数组元素。</p>
]]></content>
  </entry>
  <entry>
    <title>逻辑型向量及其运算</title>
    <url>/2020/10/31/%E9%80%BB%E8%BE%91%E5%9E%8B%E5%90%91%E9%87%8F%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>逻辑型是R的基本数据类型之一，只有两个值TRUE和FALSE, 缺失时为NA。逻辑值一般产生自比较，如</p>
<pre><code>&gt; sele &lt;- (log10(15) &lt; 2)
&gt; print(sele)

## [1] TRUE</code></pre>
<p>向量比较结果为逻辑型向量。如</p>
<pre><code>&gt; c(1, 3, 5) &gt; 2
## [1] FALSE  TRUE  TRUE

&gt; (1:4) &gt;= (4:1)    
## [1] FALSE FALSE  TRUE  TRUE</code></pre>
<p>从例子可以看出，向量比较也遵从R的向量间运算的一般规则： 向量与标量的运算是向量每个元素与标量都分别运算一次， 等长向量的运算时对应元素的运算， 不等长但长度为倍数关系的向量运算是把短的从头重复利用。</p>
<p>与NA比较产生NA，如</p>
<pre><code>&gt; c(1, NA, 3) &gt; 2
## [1] FALSE    NA  TRUE

&gt; NA == NA
## [1] NA</code></pre>
<p>为了判断向量每个元素是否NA， 用is.na()函数，如</p>
<pre><code>&gt; is.na(c(1, NA, 3) &gt; 2)
## [1] FALSE  TRUE FALSE</code></pre>
<p>用**is.finite()**判断向量每个元素是否Inf值。</p>
<p>比较运算符包括</p>
<blockquote>
<p>&lt;   &lt;=  &gt;  &gt;=  ==  !=  %in%<br>分别表示小于、小于等于、大于、大于等于、等于、不等于、属于。 要注意等于比较用了两个等号。</p>
</blockquote>
<p>%in%是比较特殊的比较， x %in% y的运算把向量y看成集合， 运算结果是一个逻辑型向量， 第个元素的值为x的第元素是否属于y的逻辑型值。 如</p>
<pre><code>&gt; c(1,3) %in% c(2,3,4)
## [1] FALSE  TRUE

&gt; c(NA,3) %in% c(2,3,4)
## [1] FALSE  TRUE

&gt; c(1,3) %in% c(NA, 3, 4)
## [1] FALSE  TRUE

&gt; c(NA,3) %in% c(NA, 3, 4)
## [1] TRUE TRUE</code></pre>
<p>函数match(x, y)起到和x %in% y运算类似的作用， 但是其返回结果不是找到与否， 而是对x的每个元素， 找到其在y中首次出现的下标，找不到时取缺失值，如</p>
<pre><code>&gt; match(c(1, 3), c(2,3,4,3))
## [1] NA  2</code></pre>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><p>为了表达如“而且”, “或者”之类的复合比较， 需要使用逻辑运算把两个比较连接起来。 逻辑运算符为&amp;, |和!, 分别表示“同时成立”、“两者至少其一成立”、“条件的反面”。 比如，设age&lt;=3表示婴儿，sex==’女’表示女性，则 age&lt;=3 &amp; sex==’女’表示女婴, age&lt;=3 | sex==’女’表示婴儿或妇女, !(age&lt;=3 | sex==’女’)表示既非婴儿也非妇女。 为了确定运算的先后次序可以用圆括号()指定。</p>
<p>用xor(x, y)表示x与y的异或运算， 即值不相等时为真值，相等时为假值， 有缺失值参加运算时为缺失值。</p>
<p>逻辑向量与逻辑标量之间的逻辑运算， 两个逻辑向量之间的逻辑运算规则遵从一般R向量间运算规则。</p>
<p>在右运算符是缺失值时， 如果左运算符能够确定结果真假， 可以得到非缺失的结果。 例如，TRUE | NA为TRUE, FALSE &amp; NA为FALSE。 不能确定结果时返回NA， 比如， TRUE &amp; NA为NA, FALSE | NA为NA。</p>
<p>&amp;&amp;和||分别为短路的标量逻辑与和短路的标量逻辑或， 仅对两个标量进行运算，如果有向量也仅使用第一个元素。 一般用在if语句、while语句中， 且只要第一个比较已经决定最终结果就不计算第二个比较。 例如</p>
<pre><code>&gt; if(TRUE || sqrt(-1)&gt;0) 3+2 

## [1] 5</code></pre>
<p>其中的sqrt(-1)部分不会执行。</p>
<p>这里结果为TRUE, 第二部分没有参加计算， 否则第二部分的计算会发生函数自变量范围错误。</p>
<h2 id="逻辑运算函数"><a href="#逻辑运算函数" class="headerlink" title="逻辑运算函数"></a>逻辑运算函数</h2><p>因为R中比较与逻辑运算都支持向量之间、向量与标量之间的运算， 所以在需要一个标量结果时要特别注意， 后面讲到的if结构、while结构都需要逻辑标量而且不能是缺失值。 这时，应该对缺失值结果单独考虑。</p>
<p>若cond是逻辑向量， 用all(cond)测试cond的所有元素为真； 用any(cond)测试cond至少一个元素为真。 cond中允许有缺失值，结果可能为缺失值。 如</p>
<pre><code>&gt; c(1, NA, 3) &gt; 2
## [1] FALSE    NA  TRUE

&gt; all(c(1, NA, 3) &gt; 2)
## [1] FALSE

&gt; any(c(1, NA, 3) &gt; 2)
## [1] TRUE

&gt; all(NA)
## [1] NA

&gt; any(NA)
## [1] NA</code></pre>
<p>函数which()返回真值对应的所有下标，如</p>
<pre><code>&gt; which(c(FALSE, TRUE, TRUE, FALSE, NA))
## [1] 2 3

&gt; which((11:15) &gt; 12)
## [1] 3 4 5</code></pre>
<p>函数identical(x,y)比较两个R对象x与y的内容是否完全相同， 结果只会取标量TRUE与FALSE两种。 如</p>
<pre><code>&gt; identical(c(1,2,3), c(1,2,NA))
## [1] FALSE

&gt; identical(c(1L,2L,3L), c(1,2,3))
## [1] FALSE</code></pre>
<p>其中第二个结果假值是因为前一向量是整数型， 后一向量是实数型。</p>
<p>函数all.equal()与identical()类似， 但是在比较数值型时不区分整数型与实数型， 而且相同时返回标量TRUE， 但是不同时会返回一个说明有何不同的字符串。如</p>
<pre><code>&gt; all.equal(c(1,2,3), c(1,2,NA))
## [1] &quot;&#39;is.NA&#39; value mismatch: 1 in current 0 in target&quot;

&gt; all.equal(c(1L,2L,3L), c(1,2,3))
## [1] TRUE</code></pre>
<p>函数duplicated()返回每个元素是否为重复值的结果，如：</p>
<pre><code>&gt; duplicated(c(1,2,1,3,NA,4,NA))
## [1] FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE</code></pre>
<p>用函数unique()可以返回去掉重复值的结果。</p>
]]></content>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>ggplot2可视化入门及作图一般原则</title>
    <url>/2020/11/20/ggplot2%E5%8F%AF%E8%A7%86%E5%8C%96%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Hadley Wickem的ggplot2包是R的一个作图用的扩展包， 它实现了“图形的语法”， 将一个作图任务分解为若干个子任务， 只要完成各个子任务就可以完成作图。 在作常用的图形时， 只需要两个步骤：</p>
<blockquote>
<p> <strong>首先将图形所展现的数据输入到ggplot()函数中， 然后调用某个geom_xxx()函数， 指定图形类型，如散点图、曲线图、盒形图等。</strong></p>
</blockquote>
<p>如果需要进一步控制图形细节， 只要继续调用其它函数， 就可以控制变量值的表现方式(scale)、图例、配色等。 这使得我们很容易做出基本的图形， 在有需要时再深入学习， 做出更为满意的图形。</p>
<p>与基本R中的作图系统相比， ggplot2的作图有规律可循， 作图结果直接达到出版印刷质量， 除了可以按照一些既定模式做出常见种类的图形， 也很容易将不同图形种类组合在一起， 或者设计新颖的图形。 基本R的作图结果通常不够美观， 如果要将不同种类图形组合在一起比较困难， 对设计新的图形类型支持也不够好。</p>
<h2 id="ggplot2的作图一般步骤为："><a href="#ggplot2的作图一般步骤为：" class="headerlink" title="ggplot2的作图一般步骤为："></a>ggplot2的作图一般步骤为：</h2><ul>
<li>准备数据，一般为数据框， 且一般为长表， 即每个观测时间占一行， 每个观测变量占一列。</li>
</ul>
<ul>
<li>将数据输入到ggplot()函数中， 并指定参与作图的每个变量分别映射到哪些图形特性， 比如映射为x坐标、y坐标、颜色、形状等。 这些映射称为aesthetic mappings或aesthetics。</li>
</ul>
<ul>
<li>选择一个合适的图形类型， 函数名以geom_开头， 如geom_point()表示散点图。 图形类型简称为geom。 将ggplot()部分与geom_xxx()部分用加号连接。 到此已经可以作图，下面的步骤是进一步的细化设定。</li>
</ul>
<ul>
<li>设定适当的坐标系统， 如coord_cartesian(), scale_x_log10()等。 仍用加号连接。<br>设定标题和图例位置等，如labs()。 仍用加号连接。</li>
</ul>
<p><strong>这个流程的一个大致的模板为</strong>：</p>
<pre><code>p &lt;- ggplot(data=&lt;输入数据框&gt;,
  mapping=aes(&lt;维度&gt;=&lt;变量名&gt;,
    &lt;维度&gt;=&lt;变量名&gt;, &lt;...&gt;))
p + geom_&lt;图形类型&gt;(&lt;...&gt;) + 
  scale_&lt;映射&gt;_&lt;类型&gt;(&lt;...&gt;) +
  coord_&lt;类型&gt;(&lt;...&gt;) +
  labs(&lt;...&gt;)</code></pre>
<p>其中&lt;…&gt;表示额外的选项。 变量p包含做出的图形的所有数据与设定， 变量名可以任意取。</p>
<p>Wickham的书主要需要安装tidyverse扩展包， 安装时会自动安装其它一些有关扩展包。 Healy的的书需要通过如下程序安装socviz软件包：</p>
<pre><code>&gt; devtools::install_github(&quot;kjhealy/socviz&quot;)</code></pre>
<p>后续的例子中用到一些数据集:</p>
<ul>
<li>来自gapminder扩展包的gapminder数据集， 有若干个国家不同年份的一些数据， 包括所属洲、期望寿命、人口数、人均GDP。 有1704个观测和6个变量。</li>
</ul>
<ul>
<li>socviz包的gss_sm数据集，是2016年美国一般社会调查数据的部分内容。 有2867个观测，32个变量。 社会调查数据的变量主要取属性值， 比如无序分类、有序分类、分组的数值、整数值等。</li>
</ul>
<ul>
<li>socviz包的organdata数据集， 是17个OECD国家历年的器官捐献情况以及一些其它记录。</li>
</ul>
<ul>
<li>socviz扩展包的elections_historic数据集。 包括美国历次总统大选当选人、所属党派、支持比例等。</li>
</ul>
<ul>
<li>socviz扩展包的asasec数据集。 这是美国社会学学会(ASA)的各分会2005年到2015年的一些数据。</li>
</ul>
<ul>
<li>ggplot2包中的midwest数据集包含了美国中西部的一些县的统计数据， 如面积等。<br>来自ggplot2包的钻石数据集。</li>
</ul>
<h2 id="作图时应考虑的一些因素："><a href="#作图时应考虑的一些因素：" class="headerlink" title="作图时应考虑的一些因素："></a>作图时应考虑的一些因素：</h2><p>1.数值型变量的不同值可以表示为：</p>
<ul>
<li>同一坐标轴上的不同位置、</li>
<li>不同轴上的位置、</li>
<li>不同长度、</li>
<li>不同角度或者斜率、</li>
<li>不同面积、</li>
<li>三维空间中的不同位置、</li>
<li>颜色的不同明暗度、</li>
<li>不同颜色饱和度、</li>
<li>曲线的不同曲率、</li>
<li>三维体积，</li>
</ul>
<p>这些表示的选择项越往后越难以被读者正确辨识。 使用颜色时，应该使用渐变的明暗度或者渐变色。</p>
<p>2.分类变量的不同值可以表示为：</p>
<ul>
<li>不同分组、</li>
<li>不同颜色、</li>
<li>三维动态、</li>
<li>不同符号。</li>
</ul>
<p>这些表示的选择项越往后越难辨识。 使用颜色时，应该使用明显不同的颜色而不应该使用渐变色。</p>
<p>对于最少是零的变量， 是否应该以零作为坐标轴的最低值需要考虑， 但没有一定的规则。 同一组数据在不同的坐标范围或者长宽比下曲线的斜率会有很大差别。</p>
]]></content>
      <tags>
        <tag>数据可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>ggplot2散点图</title>
    <url>/2020/11/20/ggplot2%E6%95%A3%E7%82%B9%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="基本的散点图"><a href="#基本的散点图" class="headerlink" title="基本的散点图"></a>基本的散点图</h2><p>以gapminder数据集作为输入数据， 做出简单的散点图， 并逐步进行改善。 这个数据集有多个国家在多个年份的期望寿命与人均GDP值， 作期望寿命对人均GDP的散点图， 每个国家的每个年份作为一个点。 散点图最重要的映射是x轴与y轴两个维度。</p>
<p>首先调用ggplot()函数， 指定数据集， 将人均GDP映射到x轴， 将期望寿命映射到y轴， 结果保存为一个R变量：</p>
<pre><code>&gt; install.packages(&quot;gapminder&quot;)

&gt; library(gapminder)

&gt; head(gapminder,20)
# A tibble: 20 x 6
   country     continent  year lifeExp     pop gdpPercap
   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;
 1 Afghanistan Asia       1952    28.8  8.43e6      779.
 2 Afghanistan Asia       1957    30.3  9.24e6      821.
 3 Afghanistan Asia       1962    32.0  1.03e7      853.
 4 Afghanistan Asia       1967    34.0  1.15e7      836.
 5 Afghanistan Asia       1972    36.1  1.31e7      740.
 6 Afghanistan Asia       1977    38.4  1.49e7      786.
 7 Afghanistan Asia       1982    39.9  1.29e7      978.
 8 Afghanistan Asia       1987    40.8  1.39e7      852.
 9 Afghanistan Asia       1992    41.7  1.63e7      649.
10 Afghanistan Asia       1997    41.8  2.22e7      635.
11 Afghanistan Asia       2002    42.1  2.53e7      727.
12 Afghanistan Asia       2007    43.8  3.19e7      975.
13 Albania     Europe     1952    55.2  1.28e6     1601.
14 Albania     Europe     1957    59.3  1.48e6     1942.
15 Albania     Europe     1962    64.8  1.73e6     2313.
16 Albania     Europe     1967    66.2  1.98e6     2760.
17 Albania     Europe     1972    67.7  2.26e6     3313.
18 Albania     Europe     1977    68.9  2.51e6     3533.
19 Albania     Europe     1982    70.4  2.78e6     3631.
20 Albania     Europe     1987    72    3.08e6     3739.

&gt; p &lt;- ggplot(data = gapminder,
+             mapping = aes(
+                 x = gdpPercap,
+                 y = lifeExp))</code></pre>
<p>ggplot()的调用中， 可以省略data =, mapping =, x =, y =， 写成：</p>
<pre><code>&gt; p &lt;- ggplot(gapminder, aes(gdpPercap, lifeExp))</code></pre>
<p>在如上指定了数据和映射后， 只要用geom_xxx()指定一个图形类型， 并与ggplot()的结果用加号连接就可以作图了，如：</p>
<pre><code>&gt; p + geom_point()</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/ggplot_files/figure-html/ggplot2-start-gapminder-point01b-1.png"></p>
<p>实际上，上面的程序等同于调用<code>print(p + geom_point())</code>。 在R函数中或者在循环中需要显式地调用print()， 否则不会显示结果。 当载入了tidyverse系统时可以写成 <code>(p + geom_point()) %&gt;% print()</code>。</p>
<h2 id="逐步改善"><a href="#逐步改善" class="headerlink" title="逐步改善"></a>逐步改善</h2><p>指定数据集、指定映射、选择适当的图形类型就可以做出基本的图形， 随后可以逐步对坐标系、坐标系刻度、标签与图例、配色等进行改善。 实际上，ggplot2包已经提供了十分合理的预设值， 用户只要进行一些必要的改动即可。</p>
<p><strong>作图步骤之间用加号连接</strong>，这是ggplot包特有的语法。 例如， 用相同的映射做出拟合曲线图：</p>
<pre><code>&gt; p + geom_smooth()
`geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39;</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/ggplot_files/figure-html/ggplot2-start-gapminder-point01c-1.png"></p>
<pre><code>&gt; p + geom_smooth() + geom_point()
`geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39;</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/ggplot_files/figure-html/ggplot2-start-gapminder-point01d-1.png"></p>
<pre><code>&gt; p + geom_point() + geom_smooth(method=&quot;lm&quot;)
`geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/ggplot_files/figure-html/ggplot2-start-gapminder-point01e-1.png"></p>
<p>注意geom_xxx()函数计算所需的变量值是从ggplot()函数保存在变量p中的信息提取的。</p>
<p>在以上的所有图形中， x轴变量（人均GDP）分布非正态，严重右偏， 使得大多数散点重叠地分布在直角坐标系的左下角。 将x轴用对数刻度可以改善， 函数为scale_x_log10():</p>
<pre><code>&gt; p + geom_point() + geom_smooth() + scale_x_log10(labels=scales::dollar)


## `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39;</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/ggplot_files/figure-html/ggplot2-start-gapminder-point01g-1.png"></p>
<p>scale_xxx()的labels选项指定如何标出坐标刻度数字， 参数值是一个函数对象， 如果scales包中找不到适当的功能， 可以自定义一个函数将数值转换为字符串。 scales包提供了comma, date, dollar, math, number, ordinal, pvalue, scientific, time等坐标刻度值转换函数。</p>
<h2 id="颜色、符号、线型等映射"><a href="#颜色、符号、线型等映射" class="headerlink" title="颜色、符号、线型等映射"></a>颜色、符号、线型等映射</h2><p>在ggplot()函数的mapping参数的aes()设定中将变量映射到x、y轴， 颜色、符号、线型等图形元素类型， 也可以作为图形设置将某些图形元素设置为固定值。</p>
<p>例如， 用不同颜色表示不同大洲， 就是将continent变量映射到color:</p>
<pre><code>&gt; p &lt;- ggplot(data=gapminder,
+             mapping = aes(
+                 x = gdpPercap,
+                 y = lifeExp,
+                 color = continent))</code></pre>
<p>程序中仅指定了将大洲映射到颜色维， 并不具体指定所用的颜色。</p>
<p>作带有局部多项式曲线拟合的散点图：</p>
<pre><code>&gt; p + geom_point() + geom_smooth(method =&quot;loess&quot;) + scale_x_log10(labels=scales::dollar)

`geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/ggplot_files/figure-html/ggplot2-start-gapminder-point02b-1.png"></p>
<p>可以看出， 不同散点用了不同颜色表示其continent变量的值， 五个大洲分别进行了曲线拟合， 曲线使用了不同颜色但置信域颜色相同， 使得难以认读。 在图形右侧自动生成了颜色与continent变量值的对应关系图例。</p>
<p>下面的图形仍分不同大洲作曲线拟合， 并将置信区间阴影的颜色也用不同大洲区分， 方法是在aes()中将color和fill都指定为变量continent:</p>
<pre><code>&gt; p &lt;- ggplot(data=gapminder,
+             mapping = aes(
+                 x = gdpPercap,
+                 y = lifeExp,
+                 color = continent,
+                 fill = continent))

&gt; p + geom_point() + geom_smooth(method =&quot;loess&quot;) + scale_x_log10(labels=scales::dollar)

`geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/ggplot_files/figure-html/ggplot2-start-gapminder-point03-1.png"></p>
<pre><code>&gt; p &lt;- ggplot(data=gapminder,
+             mapping = aes(
+                 x = gdpPercap,
+                 y = lifeExp,
+                 color = &quot;chartreuse4&quot;))

&gt; p + geom_point() +
+     geom_smooth(method=&quot;loess&quot;) +
+     scale_x_log10(labels=scales::dollar)</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/ggplot_files/figure-html/ggplot2-start-gapminder-point04-bad-1.png"></p>
<p>我们发现，散点并没有使用草绿色，而且图形右侧有一个chartreuse4图例。 这是因为， aes()仅用来指定变量与图形元素类型的映射，所以实际上是生成了一个仅有一个常数值”chartreuse4”的新变量， 用颜色表示这个新变量。 为了指定固定颜色， 应将color=作为geom_xxx()函数的选项， 而不是放在aes()映射中，如：</p>
<pre><code>&gt; p &lt;- ggplot(data=gapminder,
  mapping = aes(
    x = gdpPercap,
    y = lifeExp))

&gt; p + geom_point(color=&quot;chartreuse4&quot;) +
+ geom_smooth(method=&quot;loess&quot;) +
+     scale_x_log10(labels=scales::dollar)

`geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/ggplot_files/figure-html/ggplot2-start-gapminder-point05-1.png"></p>
<p>geom_xxx()函数接受许多关于颜色、透明度、符号、线型的设置参数。 比如， 下面的程序指定了散点的透明度， 以及拟合直线的粗细：</p>
<pre><code>&gt; p + geom_point(alpha=0.5) +
+ geom_smooth(method = &quot;lm&quot;,color=&quot;cadetblue1&quot;,se=FALSE,size=4,alpha=0.3) + scale_x_log10(labels=scales::dollar)

## `geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/ggplot_files/figure-html/ggplot2-start-gapminder-point05b-1.png"></p>
<p>程序中size指定了线的以毫米为单位的粗细， se = FALSE关闭了置信区间显示。 用alpha =设置了透明度， 取0和1之间的值， 数值越小越透明。</p>
<p>下面用labs()函数给图形加上适当的标题：</p>
<pre><code>&gt; p + geom_point(alpha=0.5) + 
+     geom_smooth(method = &quot;gam&quot;) +
+     scale_x_log10(labels=scales::dollar) + 
+     labs(
+         x=&quot;人均GDP&quot;,
+         y=&quot;期望寿命(年数)&quot;,
+         title = &quot;经济增长与期望寿命&quot;,
+         subtitle = &quot;数据点为每个国家每年&quot;,
+         caption = &quot;数据来源：gapminder&quot;)</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/ggplot_files/figure-html/ggplot2-start-gapminder-point06-1.png"></p>
<p>可以看出， labs()规定了上方的标题、小标题， x轴、y轴的标题， 右下方的标注(caption)。 坐标轴刻度数值的规定则需要在scale_xxx()函数中给出</p>
<h2 id="在geom函数中映射变量"><a href="#在geom函数中映射变量" class="headerlink" title="在geom函数中映射变量"></a>在geom函数中映射变量</h2><p>在前面的一个例图中， 在ggplot()函数中将color和fill映射到了continent变量， 使得不仅散点颜色代表了不同大洲， 还使得每个大洲单独拟合了曲线。 如果希望所有大洲拟合同一条曲线怎么办？</p>
<p>在必要时， 可以在geom_xxx()函数中用mapping = aes(&lt;…&gt;)单独指定变量映射。 例如下面的程序在geom_point()中将不同大洲映射为不同颜色， 而不影响geom_smooth()中的颜色以及分组：</p>
<pre><code>&gt; library(ggplot2)
&gt; library(gapminder)
&gt; p &lt;- ggplot(data=gapminder,
+             mapping = aes(
+                 x = gdpPercap,
+                 y = lifeExp))
&gt; p + geom_point(mapping = aes(color = continent)) +
+     geom_smooth(method=&quot;loess&quot;) +
+     scale_x_log10(labels=scales::dollar)
## `geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/ggplot_files/figure-html/ggplot2-start-gapminder-point07-1.png"></p>
<pre><code>&gt; library(dplyr)
&gt; p &lt;- ggplot(data = filter(gapminder, year == 2007),
+   mapping = aes(
+     x = gdpPercap,
+     y = lifeExp, 
+     shape = continent))
&gt; p + geom_point(alpha = 0.4, size = 4) +
+   scale_x_log10(labels=scales::dollar)</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/ggplot_files/figure-html/ggplot2-start-gapminder-point08-1.png"></p>
<p>这种映射仅适用于点数比较少的情况， 还用了size参数指定符号的大小（单位：毫米）。 如果所有点使用同一符号并需要指定符号， 可以在geom_point()中用shape参数指定， 可以用0到25的整数值表示， 比如19为实心点， 也可以用字符串符号名称表示， 如”circle”表示实心点。 参见ggplot2帮助目录中的vignette ggplot2: ggplot2-specs。</p>
<p>注意， 绘图时参与映射的分类变量会自动产生分类效果， color映射与fill映射到分类变量时常常会起到与添加group维相同的作用， 但为了逻辑清晰起见， 需要分组时还应该显式地映射group维。</p>
<h2 id="连续变量的颜色映射"><a href="#连续变量的颜色映射" class="headerlink" title="连续变量的颜色映射"></a>连续变量的颜色映射</h2><p>也可以将连续变量映射为渐变色。 除了表示二元函数的等值线图以外这种方法并不利于读者认读。</p>
<p>例如， 将人口数取自然对数映射为渐变色：</p>
<pre><code>&gt; p &lt;- ggplot(data=gapminder,
+             mapping = aes(
+                 x = gdpPercap,
+                 y = lifeExp,
+                 color = log(pop)))
&gt; p + geom_point() +
+     geom_smooth(method=&quot;loess&quot;) +
+     scale_x_log10(labels=scales::dollar)
## `geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
<p>这里不同散点的颜色是连续变化的， 右侧的图例仅显示了有限的一些代表值。</p>
<h2 id="保存图像"><a href="#保存图像" class="headerlink" title="保存图像"></a>保存图像</h2><p>如果使用Rmarkdown制作图文， 图像会自动进入编译的结果（如PDF、Word、HTML）中， 图像大小、输出大小可以用Rmarkdown的设置调整。</p>
<p>为了将最近生成的图形保存为PNG格式，用命令如</p>
<pre><code>&gt; ggsave(filename=&quot;文件名.png&quot;)</code></pre>
<p>保存为PDF格式：</p>
<pre><code>&gt; ggsave(filename=&quot;文件名.pdf&quot;)</code></pre>
<p>可以将制作的图形保存到了一个R变量中， 在ggsave()中可以用plot=参数指定，如</p>
<pre><code>&gt; ggout01 &lt;- p + geom_point()
&gt; ggsave(filename=&quot;文件名.pdf&quot;, plot=ggout01)</code></pre>
<p>在ggsave()中可以用scale =指定放大比例， 用height =指定高度， 用width =指定宽度，用units =指定高度和宽度的单位，如：</p>
<pre><code>&gt; ggsave(filename=&quot;文件名.pdf&quot;, plot=ggout01,
       height=12, width=8, units=&quot;cm&quot;)</code></pre>
<p>单位可以是in, cm, mm。</p>
]]></content>
  </entry>
  <entry>
    <title>RNAseq_2_原始测序数据处理</title>
    <url>/2020/11/22/RNAseq-2-%E5%8E%9F%E5%A7%8B%E6%B5%8B%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="1、fastq文件"><a href="#1、fastq文件" class="headerlink" title="1、fastq文件"></a>1、fastq文件</h3><p>一般我们从公司里得到的原始测序数据都是属于fastq.gz文件, .gz是一种压缩格式的缩写，于是首先第一步是对这些压缩格式进行解压操作</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/2_1.webp"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip -d 19R576_combined_R1.fastq.gz 19R576_combined_R2.fastq.gz 19R577_combined_R1.fastq.gz 19R577_combined_R2.fastq.gz</span><br></pre></td></tr></table></figure>
<p>解压好的文件即正常的Fastq文件，当然这里只是演示一下Fastq.gz是怎样解压的，给大家看一下即可，建议还是暂时不用解压，以为后面将介绍的测序质控还是用的压缩格式的gz文件作为输入文件</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/2_2.jpg"></p>
<p>首先先简单介绍一下什么是fataq文件</p>
<p>在illumina的测序文件中，采用双端测序（paired-end），一个样本得到的是seq_1.fastq.gz和seq_2.fastq.gz两个文件，每个文件存放一段测序文件。在illumina的测序的cDNA短链被修饰为以下形式（图源见水印）：</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/2_3.jpg" alt="image"></p>
<p>两端的序列是保护碱基（terminal sequence）、接头序列（adapter）、索引序列（index）、引物结合位点（Primer Binding Site）：其中 adapter是和flowcell上的接头互补配对结合的；index是一段特异序列，加入index是为了提高illumina测序仪的使用率，因为同一个泳道可能会测序多个样品，样品间的区分就是通过index区分。参考：<a href="https://link.zhihu.com/?target=https://blog.csdn.net/hanli1992/article/details/82980042">illumina 双端测序（pair end）</a>、<a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/b18ee79a0285">双端测序中read1和read2的关系</a>。</p>
<p>在illumina公司测得的序列文件经过处理以fastq文件协议存储为*.fastq格式文件。在fastq文件中每4行存储一个read。</p>
<p><strong>第一行</strong>：以@开头接ReadID和其他信息，分别介绍了 <strong>第二行</strong>：read测序信息 <strong>第三行</strong>：规定必须以“+”开头，后面跟着可选的ID标识符和可选的描述内容，如果“+”后面有内容，该内容必须与第一行“@”后的内容相同 <strong>第四行</strong>：每个碱基的质量得分。记分方法是利用ERROR P经过对数和运算分为40个级别分别与ASCII码的第33号<code>!</code>和第73号<code>I</code>对应。用ASCII码表示碱基质量是为了减少文件空间占据和防止移码导致的数据损失。fastq文件预览如下：</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/2_4.jpg"></p>
<p>###2、对数据进行质控（去接头和低质量的reads以及Fastqc）<br>为什么要对数据进行clean data这一步呢，主要是在测序过程中加入了接头序列（便于测序），以及测序过程中产生的一些低质量的reads, 如果不事先对这些进行筛选的很有可能会影响之后进行序列比对。</p>
<p>这里给大家介绍的就是数据质控界常用的——Trimmomatic软件。</p>
<h5 id="Trimmomatic-简介"><a href="#Trimmomatic-简介" class="headerlink" title="Trimmomatic 简介"></a>Trimmomatic 简介</h5><p>Trimmomatic软件，2014年首次发表在Bioinformatics期刊上，是一款专门对Illumina平台测序产生的reads进行修剪和过滤的软件。自发表以来，Trimmomatic软件凭借其简单的安装方法、较快的运行速度（支持多线程）、强大的去接头能力（simple和palindrome两种模式）、多元化的低质量数据处理方式、人性化的输出格式（clean reads为一一对应的pair-end形式，无需再次处理）等特点，深受数据处理者喜爱！下面就由小奥带大家一起来学习下Trimmomatic的具体用法。</p>
<h5 id="Trimmomatic-下载"><a href="#Trimmomatic-下载" class="headerlink" title="Trimmomatic 下载"></a>Trimmomatic 下载</h5><p>######(一)在Linux系统下通过命令行进行下载安装</p>
<p><strong>1.mkdir Trimmomatic</strong>（创建一个名为Trimmomatic的文件夹）</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/2_5.jpg"></p>
<p><strong>2.cd Trimmomatic</strong> （进入Trimmomatic文件夹工作路径下）</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/2_6.jpg"></p>
<p><strong>3.wget</strong></p>
<p><a href="http://www.usadellab.org/cms/uploads/supplementary/Trimmomatic/Trimmomatic-0.38.zip%EF%BC%88%E9%80%9A%E8%BF%87wget%E5%91%BD%E4%BB%A4%E4%B8%8B%E8%BD%BDTrimmomatic-0.38.zip%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%EF%BC%89">http://www.usadellab.org/cms/uploads/supplementary/Trimmomatic/Trimmomatic-0.38.zip（通过wget命令下载Trimmomatic-0.38.zip压缩文件）</a></p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/2_7.webp" alt="image"></p>
<p><strong>4.unzip Trimmomatic-0.38.zip</strong> （解压缩Trimmomatic-0.36.zip文件）</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/2_8.webp" alt="image"></p>
<p><strong>5.java</strong> -jar~/biosoft/Trimmomatic/Trimmomatic-0.36/trimmomatic-0.36.jar –h（运行安装命令，即可完成安装）</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/2_9.webp"></p>
<p>######（二）通过conda直接一键安装</p>
<p>先search一下到底conda可不可以搜索到软件安装的channel</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda search trimmomatic</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/2_10.webp"></p>
<p>反馈显示可以从相应的channel中找到trimmomatic软件<br>于是直接用conda一键安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda install trimmomatic</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/2_11.webp"></p>
<p>安装完成</p>
<h4 id="Trimmomatic-质控用法"><a href="#Trimmomatic-质控用法" class="headerlink" title="Trimmomatic 质控用法"></a>Trimmomatic 质控用法</h4><p>根据单端测序和双端测序两种模式，Trimmomatic软件也有两种质控用法</p>
<h5 id="◆-1-SE-模式"><a href="#◆-1-SE-模式" class="headerlink" title="◆ 1. SE 模式"></a>◆ 1. SE 模式</h5><p>SE模式下，只有一个输入文件和一个质控后的输出文件，运行命令如下</p>
<pre><code>Java –jar &lt; trimmomatic的安装路径&gt; SE –threads &lt;线程数&gt; &lt;input&gt; &lt;output&gt; &lt;step1&gt; &lt;step2&gt; …&lt;step1&gt;&lt;step2&gt;… 表示每一步的质控参数</code></pre>
<h5 id="◆-2-PE模式"><a href="#◆-2-PE模式" class="headerlink" title="◆ 2. PE模式"></a>◆ 2. PE模式</h5><p>PE 模式下，有两个输入文件（正向测序reads和反向测序reads）和四个质控后的输出文件（双端序列都保留的paired序列文件和只保留一端序列的unpaired序列文件），运行命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar $trimmomatic PE -threads 12 -phred33 $R1.fq.gz $R2.fq.gz $R1.paired.fq.gz $R1.unpaired.fq.gz $R2.paired.fq.gz $R2.unpaired.fq.gz ILLUMINACLIP:$adapter.fa:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:36</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数设置说明（同一个命令下的不同参数可以用“：”来界定）：<br>$ 表示软件或文件所在的路径（建议使用绝对路径）<br> 其中<strong>R1.fq.gz</strong>以及 <strong>R2.fq.gz</strong> 为两个输入文件<br><strong>R1.paired.fq.gz</strong> 、<strong>R1.unpaired.fq.gz</strong>、 <strong>R2.paired.fq.gz</strong> 、<strong>R2.unpaired.fq.gz</strong> 为四个对应的输出文件<br>Phred33 设置碱基的质量格式，默认的是-phred64。</p>
</blockquote>
<blockquote>
<p>ILLUMINACLIP:$adapter.fa:2:30:10 adapter.fa为接头文件，2表示最大mismatch数，30表示palindrome模式下碱基的匹配阈值，10表示simple模式下碱基的匹配阈值。<br>LEADING: 3 表示切除reads 5’端碱基质量低于3的碱基。<br>TRAILING:3 表示切除3’ 端碱基质量低于3的碱基。<br>SLIDINGWINDOW:4:15 表示以4个碱基为窗口进行滑动，切除窗口内碱基平均质量小于15的。<br>MINLEN:36 丢弃以上步骤处理后，序列长度小于36的reads。</p>
</blockquote>
<p>运行代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">trimmomatic PE -threads 12 -phred33 &#x2F;mnt&#x2F;e&#x2F;sequence_data_YNY&#x2F;20191030_NGS_DATA&#x2F;19R576_combined_R1.fastq.gz  &#x2F;mnt&#x2F;e&#x2F;sequence_data_YNY&#x2F;20191030_NGS_DATA&#x2F;19R576_combined_R2.fastq.gz  &#x2F;mnt&#x2F;e&#x2F;sequence_data_YNY&#x2F;20191030_NGS_DATA&#x2F;19R576_combined_R1.paired.fq.gz &#x2F;mnt&#x2F;e&#x2F;sequence_data_YNY&#x2F;20191030_NGS_DATA&#x2F;19R576_c</span><br><span class="line">ombined_R1.unpaired.fq.gz &#x2F;mnt&#x2F;e&#x2F;sequence_data_YNY&#x2F;20191030_NGS_DATA&#x2F;19R576_combined_R2.paired.fq.gz &#x2F;mnt&#x2F;e&#x2F;sequence_data_YNY&#x2F;20191030_NGS_DATA&#x2F;19R576_combined_R2.unpaired.fq.gz ILLUMINACLI</span><br><span class="line">P:$adapter.fa:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:36 ; trimmomatic PE -threads 12 -phred33 &#x2F;mnt&#x2F;e&#x2F;sequence_data_YNY&#x2F;20191030_NGS_DATA&#x2F;19R577_combined_R1.fastq.gz  &#x2F;mnt&#x2F;e&#x2F;</span><br><span class="line">sequence_data_YNY&#x2F;20191030_NGS_DATA&#x2F;19R577_combined_R2.fastq.gz  &#x2F;mnt&#x2F;e&#x2F;sequence_data_YNY&#x2F;20191030_NGS_DATA&#x2F;19R577_combined_R1.paired.fq.gz &#x2F;mnt&#x2F;e&#x2F;sequence_data_YNY&#x2F;20191030_NGS_DATA&#x2F;19R577</span><br><span class="line">_combined_R1.unpaired.fq.gz &#x2F;mnt&#x2F;e&#x2F;sequence_data_YNY&#x2F;20191030_NGS_DATA&#x2F;19R577_combined_R2.paired.fq.gz &#x2F;mnt&#x2F;e&#x2F;sequence_data_YNY&#x2F;20191030_NGS_DATA&#x2F;19R577_combined_R2.unpaired.fq.gz ILLUMINAC</span><br><span class="line">LIP:$adapter.fa:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:36</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/2_13.webp" alt="开始执行去接头"></p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/2_14.webp" alt="运行结束"></p>
<p>最终运行出的结果输出文件有四个，R1.paired.fq.gz 、R1.unpaired.fq.gz、 R2.paired.fq.gz 、R2.unpaired.fq.gz ，如果在接下来要进行序列比对的话用的文件只需要使用到两个paired文件。</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/2_15.webp" alt="输出结果"></p>
<p>到这里，我们的RNAseq流程中的原始数据处理(clean data)这一步就已经到这里就告一段落了。</p>
<p>参考链接：<br><a href="https://www.sohu.com/a/252244330_100269283">https://www.sohu.com/a/252244330_100269283</a><br><a href="https://zhuanlan.zhihu.com/p/61847802">https://zhuanlan.zhihu.com/p/61847802</a></p>
]]></content>
  </entry>
  <entry>
    <title>RNAseq_3_测序数据质控</title>
    <url>/2020/11/23/RNAseq-3-%E6%B5%8B%E5%BA%8F%E6%95%B0%E6%8D%AE%E8%B4%A8%E6%8E%A7/</url>
    <content><![CDATA[<h2 id="质量汇报生成与读取"><a href="#质量汇报生成与读取" class="headerlink" title="质量汇报生成与读取"></a>质量汇报生成与读取</h2><h3 id="fastq质量汇报"><a href="#fastq质量汇报" class="headerlink" title="fastq质量汇报"></a>fastq质量汇报</h3><p>使用命令<code>fastqc -o &lt;output dir&gt; &lt;seqfile1,seqfile2..&gt;</code>来进行质量报告。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下载fastqc工具包</span><br><span class="line">$ wget https:&#x2F;&#x2F;www.bioinformatics.babraham.ac.uk&#x2F;projects&#x2F;fastqc&#x2F;fastqc_v0.11.8.zip</span><br><span class="line"># 解压</span><br><span class="line">&amp; unzip fastqc_v0.11.8.zip</span><br><span class="line"># 执行fastqc</span><br><span class="line">&amp; ~FastQC&#x2F;.&#x2F;fastqc -f fastq -o &#x2F;home&#x2F;cenhui2018&#x2F;QWJ&#x2F;sequence_data&#x2F;20191030_NGS_DATA&#x2F;result &#x2F;home&#x2F;cenhui2018&#x2F;QWJ&#x2F;sequence_data&#x2F;20191030_NGS_DATA&#x2F;19R576_combined_R1.fastq</span><br></pre></td></tr></table></figure>
<p>需要注意的是./fastqc前面的”.”不可以省略</p>
<p>每个fastqc文件会获得一个质量分析报告，来描述此次RNA-seq的测序质量。 获取质量报告如图：</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/3_1.jpg" alt="Fastqc basic information"></p>
<h5 id="Basic-Statistics"><a href="#Basic-Statistics" class="headerlink" title="Basic Statistics"></a>Basic Statistics</h5><p>从read水平来总览，判断测序质量。 Encoding ：测序平台的版本，因为不同版本的 error p的计算方法不一样。 Total sequence：测序深度。一共测序的read数。是质量分析的主要参数。 Sequence length：测序长度。 %GC：GC碱基含量比，一般是物种特异性，比如人类是42%左右。</p>
<h5 id="Perbase-sequence-quality"><a href="#Perbase-sequence-quality" class="headerlink" title="Perbase sequence quality"></a>Perbase sequence quality</h5><p>横坐标： 第1-100个测序得到的碱基 纵坐标： 测序质量评估。这里的Q=-10*lg10(error P),即20%代表1%的错误读取率，30%代表0.1%的错误读取率 箱型图： 红色线，是某个顺序下测序碱基所有测序质量的中位数。黄色块，是测序质量在25%-75%区域。蓝色线，平均数。 一般要求： 测序箱型图10%的线大于Q=20。Q20过滤法。</p>
<h5 id="per-tail-sequence-quality"><a href="#per-tail-sequence-quality" class="headerlink" title="per tail sequence quality"></a>per tail sequence quality</h5><p>横坐标：同上。 纵坐标：tail的index编号。 目的：防止测序过程中某些tail受不可控因素测序质量低。 标准：蓝色表示质量高，浅色或暖色表示质量低，后续的分析可以去除低质量tail。</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/3_2.jpg" alt="per tail sequence quality"></p>
<h5 id="Per-sequence-quality-scores"><a href="#Per-sequence-quality-scores" class="headerlink" title="Per sequence quality scores"></a>Per sequence quality scores</h5><p>从read的总体测序质量分布来判定此次的测序质量，是质量分析的重要标准之一。 横坐标：表示read的测序质量Q=-10*lg10(error P)。 纵坐标：表示在该Q值下的read 的数量 标准：需要集中在高分区</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/3_3.jpg" alt="Per sequence quality scores"></p>
<h5 id="Per-base-sequence-content"><a href="#Per-base-sequence-content" class="headerlink" title="Per base sequence content"></a>Per base sequence content</h5><p>横坐标：1-100的测序碱基位置 纵坐标：碱基百分比 标准：理论上，ATCG碱基的分布应该差别不大，即四条线应该大致平行状态。如果AT或CG差异超过10%，此项检测是危险的。一般是测序机器前几个碱基测序时候因为状态调整导致测序略有偏差，如果前几个碱基偏差较大，可以在后期将前几个碱基切掉。造成这个偏差较大的原因重要是由于测序数据中的adapter没有clean干净。所以在接下来的数据处理中需要对测序数据进行clean data的处理，下一个章节会详细介绍clean data的步骤。</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/3_4.jpg" alt="Per base sequence content"></p>
<h5 id="Sequence-Length-Distribution"><a href="#Sequence-Length-Distribution" class="headerlink" title="Sequence Length Distribution"></a>Sequence Length Distribution</h5><p>统计read的碱基长度，本例理论上测序应该全是150bp。 横坐标：是read的碱基长度 纵坐标：是该长度下的read数量</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/3_5.jpg" alt="Sequence Length Distribution"></p>
<h5 id="Per-sequence-GC-content"><a href="#Per-sequence-GC-content" class="headerlink" title="Per sequence GC content"></a>Per sequence GC content</h5><p>横坐标：每个read的平局GC含量占比 纵坐标：一定GC比下的read数 标准：蓝色是理论值，红色是真实值。两者接近是比较好的状态。如果有双峰，可能混有了其他物种的DNA序列。</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/3_6.jpg" alt="Per sequence GC content"></p>
<h5 id="Adapter-Content"><a href="#Adapter-Content" class="headerlink" title="Adapter Content"></a>Adapter Content</h5><p>一般测序在初步生成fastq文件时候，adapter会被去除，但是有的会没有去除或者遗漏部分adapter。所以这一步是检测RNA-seq测序过程中adapter是否去除。如果没有去除会严重影响后续的比对工作。没有去除的adapter在质量处理环节会被处理掉。</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/3_7.jpg" alt="Adapter Content"></p>
<ol start="2">
<li>multiqc质量报告<br>multiqc可以对几个fastqc报告文件进行总结并汇总到一个报告文件中，以更直观到防止展示。使用方法</li>
</ol>
<blockquote>
<p>multiqc <analysis directory></p>
</blockquote>
<p>参考链接：<br><a href="https://zhuanlan.zhihu.com/p/61847802">https://zhuanlan.zhihu.com/p/61847802</a></p>
]]></content>
      <tags>
        <tag>RNAseq</tag>
      </tags>
  </entry>
  <entry>
    <title>RNAseq_4_序列比对以及samtools格式转换</title>
    <url>/2020/11/23/RNAseq-4-%E5%BA%8F%E5%88%97%E6%AF%94%E5%AF%B9%E4%BB%A5%E5%8F%8Asamtools%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p><strong>概况</strong>：使用处理后的fastq文件和基因组与转录组比对，确定在转录组或者基因组中的关系。在转录组和基因组的比对采取的方案不同。分别是<code>ungapped alignment to transcriptome</code>和<code>Gapped aligenment to genome</code>。 <strong>软件</strong>：<code>hisat2</code>和<code>STAR</code>在比对上都有比较好的表现。有文献显示，hisat2在纳伪较少但是弃真较多，但是速度比较快。STAR就比对而言综合质量比较好，在长短reads回帖上都有良好发挥。由于hisat2的速度优势，选择hisat2作为本次比对的软件。 在比对之前首先要先进行索引文件的获取或者制作。</p>
<h3 id="比对还是不比对"><a href="#比对还是不比对" class="headerlink" title="比对还是不比对"></a>比对还是不比对</h3><p>在比对之前，我们得了解比对的目的是什么？RNA-Seq数据比对和DNA-Seq数据比对有什么差异？<br>RNA-Seq数据分析分为很多种，比如说找差异表达基因或寻找新的可变剪切。如果找差异表达基因单纯只需要确定不同的read计数就行的话，我们可以用bowtie, bwa这类比对工具，或者是salmon这类align-free工具，并且后者的速度更快。</p>
<p>但是如果你需要找到新的isoform，或者RNA的可变剪切，看看外显子使用差异的话，你就需要TopHat, HISAT2或者是STAR这类工具用于找到剪切位点。因为RNA-Seq不同于DNA-Seq，DNA在转录成mRNA的时候会把内含子部分去掉。所以mRNA反转的cDNA如果比对不到参考序列，会被分开，重新比对一次，判断中间是否有内含子。</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/4_1.jpg"></p>
<h5 id="比对工具抉择"><a href="#比对工具抉择" class="headerlink" title="比对工具抉择"></a>比对工具抉择</h5><p>在2016年的一篇综述<em>A survey of best practices for RNA-seq data analysis</em>，提到目前有三种RNA数据分析的策略。那个时候的工具也主要用的是<strong>TopHat</strong>,<strong>STAR</strong>和<strong>Bowtie</strong>.其中<strong>TopHat</strong>目前已经被它的作者推荐改用<strong>HISAT</strong>进行替代。</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/4_2.jpg"></p>
<p>最近的Nature Communication发表了一篇题为的<em>Gaining comprehensive biological insight into the transcriptome by performing a broad-spectrum RNA-seq analysis</em>的文章–被称之为史上最全RNA-Seq数据分析流程，也是我一直以来想做的事情，只不过他们做的超乎我的想象。文章中在基于参考基因组的转录本分析中所用的工具，是TopHat,HISAT2和STAR，<strong>结论</strong>就是HISAT2<strong>找到junction正确率</strong>最高，但是在总数上却比TopHat和STAR少。从这里可以看出HISAT2的二类错误(<strong>纳伪</strong>）比较少，但是一类错误（<strong>弃真</strong>）就高起来。<br>就<strong>唯一比对</strong>而言，STAR是三者最佳的，主要是因为它不会像TopHat和HISAT2一样在PE比对不上的情况还强行把SE也比对到基因组上。而且在处理较长的read和较短read的不同情况，STAR的稳定性也是最佳的。<br>就<strong>速度</strong>而言，HISAT2比STAR和TopHat2平均快上2.5~100倍。</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/4_3.jpg" alt="image"></p>
<p>如果学习RNA-Seq数据分析，上面提到的两篇文献是必须要看上3遍以上的，而且建议每隔一段时间回顾一下。但是如果就比对工具而言，基本上就是HISAT2和STAR选一个就行。</p>
<h5 id="1-索引文件的获取"><a href="#1-索引文件的获取" class="headerlink" title="1. 索引文件的获取"></a>1. 索引文件的获取</h5><p>######下载index</p>
<p>首先，问自己一个问题，为什么比对的时候需要用到index？这里强烈建议大家去看Jimmy写的<a href="https://links.jianshu.com/go?to=http://www.biotrainee.com/thread-26-1-1.html">bowtie算法原理探究bowtie算法原理探究</a>。但是只是建议，你不需要真的去看，反正你也看不懂。</p>
<p>高通量测序遇到的第一个问题就是，成千上万甚至上几亿条read如果在合理的时间内比对到参考基因组上，并且保证错误率在接受范围内。为了提高比对速度，就需要根据参考基因组序列，经过BWT算法转换成index，而我们比对的序列其实是index的一个子集。当然转录组比对还要考虑到可变剪切的情况，所以更加复杂。</p>
<p>因此我门不是直接把read回贴到基因组上，而是把read和index进行比较。人类的index一般都是有现成的，我建议大家下载现成的，我曾经尝试过用服务器自己创建index，花的时间让我怀疑人生。<br>所以一般建议的做法就是直接从网站上下载已经index好的数据<br><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/4_4.jpg" alt="hisat2的index"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下载小鼠基因组的index</span><br><span class="line">mkdir mm10_indexed</span><br><span class="line">cd mm10_indexed&#x2F;</span><br><span class="line"># 从网站上下载安装包</span><br><span class="line">wget ftp:&#x2F;&#x2F;ftp.ccb.jhu.edu&#x2F;pub&#x2F;infphilo&#x2F;hisat2&#x2F;data&#x2F;mm10.tar.gz</span><br><span class="line">#解压</span><br><span class="line">tar zvfx mm10.tar.gz </span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>  不同的比对软件构建索引方式不同，所用的索引也不尽相同</li>
<li>  索引文件可以去网站下载也可以自己构建。但是索引构建会比较费时间。<a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/250607bd401f">建立索引文件需要大约一个小时（MAC: 2.6 GHz Intel Core i5/ 8 GB 1600 MHz DDR3）</a> 。</li>
<li>  网站下载hisat2基因组索引：<a href="https://link.zhihu.com/?target=http://ccb.jhu.edu/software/hisat2/index.shtml">http://ccb.jhu.edu/software/hisat2/index.shtml</a></li>
<li>  本地索引文件构建参考了CSDN<a href="https://link.zhihu.com/?target=https://me.csdn.net/qq_40280759">@ Richard_Jolin</a>的<a href="https://link.zhihu.com/?target=https://blog.csdn.net/qq_40280759/article/details/80552193">构建过程</a></li>
<li>  索引文件的格式如下，是由多个文件构成，要保证索引文件的格式和名称部分一致。</li>
</ul>
</blockquote>
<h5 id="2-hisat2的比对"><a href="#2-hisat2的比对" class="headerlink" title="2. hisat2的比对"></a>2. hisat2的比对</h5><p>使用hisat2<br>公式构建根据hisat2 的使用说明书构建了以下公式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hisat2  -p 6    -x &lt;dir of index of genome&gt;  -1  seq_val_1.fq.gz   -2  seq_val_2.fq.gz  -S  tem.hisat2.sam</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数说明：<br>-p #多线程数 -x #参考基因组索引文件目录和前缀 -1 #双端测序中一端测序文件 -2 #同上 -S #输出的sam文件</p>
</blockquote>
<p><strong>说明</strong>：在比对过程中，hisat会自动将双端测序匹配同一reads并在基因组中比对，最后两个双端测序生成一个sam文件。比对回帖过程需要消耗大量时间和电脑运行速度和硬盘存储空间。5G左右fastq文件比对回帖过程消耗大概一个小时，生成了17G的sam格式文件。回帖完成会生成一个回帖报告。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 首先利用conda安装版本为2.1.0的hisat软件</span><br><span class="line">conda install hisat2&#x3D;2.1.0</span><br><span class="line">#因为比对的过程比较长，所以利用nohup命令将程序放在后台执行，并将执行结束的</span><br><span class="line">nohup &#x2F;home&#x2F;cenhui2018&#x2F;QWJ&#x2F;sequence_data&#x2F;bio_soft&#x2F;Hisat2&#x2F;hisat2-2.1.0&#x2F;.&#x2F;hisat2 -p 16 -x ~&#x2F;QWJ&#x2F;sequence_data&#x2F;genome&#x2F;mm10_indexed&#x2F;mm10&#x2F;genome  -1 ~&#x2F;QWJ&#x2F;sequence_data&#x2F;20191030_NGS_DATA&#x2F;Clean_data&#x2F;19R576_combined_paired_R1.fastq -2 ~&#x2F;QWJ&#x2F;sequence_data&#x2F;20191030_NGS_DATA&#x2F;Clean_data&#x2F;19R576_combined_paired_R2.fastq -S ~&#x2F;QWJ&#x2F;sequence_data&#x2F;20191030_NGS_DATA&#x2F;19R576_paired.hisat2_2.sam &gt; program_2.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&amp;会把任务丢到后台，所以会同时执行这3个比对程序，如果CPU和内存承受不住，去掉&amp;一个个来。比对这一步是非常消耗内存资源的，这是比对工具要将索引数据放入内存引起的。</p>
<h4 id="HISAT2输出结果"><a href="#HISAT2输出结果" class="headerlink" title="HISAT2输出结果"></a>HISAT2输出结果</h4><p>比对之后会输出如下结果</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/4_5.jpg"></p>
<p>根据结果，显示的overall的比对率为97.19%</p>
<h5 id="3-SAMtools三板斧"><a href="#3-SAMtools三板斧" class="headerlink" title="3. SAMtools三板斧"></a>3. SAMtools三板斧</h5><p>SAM（sequence Alignment/mapping)数据格式是目前高通量测序中存放比对数据的标准格式，当然他可以用于存放未比对的数据。所以，<a href="https://links.jianshu.com/go?to=https://samtools.github.io/hts-specs/SAMv1.pdf">SAM</a>的格式说明</p>
<p>而目前处理SAM格式的工具主要是SAMTools，这是Heng Li大神写的.除了C语言版本，还有Java的Picard，Python的Pysam，Common lisp的cl-sam等其他版本。SAMTools的主要功能如下：</p>
<ul>
<li>  <strong>view</strong>: BAM-SAM/SAM-BAM 转换和提取部分比对</li>
<li>  <strong>sort</strong>: 比对排序</li>
<li>  <strong>merge</strong>: 聚合多个排序比对</li>
<li>  <strong>index</strong>: 索引排序比对</li>
<li>  <strong>faidx</strong>: 建立FASTA索引，提取部分序列</li>
<li>  <a href="https://links.jianshu.com/go?to=http://samtools.sourceforge.net/tview.shtml"><strong>tview</strong></a>: 文本格式查看序列</li>
<li>  <a href="https://links.jianshu.com/go?to=http://samtools.sourceforge.net/pileup.shtml"><strong>pileup</strong></a>: 产生基于位置的结果和 <a href="https://links.jianshu.com/go?to=http://samtools.sourceforge.net/cns0.shtml">consensus/indel calling</a></li>
</ul>
<p>最常用的三板斧就是格式转换，排序，索引。而进阶教程就是看文档提高。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 利用samtools工具将比对得到的sam文件转换为bam文件</span><br><span class="line">samtools view -S 19R576_paired.hisat2_2.sam -b &gt; 19R576_paired.hisat2_2.bam &amp;</span><br><span class="line"># 将得到的sam文件sort一下</span><br><span class="line">samtools sort 19R576_paired.hisat2_2.bam -o 19R576_paired.hisat2_2_sorted.bam</span><br><span class="line">#将得到的sort之后的bam文件排序</span><br><span class="line">samtools index 19R576_paired.hisat2_2_sorted.bam &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4-IGV查看"><a href="#4-IGV查看" class="headerlink" title="4. IGV查看"></a>4. IGV查看</h5><p>这个<code>seq_sourted.bam</code>文件可以通过<code>samtools</code>或者**<a href="https://link.zhihu.com/?target=http://www.igv.org/">IGV( Integrative Genomics Viewer)</a>**独立软件进行查看。在IGV软件中载入<code>seq_sourted.bam</code>文件。 可以很直观清晰地观察到reads在基因组中的回帖情况和外显子与内含子的关系。</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/4_6.jpg" alt="IGV查看结果"></p>
<p>参考文献：<br><a href="https://zhuanlan.zhihu.com/p/61847802">https://zhuanlan.zhihu.com/p/61847802</a><br><a href="https://www.jianshu.com/p/681e02e7f9af">https://www.jianshu.com/p/681e02e7f9af</a></p>
]]></content>
      <tags>
        <tag>RNAseq</tag>
      </tags>
  </entry>
  <entry>
    <title>RNAseq_6_无重复差异基因分析</title>
    <url>/2020/11/23/RNAseq-6-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%B7%AE%E5%BC%82%E5%9F%BA%E5%9B%A0%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>edgeR作用对象是count文件，rows 代表基因，行代表文库，count代表的是比对到每个基因的reads数目。它主要关注的是差异表达分析，而不是定量基因表达水平。</p>
<p>edgeR works on a table of integer read counts, with rows corresponding to genes and columns to independent libraries. The counts represent the total number of reads aligning to each gene (or other genomic locus).edgeR is concerned with diﬀerential expression analysis rather than with the quantiﬁcation of expression levels. It is concerned with relative changes in expression levels between conditions,but not directly with estimating absolute expression levels.</p>
<p>edgeR作用的是真实的比对统计，因此不建议用预测的转录本</p>
<p>Note that edgeR is designed to work with actual read counts. We not recommend that predicted transcript abundances are input the edgeR in place of actual counts.</p>
<p><strong>归一化原因：</strong></p>
<blockquote>
<p>技术原因影响差异表达分析：<br>1）Sequencing depth：统计测序深度(即代表的是library size)；<br>2）RNA composition：个别异常高表达基因导致其它基因采样不足<br>3）GC content： sample-speciﬁc eﬀects for GC-content can be detected<br>4）sample-speciﬁc eﬀects for gene length have been detected</p>
</blockquote>
<p><strong>注意：edgeR必须是原始表达量，而不能是rpkm等矫正过的。</strong><br>Note that normalization in edgeR is model-based, and the original read counts are not themselves transformed. This means that users should not transform the read counts in any way before inputing them to edgeR. For example, users should not enter RPKM or FPKM values to edgeR in place of read counts. Such quantities will prevent edgeR from correctly estimating the mean-variance relationship in the data, which is a crucial to the statistical strategies underlying edgeR.Similarly, users should not add artiﬁcial values to the counts before inputing them to edgeR.<br>个人是不太推荐没有重复的差异表达分析，因为毕竟统计学上的p值是为了证明两个样本的差异是真实存在而不是抽样误差导致的，<br>因此每当别人提问的时候, 我个人的建议就是定性看看倍数变化吧. 但是如果真的强行要算p值, 其实也不是不行, edgeR就是一种选择.</p>
<h2 id="1-首先安装edgeR-包"><a href="#1-首先安装edgeR-包" class="headerlink" title="1) 首先安装edgeR 包"></a>1) 首先安装edgeR 包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#如果没有安装BiocMaRnager则先安装BiocManager，之后通过BiocManager安装edgeR包</span><br><span class="line"></span><br><span class="line">if (!requireNamespace(&quot;BiocManager&quot;, quietly &#x3D; TRUE))</span><br><span class="line">    install.packages(&quot;BiocManager&quot;)</span><br><span class="line"></span><br><span class="line">BiocManager::install(&quot;edgeR&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>安装结束之后开始处理文件</p>
<h2 id="2）矩阵构建及差异分析"><a href="#2）矩阵构建及差异分析" class="headerlink" title="2）矩阵构建及差异分析"></a>2）矩阵构建及差异分析</h2><p>需要构建2个矩阵：1、表达矩阵；2、分组矩阵( 实验设计)；</p>
<h3 id="2-1-表达矩阵"><a href="#2-1-表达矩阵" class="headerlink" title="2.1) 表达矩阵"></a>2.1) 表达矩阵</h3><p>读取文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 首先读取counts文件之后查看count文件前6行</span><br><span class="line">&gt; rawdata &lt;- read.csv(file &#x3D; &quot;C:&#x2F;&#x2F;Users&#x2F;My&#x2F;Desktop&#x2F;diff_name&quot;,header &#x3D; T,stringsAsFactors &#x3D; F)</span><br><span class="line"># 查看读取的diff_name文件</span><br><span class="line">&gt; head(rawdata)</span><br><span class="line">  X    ensembl_gene_id               gene_id control_W55 test_K54 external_gene_name</span><br><span class="line">1 1 ENSMUSG00000000001  ENSMUSG00000000001.4           7       11              Gnai3</span><br><span class="line">2 2 ENSMUSG00000000003 ENSMUSG00000000003.15           0        0               Pbsn</span><br><span class="line">3 3 ENSMUSG00000000028 ENSMUSG00000000028.15           1        0              Cdc45</span><br><span class="line">4 4 ENSMUSG00000000031 ENSMUSG00000000031.16           0        2                H19</span><br><span class="line">5 5 ENSMUSG00000000037 ENSMUSG00000000037.17           0        0              Scml2</span><br><span class="line">6 6 ENSMUSG00000000049 ENSMUSG00000000049.11          54       33               Apoh</span><br></pre></td></tr></table></figure>

<p>读取完数据之后我们先预处理一下数据，比如我只想要ensembl_gene_id、control_w55、tese_k54、external_gene_name这几列，并调整一下顺序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; swap_rawdata &lt;- cbind(rawdata$ensembl_gene_id,rawdata$external_gene_name,rawdata$control_W55,rawdata$test_K54)</span><br><span class="line">&gt; head(swap_rawdata)</span><br><span class="line">     [,1]                 [,2]    [,3] [,4]</span><br><span class="line">[1,] &quot;ENSMUSG00000000001&quot; &quot;Gnai3&quot; &quot;7&quot;  &quot;11&quot;</span><br><span class="line">[2,] &quot;ENSMUSG00000000003&quot; &quot;Pbsn&quot;  &quot;0&quot;  &quot;0&quot; </span><br><span class="line">[3,] &quot;ENSMUSG00000000028&quot; &quot;Cdc45&quot; &quot;1&quot;  &quot;0&quot; </span><br><span class="line">[4,] &quot;ENSMUSG00000000031&quot; &quot;H19&quot;   &quot;0&quot;  &quot;2&quot; </span><br><span class="line">[5,] &quot;ENSMUSG00000000037&quot; &quot;Scml2&quot; &quot;0&quot;  &quot;0&quot; </span><br><span class="line">[6,] &quot;ENSMUSG00000000049&quot; &quot;Apoh&quot;  &quot;54&quot; &quot;33&quot;</span><br><span class="line"># 得到的这个swap_rawdata是一个matrix，如果想要让其变为data frame</span><br><span class="line">&gt; swap_rawdata &lt;- data.frame(swap_rawdata)</span><br><span class="line"># 查看一下是否转化成功</span><br><span class="line">&gt; head(swap_rawdata)</span><br><span class="line">     ensembl_gene_id external_gene_name control_W55 test_K54</span><br><span class="line">1 ENSMUSG00000000001              Gnai3           7       11</span><br><span class="line">2 ENSMUSG00000000003               Pbsn           0        0</span><br><span class="line">3 ENSMUSG00000000028              Cdc45           1        0</span><br><span class="line">4 ENSMUSG00000000031                H19           0        2</span><br><span class="line">5 ENSMUSG00000000037              Scml2           0        0</span><br><span class="line">6 ENSMUSG00000000049               Apoh          54       33</span><br><span class="line"># 转化完转化先存一份csv文件在电脑里，便于之后用电脑查看</span><br><span class="line">&gt; write.csv(x &#x3D; swap_rawdata,file &#x3D; &quot;C:&#x2F;&#x2F;Users&#x2F;My&#x2F;Desktop&#x2F;swap_rawdata.csv&quot;)</span><br><span class="line"># 存完之后直接从电脑导入你刚存的文件，这样做可以避免出现numeric数据框变成factor形式</span><br><span class="line">&gt; swap_rawdata &lt;- read.table(&quot;swap_rawdata.csv&quot;,header &#x3D; T,sep &#x3D; &quot;,&quot;)</span><br><span class="line"># 查看</span><br><span class="line">&gt; head(swap_rawdata)</span><br><span class="line">  X    ensembl_gene_id external_gene_name control_W55 test_K54</span><br><span class="line">1 1 ENSMUSG00000000001              Gnai3           7       11</span><br><span class="line">2 2 ENSMUSG00000000003               Pbsn           0        0</span><br><span class="line">3 3 ENSMUSG00000000028              Cdc45           1        0</span><br><span class="line">4 4 ENSMUSG00000000031                H19           0        2</span><br><span class="line">5 5 ENSMUSG00000000037              Scml2           0        0</span><br><span class="line">6 6 ENSMUSG00000000049               Apoh          54       33</span><br><span class="line">&gt; data.class(swap_rawdata[1,1])</span><br></pre></td></tr></table></figure>


<h3 id="2-2-接着构建DGEList对象"><a href="#2-2-接着构建DGEList对象" class="headerlink" title="2.2 接着构建DGEList对象"></a>2.2 接着构建DGEList对象</h3><p>这里因为已经有rawdata的count文件，因此直接用DGEList()函数就行了，否则要用readDGE()函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 首先载入edgeR 包</span><br><span class="line">&gt; library(edgeR)</span><br><span class="line"># 构建DGEList</span><br><span class="line">&gt; group &lt;- 1:2</span><br><span class="line">&gt; y &lt;- DGEList(counts &#x3D; swap_rawdata[,4:5],genes &#x3D; swap_rawdata[,2:3],group &#x3D; group)</span><br><span class="line"># 查看构建完y的信息</span><br><span class="line">&gt; y</span><br></pre></td></tr></table></figure>


<p><strong>查看构建DGElist的运行结果:</strong></p>
<blockquote>
<p> DGEList对象主要有三部分：</p>
</blockquote>
<blockquote>
<p><strong>1、counts矩阵</strong>：包含的是整数counts;</p>
</blockquote>
<blockquote>
<p><strong>2、samples数据框：</strong>包含的是文库(sample)信息。包含 lib.size列 ：for the library size (sequencing depth) for each sample,如果不自定义，  the library sizes will be computed from the column sums of the counts。其中还有一个group列，用于指定每个sample组信息</p>
</blockquote>
<blockquote>
<p>3、<strong>一个可选的数据框genes</strong>：gene的注释信息</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/6_1.jpg"></p>
<p><strong>第二步： 过滤 low counts数据。</strong>与DESeq2的预过滤不同，DESeq2的预过滤只是为了改善后续运算性能，在运行过程中依旧会自动处理low count数据，edgeR需要在分析前就要排除那些low count数据，而且非常严格。从生物学角度，有生物学意义的基因的表达量必须高于某一个阈值。从统计学角度上， low count的数据不太可能有显著性差异，而且在多重试验矫正阶段还会拖后腿。 </p>
<h5 id="数据过滤"><a href="#数据过滤" class="headerlink" title="数据过滤"></a>数据过滤</h5><p>由于原来的表达量矩阵基因数太大, 可能存在某些基因根本没有表达, 因此需要预先过滤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; keep &lt;- rowSums(cpm(y)&gt;1) &gt;&#x3D; 1</span><br><span class="line">&gt; y &lt;- y[keep, , keep.lib.sizes&#x3D;FALSE]</span><br><span class="line">&gt; y</span><br></pre></td></tr></table></figure>
<p>这部分代码的意思指的是保留在至少在一个样本里有表达的基因(CPM &gt; 1)。 基因数就从原来的55318变为15868</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/6_2.jpg"></p>
<p>###标准化<br>考虑到测序深度不同, 我们需要对其进行标准化, 避免文库大小不同导致的分析误差.</p>
<p>edgeR里默认采用TMM(trimmed mean of M-values) 对配对样本进行标准化，用到的函数是calcNormFactors</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; y &lt;- calcNormFactors(y)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/6_3.jpg"></p>
<h3 id="差异表达分析"><a href="#差异表达分析" class="headerlink" title="差异表达分析"></a>差异表达分析</h3><p>不同差异表达分析工具的目标就是预测出dispersion(离散值), 有了离散值就能够计算p值. 那么dispersion怎么计算呢? edgeR给了几个方法</p>
<p>根据经验给定一个值(BCV, square-root-dispersion). edgeR给的建议是, 如果你是人类数据, 且实验做的很好(无过多的其他因素影响), 设置为0.4, 如果是遗传上相似的模式物种（这里为小鼠）, 设置为0.1 （查询edgeR的bioconductor包所得）<br>Simply pick a reasonable dispersion value, based on your experience with similar data,and use that for exactTest or glmFit. Typical values for the common BCV (square-root dispersion) for datasets arising from well-controlled experiments are 0.4 for human data,0.1 for data on genetically identical model organisms or 0.01 for technical replicates.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; y_bcv &lt;- y</span><br><span class="line"># 因为本次的数据使用的是小鼠的数据，所以使用0.1</span><br><span class="line">&gt; bcv &lt;- 0.1</span><br><span class="line">&gt; et &lt;- exactTest(y_bcv, dispersion &#x3D; bcv ^ 2)</span><br><span class="line">&gt; gene1 &lt;- decideTestsDGE(et, p.value &#x3D; 0.05, lfc &#x3D; 0)</span><br><span class="line">&gt; head(gene1)</span><br><span class="line">&gt; summary(gene1)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/6_4.jpg"></p>
<p>由统计结果可知，下调的基因为816个，上调的基因为572个</p>
<p>如果觉得觉得基因较多的话，可以上调bcv的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; y_bcv &lt;- y</span><br><span class="line">&gt; bcv &lt;- 0.2</span><br><span class="line">&gt; et2 &lt;- exactTest(y_bcv, dispersion &#x3D; bcv ^ 2)</span><br><span class="line">&gt; gene2 &lt;- decideTestsDGE(et2, p.value &#x3D; 0.05, lfc &#x3D; 0)</span><br><span class="line">&gt; summary(gene2)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/6_5.jpg"></p>
<p>由统计结果可知，下调的基因为377个，上调的基因为221个<br>与之前的结果相比，的确已经减少很多</p>
<p>将结果整理成excel表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 改一下gene1的名称</span><br><span class="line">&gt; colnames(gene1) &lt;- &quot;Signifi&quot;</span><br><span class="line"># 组合将所需要的数据组成一个新的data.frame</span><br><span class="line">&gt; results &lt;- cbind(y$genes,y$counts,et$table,gene1)</span><br><span class="line">&gt; head(results)</span><br><span class="line"># 将新生成的results数据框写成一个excel数据表</span><br><span class="line">&gt; write.csv(x &#x3D; results,file &#x3D; &quot;C:&#x2F;&#x2F;Users&#x2F;My&#x2F;Desktop&#x2F;DEresult.csv&quot;,row.names &#x3D; F)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/6_6.jpg" alt="组合成的新的data.frame表"></p>
<p>生成的excel表可以将down expressed 和 up expressed基因分开</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/6_7.jpg" alt="生成的excel"></p>
<p>参考文献：<a href="https://blog.csdn.net/u012110870/article/details/102804557">https://blog.csdn.net/u012110870/article/details/102804557</a><br><a href="https://www.bioconductor.org/packages/release/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf">https://www.bioconductor.org/packages/release/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf</a></p>
<p><a href="https://cdn.jsdelivr.net/">https://cdn.jsdelivr.net</a></p>
]]></content>
      <tags>
        <tag>RNAseq</tag>
      </tags>
  </entry>
  <entry>
    <title>RNAseq_1_conda安装</title>
    <url>/2020/11/22/RNAseq-1-conda%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="conda简介"><a href="#conda简介" class="headerlink" title="conda简介"></a>conda简介</h2><p>Conda 是一个开源的软件包管理系统和环境管理系统，用于安装多个版本的软件包及其依赖关系，并在它们之间轻松切换。 Conda 是为 Python 程序创建的，适用于 Linux，OS X 和Windows，也可以打包和分发其他软件。</p>
<h2 id="安装conda"><a href="#安装conda" class="headerlink" title="安装conda"></a>安装conda</h2><p>conda分为anaconda和miniconda。anaconda是包含一些常用包的版本（这里的常用不代表你常用），miniconda则是精简版，需要啥装啥，所以推荐使用miniconda。</p>
<h3 id="下载网址"><a href="#下载网址" class="headerlink" title="下载网址"></a>下载网址</h3><blockquote>
<p>conda官网：<a href="https://links.jianshu.com/go?to=https://conda.io/miniconda.html">https://conda.io/miniconda.html</a></p>
</blockquote>
<p>选择适合自己的版本，用wget命令下载。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -c https:&#x2F;&#x2F;repo.continuum.io&#x2F;miniconda&#x2F;Miniconda3-latest-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>


<p>安装命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 777 Miniconda3-latest-Linux-x86_64.sh #给执行权限</span><br><span class="line">bash Miniconda3-latest-Linux-x86_64.sh #运行</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一路yes，安装成功</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/1_1.webp" alt="安装完成"></p>
<h4 id="激活conda"><a href="#激活conda" class="headerlink" title="激活conda"></a>激活conda</h4><p>找到你刚才安装的miniconda，如果没有更改过安装位置的话应该是在/home下面，cd到miniconda3的bin目录下面，能看到有一个activate</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/1-2.webp"></p>
<p>给activate添加一下权限才能使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#添加权限</span><br><span class="line">chmod 777 activate </span><br></pre></td></tr></table></figure>
<p>接下来启动conda</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">. .&#x2F;active</span><br><span class="line">#这两个点不是连在一起的</span><br></pre></td></tr></table></figure>
<p>需要注意一下的是/active前面的两个点之间不是连着一起的.<br>需要分开，其实这条命令也相当于source ./active</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/1-3.webp" alt="conda list"><br>当命令行前面出现(base)的时候说明现在已经在conda的环境中了。这时候输入conda list 命令就有反应了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure>
<p>以下是输入conda list 显示的结果</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/1-4.webp"></p>
<h2 id="利用conda安装生物信息软件"><a href="#利用conda安装生物信息软件" class="headerlink" title="利用conda安装生物信息软件"></a>利用conda安装生物信息软件</h2><h3 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令:"></a>安装命令:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda install samtools</span><br></pre></td></tr></table></figure>

<h3 id="搜索需要的安装包"><a href="#搜索需要的安装包" class="headerlink" title="搜索需要的安装包:"></a>搜索需要的安装包:</h3><p>提供一个网址,用于事先查找想安装的软件存不存在<br><a href="https://links.jianshu.com/go?to=https://bioconda.github.io/recipes">conda available packages</a></p>
<p>当然, 也可以用这个命令进行搜索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda search samtools</span><br></pre></td></tr></table></figure>
<p>提示错误，PackagesNotFoundError: The following packages are not available from current channels:，主要是没有为conda添加相应的下载软件安装包的channel</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/1-4.webp"></p>
<p>添加生物信息分析常用的channel，添加的是清华的镜像channel</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free&#x2F;</span><br><span class="line">conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;main&#x2F;</span><br><span class="line">conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud&#x2F;conda-forge&#x2F;</span><br><span class="line">conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud&#x2F;bioconda&#x2F;</span><br></pre></td></tr></table></figure>
<p>另外对channel常用的操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">显示安装的频道</span><br><span class="line"> conda config --set show_channel_urls yes </span><br><span class="line"></span><br><span class="line">查看已经添加的channels</span><br><span class="line">conda config --get channels</span><br><span class="line"></span><br><span class="line">已添加的channel在哪里查看</span><br><span class="line">vim ~&#x2F;.condarc</span><br></pre></td></tr></table></figure>


<p>添加完channel之后继续下载</p>
<p>利用conda安装生物信息软件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda install samtools</span><br></pre></td></tr></table></figure>

<p>提示安装进程，显示安装完成</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/1-5.webp"></p>
<p>安装完成后，可以用“which 软件名”来查看该软件安装的位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">which samtools</span><br></pre></td></tr></table></figure>
<p>显示samtools的安装路径</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/1-7.webp"></p>
<p>搜索目前软件包有哪几个版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda search samtools</span><br></pre></td></tr></table></figure>


<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/1-6.webp"></p>
<p>如需要安装特定的版本:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda install 软件名&#x3D;版本号</span><br><span class="line">conda samtools&#x3D;1.10</span><br></pre></td></tr></table></figure>
<p>这时conda会先卸载已安装版本，然后重新安装指定版本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看已安装软件:</span><br><span class="line">conda list</span><br></pre></td></tr></table></figure>


<p>更新指定软件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda update samtools</span><br></pre></td></tr></table></figure>

<p>卸载指定软件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda remove gatk</span><br></pre></td></tr></table></figure>

<p>退出conda环境<br>退出也很简单，之前我们是. ./activate 或者 (. ~/miniconda3/bin/activate)现在退出只要:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">. .&#x2F;deactivate</span><br></pre></td></tr></table></figure>
<p>就退出当前的环境了</p>
<p><a href="https://www.jianshu.com/p/edaa744ea47d">参考链接</a></p>
]]></content>
      <tags>
        <tag>RNAseq</tag>
      </tags>
  </entry>
  <entry>
    <title>RNAseq_5_count与基因注释</title>
    <url>/2020/11/23/RNAseq-5-count%E4%B8%8E%E5%9F%BA%E5%9B%A0%E6%B3%A8%E9%87%8A/</url>
    <content><![CDATA[<h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><p>在上篇的比对中，我们需要纠结是否真的需要比对，如果你只需要知道已知基因的表达情况，那么可以选择alignment-free工具（例如salmon, sailfish)，如果你需要找到noval isoforms，那么就需要alignment-based工具（如HISAT2, STAR）。到了这一篇的基因（转录本）定量，需要考虑的因素就更加多了，以至于我不知道如何说清才能理清逻辑。</p>
<p>定量分为三个水平</p>
<ul>
<li>  基因水平(gene-level)</li>
<li>  转录本水平(transcript-level)</li>
<li>  外显子使用水平(exon-usage-level)。</li>
</ul>
<p>在<strong>基因水平</strong>上，常用的软件为HTSeq-count，featureCounts，BEDTools, Qualimap, Rsubread, GenomicRanges等。以常用的HTSeq-count为例，这些工具要解决的问题就是根据read和基因位置的overlap判断这个read到底是谁家的孩子。值得<strong>注意</strong>的是不同工具对multimapping reads处理方式也是不同的，例如HTSeq-count就直接当它们不存在。而Qualimpa则是一人一份，平均分配。</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/5_1.jpg" alt="image"></p>
<p>对每个基因计数之后得到的count matrix再后续的分析中，要注意标准化的问题。如果你要比较同一个样本(within-sample)不同基因之间的表达情况，你就需要考虑到<strong>转录本长度</strong>，因为转录本越长，那么检测的片段也会更多，直接比较等于让小孩和大人进行赛跑。如果你是比较不同样本（across sample）同一个基因的表达情况，虽然不必在意转录本长度，但是你要考虑到<strong>测序深度</strong>（sequence depth)，毕竟测序深度越高，检测到的概率越大。除了这两个因素外，你还需要考虑GC%所导致的偏差，以及测序仪器的系统偏差。目前对read count标准化的算法有RPKM（SE）, FPKM（PE），TPM, TMM等，不同算法之间的差异与换算方法已经有文章进行整理和吐槽了。<strong>但是</strong>，有一些下游分析的软件会要求是输入的count matrix是原始数据，未经标准化，比如说DESeq2，这个时候你需要<strong>注意</strong>你上一步所用软件会不会进行标准化。</p>
<p>在<strong>转录本水平</strong>上，一般常用工具为Cufflinks和它的继任者StringTie， eXpress。这些软件要处理的难题就时转录本亚型（isoforms）之间通常是有重叠的，当二代测序读长低于转录本长度时，如何进行区分？这些工具大多采用的都是expectation maximization（EM）。好在我们有三代测序。</p>
<p>上述软件都是alignment-based，目前许多alignment-free软件，如kallisto, silfish, salmon，能够省去比对这一步，直接得到read count，在运行效率上更高。不过最近一篇文献[1]指出这类方法在估计丰度时存在样本特异性和读长偏差。</p>
<p>在<strong>外显子使用水平</strong>上，其实和基因水平的统计类似。但是值得注意的是为了更好的计数，我们需要提供无重叠的外显子区域的gtf文件[2]。用于分析差异外显子使用的DEXSeq提供了一个Python脚本（dexseq_prepare_annotation.py）执行这个任务。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>计数分为三个水平： gene-level, transcript-level, exon-usage-level</p>
<p>标准化方法： FPKM RPKM TMM TPM</p>
<h2 id="输出表达矩阵"><a href="#输出表达矩阵" class="headerlink" title="输出表达矩阵"></a>输出表达矩阵</h2><p>在RNA-Seq分析中，每一个基因就是一个feature（特征？），而基因被认为是它的所有外显子的和集。在可变剪切分析中，可以单独把每个外显子当作一个feature。而在ChIP-Seq分析中，feature则是预先定义的结合域。但是确定一个read到底属于哪一个feature有时会非常棘手。因此HTSeq提供了三种模式，示意图见前一幅图</p>
<ul>
<li>  the union of all the sets S(i) for mode union. This mode is recommended for most use cases.</li>
<li>  the intersection of all the sets S(i) for mode intersection-strict.</li>
<li>  the intersection of all non-empty sets S(i) for mode intersection-nonempty.</li>
</ul>
<p>基本用法非常的简单：</p>
<blockquote>
<p>htseq-count [options] <alignment_file> <gtf_file></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装</span><br><span class="line">conda install htseq</span><br><span class="line"># 利用htseq-count对sort之后的bam文件进行reads计数</span><br><span class="line">htseq-count -r pos -f bam &#x2F;home&#x2F;cenhui2018&#x2F;QWJ&#x2F;sequence_data&#x2F;20191030_NGS_DATA&#x2F;19R577_paired.hisat2_sorted.bam &#x2F;home&#x2F;cenhui2018&#x2F;QWJ&#x2F;sequence_data&#x2F;genome&#x2F;Anotation&#x2F;gencode.vM23.annotation.gtf &gt; 19R577_paired.count 2&gt;&#x2F;home&#x2F;cenhui2018&#x2F;QWJ&#x2F;sequence_data&#x2F;20191030_NGS_DATA&#x2F;19R577_htseq.log &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行的时间会比较久，所以可以去了解不同参数的用法了，其中比较常用的为：</p>
<ul>
<li>  -f bam/sam： 指定输入文件格式，默认SAM</li>
<li>  -r name/pos: 你需要利用samtool sort对数据根据read name或者位置进行排序，默认是name</li>
<li>  -s yes/no/reverse: 数据是否来自于strand-specific assay。DNA是双链的，所以需要判断到底来自于哪条链。如果选择了no， 那么每一条read都会跟正义链和反义链进行比较。默认的yes对于双端测序表示第一个read都在同一个链上，第二个read则在另一条链上。</li>
<li>  -a 最低质量， 剔除低于阈值的read</li>
<li>  -m 模式 union（默认）, intersection-strict and intersection-nonempty。一般而言就用默认的，作者也是这样认为的。</li>
<li>  -i id attribute: 在GTF文件的最后一栏里，会有这个基因的多个命名方式（如下）， RNA-Seq数据分析常用的是gene_id， 当然你可以写一个脚本替换成其他命名方式。</li>
</ul>
<p>对count数据进行查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 利用wc指令我们可以计算count文件的行数</span><br><span class="line">&gt; wc -l *.count</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/5_2.jpg" alt="统计count文件的行数"></p>
<p>看下每个文件的格式，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看前4行,第一列ensembl_gene_id,第二列read_count计数</span><br><span class="line">&gt; $ head -n 4 *.count     </span><br><span class="line"> # 查看后四行</span><br><span class="line">&gt; $ tail -n 4 *.count</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/5_3.jpg" alt="查看count文件的首行及末行"></p>
<h4 id="合并表达矩阵并进行注释（R中进行）"><a href="#合并表达矩阵并进行注释（R中进行）" class="headerlink" title="合并表达矩阵并进行注释（R中进行）"></a>合并表达矩阵并进行注释（R中进行）</h4><p>上一步得到的2个单独的矩阵文件，现在要把这<strong>2个文件合并为行为基因名，列为样本名，中间为count的矩阵文件</strong>。</p>
<ul>
<li><h6 id="从上面看出需要至少做两步工作才能更好理解和往下进行分析"><a href="#从上面看出需要至少做两步工作才能更好理解和往下进行分析" class="headerlink" title="从上面看出需要至少做两步工作才能更好理解和往下进行分析"></a>从上面看出需要至少做两步工作才能更好理解和往下进行分析</h6></li>
</ul>
<h6 id="第一，需要把2个文件合并；"><a href="#第一，需要把2个文件合并；" class="headerlink" title="第一，需要把2个文件合并；"></a>第一，需要把2个文件合并；</h6><h6 id="第二，需要把ensembl-gene-id转换为gene-symbol-（这一步不进行也行，后面还需要）"><a href="#第二，需要把ensembl-gene-id转换为gene-symbol-（这一步不进行也行，后面还需要）" class="headerlink" title="第二，需要把ensembl_gene_id转换为gene_symbol;（这一步不进行也行，后面还需要）"></a>第二，需要把ensembl_gene_id转换为gene_symbol;（这一步不进行也行，后面还需要）</h6><ul>
<li>  熟悉python的朋友可以参考<a href="https://www.jianshu.com/p/e9742bbf83b9">这篇文章</a></li>
<li>  我用R中的merge命令来处理，参考<a href="https://www.jianshu.com/p/24cf44b610a7">这里</a>和<a href="https://www.jianshu.com/p/e9742bbf83b9">这里</a></li>
</ul>
<p>运行R设置工作路径并查看当前目录下的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; setwd(&quot;&#x2F;home&#x2F;cenhui2018&#x2F;QWJ&#x2F;sequence_data&#x2F;20191030_NGS_DATA&#x2F;&quot;)</span><br><span class="line">&gt; list.files()</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/5_4.jpg"></p>
<h6 id="1-载入数据，添加列名"><a href="#1-载入数据，添加列名" class="headerlink" title="(1) 载入数据，添加列名"></a>(1) 载入数据，添加列名</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 防止R自动把字符串string的列辨认成factor</span><br><span class="line">&gt; options(stringAsFactor &#x3D;  FALSE)  </span><br><span class="line"># 从19R576_paired.count文件中读取数据，并添加列名，之后生成新文件命名为control_W55</span><br><span class="line">&gt; control_W55 &lt;- read.table(&quot;19R576_paired.count&quot;,sep &#x3D; &quot;\t&quot;,col.names&#x3D;c(&quot;gene_id&quot;,&quot;control_W55&quot;))</span><br><span class="line"># 查看前6行</span><br><span class="line">&gt; head(control_W55)</span><br><span class="line"># 类似的方法处理19R577_paired.count，并存储到</span><br><span class="line">&gt; test_K54 &lt;- read.table(&quot;19R577_paired.count&quot;,sep &#x3D; &quot;\t&quot;,col.names&#x3D;c(&quot;gene_id&quot;,&quot;test_K54&quot;))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/5_5.jpg"></p>
<p>######(2)数据整合<br><strong>merge进行整合</strong><br>gencode的注释文件中的gene_id（如ENSMUSG00000105298.13_3）在EBI是不能搜索到的，所以用gsub功能只保留ENSMUSG00000105298这部分<br>处理之前先看一下,也就是最后5行是我们不需要的，可以删除</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/5_6.jpg" alt="查看文件的最后五行"></p>
<p>整合文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将control_w55和test_K54这两个文件通过&quot;gene_id&quot;进行merge，生成新的merge好的文件raw_count</span><br><span class="line">&gt; raw_count &lt;- merge(control_W55,test_K54, by &#x3D; &quot;gene_id&quot;)</span><br><span class="line"># 查看merge后的文件的前6行</span><br><span class="line">&gt; head(raw_count)</span><br><span class="line"># 查看后六行</span><br><span class="line">&gt; tail(raw_count)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/5_7.jpg" alt="合并文件并查看前六行"><br><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/5_8.jpg" alt="查看合并后的文件的后六行"></p>
<p>######删除前5行<br>这里要注意，因为读入之后顺序变了，删除的时候看下删除的是哪些行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; raw_count_filt &lt;- raw_count[-1:-5,]</span><br><span class="line">&gt; head(raw_count_filt)</span><br></pre></td></tr></table></figure>
<p>删除之后的结果：</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/5_9.jpg"><br>######因为我们无法在EBI数据库上直接搜索找到ENSMUSG00000024045.5这样的基因，只能是ENSMUSG00000024045的整数，没有小数点，所以需要进一步替换为整数的形式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 第一步通过gsub工具将匹配到的.以及后面的数字连续匹配并替换为空，并赋值给ENSEMBL</span><br><span class="line">&gt;ENSEMBL &lt;- gsub(&quot;\\.\\d*&quot;, &quot;&quot;, raw_count_filt$gene_id) </span><br><span class="line"># 将ENSEMBL重新添加到raw_count_filt1矩阵</span><br><span class="line">&gt;row.names(raw_count_filt) &lt;- ENSEMBL</span><br><span class="line"># 查看&gt;head(raw_count_filt)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/5_10.jpg"></p>
<p>可以将最后得到的raw_count_filt文件通过save()函数保存成.Rdata文件，然后复制放在自己的桌面，然后用自己的Rstudio打开</p>
<h6 id="3-对基因进行注释-获取gene-symbol"><a href="#3-对基因进行注释-获取gene-symbol" class="headerlink" title="(3) 对基因进行注释-获取gene_symbol"></a>(3) 对基因进行注释-获取gene_symbol</h6><h6 id="以下两种方式可以进行"><a href="#以下两种方式可以进行" class="headerlink" title="以下两种方式可以进行"></a>以下两种方式可以进行</h6><p>第一：去<a href="https://biodbnet-abcc.ncifcrf.gov/db/db2db.php">这里</a>或<a href="https://www.biotools.fr/mouse/ensembl_symbol_converter">这里</a>的网页版，输入列表即可输出，不再赘述<br>第二：用bioMart对ensembl_id转换成gene_symbol<br>bioMart包是一个连接bioMart数据库的R语言接口，能通过这个软件包自由连接到bioMart数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 首先检查BioManager包是否安装</span><br><span class="line">if (!requireNamespace(&quot;BiocManager&quot;, quietly &#x3D; TRUE))</span><br><span class="line">    install.packages(&quot;BiocManager&quot;)</span><br><span class="line"># 如果BioManager包已经安装，则通过BioManager包安装biomaRt包</span><br><span class="line">BiocManager::install(&quot;biomaRt&quot;)</span><br><span class="line"># 因为我的文件是放在桌面上的，所以先设置R的工作目录为桌面路径</span><br><span class="line">&gt; setwd(&quot;C:&#x2F;&#x2F;Users&#x2F;My&#x2F;Desktop&#x2F;&quot;)</span><br><span class="line"># 加载放在桌面上的.Rdata文件</span><br><span class="line">&gt; load(&quot;raw_count.Rdata&quot;)</span><br><span class="line"># 加载所需要的R包</span><br><span class="line">&gt; library(&#39;biomaRt&#39;)</span><br><span class="line">&gt; library(&quot;curl&quot;)</span><br><span class="line"># 用bioMart对差异表达基因进行注释</span><br><span class="line">&gt; mart &lt;- useDataset(&quot;mmusculus_gene_ensembl&quot;, useMart(&quot;ensembl&quot;))</span><br><span class="line">&gt; my_ensembl_gene_id&lt;-row.names(raw_count_filt)</span><br><span class="line">&gt; mms_symbols&lt;- getBM(attributes&#x3D;c(&#39;ensembl_gene_id&#39;,&#39;external_gene_name&#39;,&quot;description&quot;),filters &#x3D; &#39;ensembl_gene_id&#39;, values &#x3D; my_ensembl_gene_id, mart &#x3D; mart)</span><br></pre></td></tr></table></figure>
<p>执行完之后需要等待一段时间提交检索，下方会有一个进度条</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/5_11.jpg"></p>
<p>基因注释结束后，查看注释结果</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/5_12.jpg" alt="基因注释结束后的结果"></p>
<p>####合并数据成一个文件</p>
<p>注意：合并的话两个数据必须有共同的列名，我们先看一下</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/5_13.jpg"></p>
<p>可见，两个文件没有共同的列名，所以要先给’raw_count_filt’添加一个‘ensembl_gene_id’的列名<br>方法如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将raw_count_filt的行名赋值到一个ensembl_gene_id的变量</span><br><span class="line">&gt; ensembl_gene_id&lt;-rownames(raw_count_filt)</span><br><span class="line"># 将行名单独变成一列加到raw_count_filt文件中</span><br><span class="line">&gt; raw_count_filt &lt;- cbind(ensembl_gene_id,raw_count_filt)</span><br><span class="line"># 添加列名</span><br><span class="line">&gt; colnames(raw_count_filt)[1] &lt;- c(&quot;ensembl_gene_id&quot;)</span><br><span class="line"># 将raw_count_filt文件和mms_symbols文件通过ensembl_gene_id而merge在一起，生成新的文件</span><br><span class="line">&gt; diff_name&lt;-merge(raw_count_filt,mms_symbols,by&#x3D;&quot;ensembl_gene_id&quot;)</span><br><span class="line"># 查看新文件前6行</span><br><span class="line">&gt; head(diff_name)</span><br></pre></td></tr></table></figure>
<p>代码执行结果：</p>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/5_14.jpg" alt="执行结果"></p>
<p>现在成功地生成了一个带有基因名称的count表达矩阵</p>
<p>参考链接：<br><a href="https://blog.csdn.net/lztttao/article/details/82086346">https://blog.csdn.net/lztttao/article/details/82086346</a><br><a href="https://www.jianshu.com/p/3a0e1e3e41d0">https://www.jianshu.com/p/3a0e1e3e41d0</a></p>
]]></content>
      <tags>
        <tag>RNAseq</tag>
      </tags>
  </entry>
  <entry>
    <title>GEO数据库的使用及数据分析(练习)</title>
    <url>/2020/12/05/GEO%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p><strong>GEO数据链接：</strong><br><a href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE61763">https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE61763</a></p>
<pre><code>#安装GEOquery package
&gt; if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE))
    install.packages(&quot;BiocManager&quot;)

&gt; BiocManager::install(&quot;GEOquery&quot;)

&gt; library(GEOquery)</code></pre>
<p>因为GFW的原因，导致部分用户出现网络错误，导致不能下载数据，所以需要修改一下这个option</p>
<pre><code>&gt; options(&#39;download.file.method.GEOquery&#39;=&#39;libcurl&#39;)
#开始下载GEO数据
&gt; gse &lt;- getGEO(&#39;GSE61763&#39;)

## Found 1 file(s)
GSE61763_series_matrix.txt.gz
试开URL’https://ftp.ncbi.nlm.nih.gov/geo/series/GSE61nnn/GSE61763/matrix/GSE61763_series_matrix.txt.gz&#39;
 length 7625052 bytes (7.3 MB)
downloaded 7.3 MB


-- Column specification ------------------------------------------------------------------------------
cols(
  .default = col_double(),
  ID_REF = col_character()
)
i Use `spec()` for the full column specifications.

File stored at: 
C:\Users\lenovo\AppData\Local\Temp\RtmpABSroa/GPL19197.soft</code></pre>
<h2 id="查看下载的GSE数据"><a href="#查看下载的GSE数据" class="headerlink" title="查看下载的GSE数据"></a>查看下载的GSE数据</h2><pre><code>&gt; head(gse)

$GSE61763_series_matrix.txt.gz
ExpressionSet (storageMode: lockedEnvironment)
assayData: 57176 features, 30 samples 
  element names: exprs 
protocolData: none
phenoData
  sampleNames: GSM1513596 GSM1513597 ... GSM1513625 (30 total)
  varLabels: title geo_accession ... tnm:ch1 (49 total)
  varMetadata: labelDescription
featureData
  featureNames: A_23_P100001 A_23_P100022 ... CUST_9_PI427704219 (57176 total)
  fvarLabels: ID GB_ACC ... Sequence (5 total)
  fvarMetadata: Column Description labelDescription
experimentData: use &#39;experimentData(object)&#39;
  pubMedIds: 25685243 
Annotation: GPL19197 </code></pre>
<h2 id="提取表达矩阵"><a href="#提取表达矩阵" class="headerlink" title="提取表达矩阵"></a>提取表达矩阵</h2><pre><code>&gt; gset &lt;- gse[[1]]
&gt; head(gset)

ExpressionSet (storageMode: lockedEnvironment)
assayData: 1 features, 30 samples 
  element names: exprs 
protocolData: none
phenoData
  sampleNames: GSM1513596 GSM1513597 ... GSM1513625 (30 total)
  varLabels: title geo_accession ... tnm:ch1 (49 total)
  varMetadata: labelDescription
featureData
  featureNames: A_23_P100001
  fvarLabels: ID GB_ACC ... Sequence (5 total)
  fvarMetadata: Column Description labelDescription
experimentData: use &#39;experimentData(object)&#39;
  pubMedIds: 25685243 
Annotation: GPL19197 


#提取表型数据信息
&gt; pdata &lt;- pData(gset)

# 查看数据的维度，共30个样本数据，也就是15对
&gt; dim(pdata)
[1] 30 49

# 强制限定顺序
&gt; group_list &lt;- relevel(group_list, ref=&#39;tumor&#39;)
&gt; group_list
 [1] tumor  normal tumor  normal tumor  normal tumor  normal tumor  normal tumor  normal tumor  normal
[15] tumor  normal tumor  normal tumor  normal tumor  normal tumor  normal tumor  normal tumor  normal
[29] tumor  normal
Levels: tumor normal

#boxplot查看整体样本的表达情况
&gt; boxplot(exprSet,outline=FALSE,notch=T,col=group_list,las=2)</code></pre>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/GEOboxplot_before.png" alt="校正前"></p>
<center>校正前的整体样本表达情况</center>

<p>整体表达不整齐，使用limma包内置函数人工校正</p>
<pre><code>&gt; library(limma)

载入程辑包：&#39;limma&#39;

The following object is masked from &#39;package:BiocGenerics&#39;:

    plotMA

&gt; exprSet &lt;- normalizeBetweenArrays(exprSet)
&gt; boxplot(exprSet,outline=FALSE,notch=T,col=group_list,las=2)</code></pre>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/boxplot_after.png" alt="校正后"></p>
<center>校正后就感觉数据整体平整很多</center>

<h2 id="表达量很大，log转换-选log2"><a href="#表达量很大，log转换-选log2" class="headerlink" title="表达量很大，log转换(选log2)"></a>表达量很大，log转换(选log2)</h2><pre><code>&gt; ex &lt;- exprSet
&gt; qx &lt;- as.numeric(quantile(ex, c(0., 0.25, 0.5, 0.75, 0.99, 1.0), na.rm=T))
&gt; LogC &lt;- (qx[5] &gt; 100) ||
+ (qx[6]-qx[1] &gt; 50 &amp;&amp; qx[2] &gt; 0) ||
+ (qx[2] &gt; 0 &amp;&amp; qx[2] &lt; 1 &amp;&amp; qx[4] &gt; 1 &amp;&amp; qx[4] &lt; 2)

&gt; if (LogC) &#123; ex[which(ex &lt;= 0)] &lt;- NaN
+ exprSet &lt;- log2(ex) &#125;
&gt; dim(exprSet)
[1] 57176    30</code></pre>
<h2 id="添加Annotation"><a href="#添加Annotation" class="headerlink" title="添加Annotation"></a>添加Annotation</h2><pre><code>&gt; gpl&lt;- getGEO(&#39;GPL19197&#39;,destdir = &#39;./&#39;)
File stored at: 
.//GPL19197.soft
&gt; GPL19197 &lt;- GEOquery::Table(gpl)
&gt; probeset &lt;- rownames(exprSet)
&gt; probe2symbol &lt;- data.frame(probeset,symbol=GPL19197$`Gene Symbol`,stringsAsFactors = F)
&gt; dim(probe2symbol)
[1] 57176     2
&gt; head(probe2symbol)
      probeset  symbol
1 A_23_P100001 FAM174B
2 A_23_P100022    SV2B
3 A_23_P100056  RBPMS2
4 A_23_P100074    AVEN
5 A_23_P100127   CASC5
6 A_23_P100141    UNKL</code></pre>
<h2 id="去除表达矩阵的一些缺失值"><a href="#去除表达矩阵的一些缺失值" class="headerlink" title="去除表达矩阵的一些缺失值"></a>去除表达矩阵的一些缺失值</h2><pre><code>&gt; library(dplyr)

载入程辑包：&#39;dplyr&#39;

&gt; library(tibble)

载入程辑包：&#39;tibble&#39;

The following object is masked from &#39;package:ShortRead&#39;:

    view

&gt; exprSet &lt;- as.data.frame(exprSet)
&gt; exprSet &lt;- exprSet %&gt;% 
+     rownames_to_column(var=&#39;probeset&#39;) %&gt;% 
+     #合并探针的信息
+     inner_join(probe2symbol,by=&#39;probeset&#39;) %&gt;% 
+     #去掉多余信息
+     select(-probeset) %&gt;% 
+     #重新排列
+     select(symbol,everything()) %&gt;% 
+     #求出平均数(这边的点号代表上一步产出的数据)
+     mutate(rowMean =rowMeans(.[grep(&#39;GSM&#39;, names(.))])) %&gt;%
+     # #去除symbol中的NA 
+     filter(symbol != &#39;NA&#39;) %&gt;% 
+     #把表达量的平均值按从大到小排序
+     arrange(desc(rowMean)) %&gt;% 
+     # symbol留下第一个
+     distinct(symbol,.keep_all = T) %&gt;%
+     #反向选择去除rowMean这一列 
+     select(-rowMean) %&gt;% 
+     # 列名变成行名
+     column_to_rownames(var = &#39;symbol&#39;)
&gt; exprSet &lt;- na.omit(exprSet)
&gt; dim(exprSet)
[1] 22723    30</code></pre>
<h2 id="PCA分析"><a href="#PCA分析" class="headerlink" title="PCA分析"></a>PCA分析</h2><pre><code>&gt; pcaData &lt;- exprSet
&gt; head(pcaData)
        GSM1513596 GSM1513597 GSM1513598 GSM1513599 GSM1513600
ZNF865    18.83438   18.74083   18.83438   18.83438   18.83438
RN28S1    18.74083   18.83438   18.74083   18.74083   18.74083
PQLC2     18.39928   18.59863   18.59863   18.59863   18.50781
GPR155    18.59863   18.32740   18.39928   18.32740   18.32740
          17.83468   18.22174   18.32740   18.22174   18.39928
FAM74A4   18.32740   17.89507   18.22174   18.05010   18.22174
        GSM1513601 GSM1513602 GSM1513603 GSM1513604 GSM1513605
ZNF865    18.74083   18.83438   18.74083   18.74083   18.74083
RN28S1    18.83438   18.74083   18.83438   18.83438   18.83438
PQLC2     18.50781   18.50781   18.50781   17.33055   18.59863
GPR155    18.22174   18.39928   18.22174   18.39928   18.32740
          18.13508   18.13508   18.32740   18.59863   18.39928
FAM74A4   17.67673   17.94982   18.00258   18.22174   18.05010
        GSM1513606 GSM1513607 GSM1513608 GSM1513609 GSM1513610
ZNF865    18.59863   18.83438   18.50781   18.83438   18.74083
RN28S1    18.74083   18.50781   18.39928   18.74083   18.83438
PQLC2     18.50781   18.59863   18.32740   18.22174   18.59863
GPR155    18.13508   18.39928   18.00258   18.50781   18.22174
          18.22174   18.32740   18.05010   18.05010   18.39928
FAM74A4   18.05010   18.00258   17.79035   18.39928   18.05010
        GSM1513611 GSM1513612 GSM1513613 GSM1513614 GSM1513615
ZNF865    18.74083   18.83438   18.74083   18.83438   18.83438
RN28S1    18.83438   18.50781   18.83438   18.74083   18.74083
PQLC2     18.50781   18.74083   18.05010   18.59863   18.50781
GPR155    18.32740   18.39928   18.50781   18.32740   18.39928
          18.39928   18.32740   18.39928   18.39928   18.13508
FAM74A4   18.13508   18.13508   18.32740   18.13508   18.22174
        GSM1513616 GSM1513617 GSM1513618 GSM1513619 GSM1513620
ZNF865    18.83438   18.83438   18.39928   18.83438   18.83438
RN28S1    18.50781   18.74083   18.59863   18.39928   18.50781
PQLC2     18.59863   18.59863   18.32740   18.59863   18.59863
GPR155    18.22174   18.39928   18.05010   18.50781   18.39928
          18.32740   18.32740   18.22174   18.32740   18.32740
FAM74A4   18.00258   18.22174   17.83468   18.13508   18.13508
        GSM1513621 GSM1513622 GSM1513623 GSM1513624 GSM1513625
ZNF865    18.74083   18.74083   18.74083   18.83438   18.50781
RN28S1    18.83438   18.83438   18.83438   18.50781   18.83438
PQLC2     18.13508   18.50781   18.50781   18.74083   18.22174
GPR155    18.50781   18.32740   18.32740   18.22174   18.32740
          18.39928   18.39928   18.39928   18.39928   18.59863
FAM74A4   18.32740   17.83468   18.22174   18.05010   18.00258

#将基因名和样品名进行转置
&gt; pcaDataT &lt;- as.data.frame(t(pcaData))
# 查看数据维度
&gt; dim(pcaDataT)
[1]    30 22723

&gt; head(pcaDataT)[,1:3]
             ZNF865   RN28S1    PQLC2
GSM1513596 18.83438 18.74083 18.39928
GSM1513597 18.74083 18.83438 18.59863
GSM1513598 18.83438 18.74083 18.59863
GSM1513599 18.83438 18.74083 18.59863
GSM1513600 18.83438 18.74083 18.50781
GSM1513601 18.74083 18.83438 18.50781

#将分类信息加上，方便后面作图时颜色来区分
&gt; pcaDataTGroup &lt;- cbind(pcaDataT,as.data.frame(group_list))
&gt; dim(pcaDataTGroup)
[1]    30 22724
&gt; head(pcaDataTGroup)[,22720:22724]
            GALNTL5 LOC647012 LOC339822     ODF1 group_list
GSM1513596 2.962558  2.368222  3.321705 3.150202      tumor
GSM1513597 3.524921  3.030981  3.647162 3.441140     normal
GSM1513598 2.515347  1.696235  2.649310 2.854849      tumor
GSM1513599 2.791733  1.647627  2.854849 3.157716     normal
GSM1513600 1.647627  2.861833  2.064990 2.649310      tumor
GSM1513601 3.030981  2.233265  2.875022 2.462675     normal

#使用R自带的prcomp()函数进行分析
&gt; pca &lt;- prcomp(pcaDataT,scale=TRUE)
# 查看一下汇总情况
&gt; summary(pca)
Importance of components:
                           PC1     PC2      PC3      PC4
Standard deviation     69.7013 53.6954 41.59722 38.27877
Proportion of Variance  0.2138  0.1269  0.07615  0.06448
Cumulative Proportion   0.2138  0.3407  0.41684  0.48132
                            PC5      PC6      PC7      PC8
Standard deviation     34.27880 32.53043 29.90406 27.07682
Proportion of Variance  0.05171  0.04657  0.03935  0.03226
Cumulative Proportion   0.53303  0.57960  0.61896  0.65122
                            PC9     PC10     PC11    PC12
Standard deviation     26.73741 25.63509 24.28643 23.4961
Proportion of Variance  0.03146  0.02892  0.02596  0.0243
Cumulative Proportion   0.68268  0.71160  0.73756  0.7619
                           PC13     PC14     PC15     PC16
Standard deviation     22.54617 21.24446 20.90725 19.67930
Proportion of Variance  0.02237  0.01986  0.01924  0.01704
Cumulative Proportion   0.78423  0.80409  0.82333  0.84037
                           PC17     PC18     PC19     PC20
Standard deviation     19.62633 19.39049 18.81680 18.53608
Proportion of Variance  0.01695  0.01655  0.01558  0.01512
Cumulative Proportion   0.85732  0.87387  0.88945  0.90457
                           PC21     PC22     PC23     PC24
Standard deviation     17.27997 16.62282 16.24557 15.85570
Proportion of Variance  0.01314  0.01216  0.01161  0.01106
Cumulative Proportion   0.91771  0.92987  0.94149  0.95255
                           PC25     PC26     PC27     PC28
Standard deviation     15.68151 15.07915 14.48868 14.27492
Proportion of Variance  0.01082  0.01001  0.00924  0.00897
Cumulative Proportion   0.96337  0.97338  0.98262  0.99159
                           PC29      PC30
Standard deviation     13.82776 1.559e-13
Proportion of Variance  0.00841 0.000e+00
Cumulative Proportion   1.00000 1.000e+00


#查看一下数据结构
&gt; str(pca)
List of 5
 $ sdev    : num [1:30] 69.7 53.7 41.6 38.3 34.3 ...
 $ rotation: num [1:22723, 1:30] 0.00525 -0.00221 0.00164 -0.00047 0.00375 ...
  ..- attr(*, &quot;dimnames&quot;)=List of 2
  .. ..$ : chr [1:22723] &quot;ZNF865&quot; &quot;RN28S1&quot; &quot;PQLC2&quot; &quot;GPR155&quot; ...
  .. ..$ : chr [1:30] &quot;PC1&quot; &quot;PC2&quot; &quot;PC3&quot; &quot;PC4&quot; ...
 $ center  : Named num [1:22723] 18.8 18.7 18.5 18.3 18.3 ...
  ..- attr(*, &quot;names&quot;)= chr [1:22723] &quot;ZNF865&quot; &quot;RN28S1&quot; &quot;PQLC2&quot; &quot;GPR155&quot; ...
 $ scale   : Named num [1:22723] 0.113 0.144 0.268 0.134 0.159 ...
  ..- attr(*, &quot;names&quot;)= chr [1:22723] &quot;ZNF865&quot; &quot;RN28S1&quot; &quot;PQLC2&quot; &quot;GPR155&quot; ...
 $ x       : num [1:30, 1:30] -70.3 68.8 -65.9 86.2 -49.5 ...
  ..- attr(*, &quot;dimnames&quot;)=List of 2
  .. ..$ : chr [1:30] &quot;GSM1513596&quot; &quot;GSM1513597&quot; &quot;GSM1513598&quot; &quot;GSM1513599&quot; ...
  .. ..$ : chr [1:30] &quot;PC1&quot; &quot;PC2&quot; &quot;PC3&quot; &quot;PC4&quot; ...
 - attr(*, &quot;class&quot;)= chr &quot;prcomp


&gt; head(data_pca)[,22720:22726]
            GALNTL5 LOC647012 LOC339822     ODF1 group_list
GSM1513596 2.962558  2.368222  3.321705 3.150202      tumor
GSM1513597 3.524921  3.030981  3.647162 3.441140     normal
GSM1513598 2.515347  1.696235  2.649310 2.854849      tumor
GSM1513599 2.791733  1.647627  2.854849 3.157716     normal
GSM1513600 1.647627  2.861833  2.064990 2.649310      tumor
GSM1513601 3.030981  2.233265  2.875022 2.462675     normal
                 PC1        PC2
GSM1513596 -70.29442 -106.21949
GSM1513597  68.78575  -50.57325
GSM1513598 -65.90130  -80.09775
GSM1513599  86.22612  -76.48759
GSM1513600 -49.48738  -93.12600
GSM1513601  56.59620   14.35318


&gt; ggplot(data_pca,aes(PC1,PC2,col=group_list,fill=group_list))+
+     stat_ellipse(geom=&quot;polygon&quot;,col=&quot;black&quot;,alpha=0.5)+
+     geom_point(shape=21,col=&quot;black&quot;,size=1.2)+
+     theme(panel.background = element_rect(fill=&quot;transparent&quot;,color=&quot;black&quot;),
+           panel.grid.minor = element_blank(), 
+           panel.grid.major = element_blank())</code></pre>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/PCA.png" alt="PCA"></p>
<center>PCA(Principal components analysis)</center>


<h2 id="差异基因分析"><a href="#差异基因分析" class="headerlink" title="差异基因分析"></a>差异基因分析</h2><pre><code>&gt; pairinfo &lt;- factor(c(1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15))
&gt; pairinfo
 [1] 1  1  2  2  3  3  4  4  5  5  6  6  7  7  8  8  9  9  10
[20] 10 11 11 12 12 13 13 14 14 15 15
Levels: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
&gt; design &lt;- model.matrix(~ pairinfo+group_list)
&gt; fit &lt;- lmFit(exprSet,design)
#使用经验贝叶斯算法计算差异表达基因的显著性
&gt; fit &lt;- eBayes(fit)
#使用“FDR校正”
&gt; allDiff_pair &lt;- topTable(fit,adjust=&#39;fdr&#39;,coef=1,n = Inf,p.value = 0.05)</code></pre>
<h2 id="使用pheatmap-绘制Heatmap"><a href="#使用pheatmap-绘制Heatmap" class="headerlink" title="使用pheatmap()绘制Heatmap"></a>使用pheatmap()绘制Heatmap</h2><pre><code>&gt; library(pheatmap)
&gt; allDiff_pair2 &lt;- topTable(fit,adjust=&#39;fdr&#39;,coef=1,number=Inf,p.value=0.05,lfc = 1) 
&gt; heatdata &lt;- exprSet[rownames(allDiff_pair2),]
&gt; heat &lt;- na.omit(heatdata)
&gt; annotation_col &lt;- data.frame(group_list)
&gt; rownames(annotation_col) &lt;- colnames(heatdata)
&gt; pheatmap(heat, 
+          cluster_rows = TRUE,
+          cluster_cols = TRUE,
+          annotation_col =annotation_col, 
+          annotation_legend=TRUE, 
+          show_rownames = F,
+          show_colnames = T,
+          scale = &#39;row&#39;, 
+          color =colorRampPalette(c(&#39;blue&#39;, &#39;white&#39;,&#39;red&#39;))(100))</code></pre>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/heatmap.png"></p>
<p>火山图绘制</p>
<pre><code>&gt; library(ggplot2)
&gt; library(ggrepel)
&gt; library(dplyr)
&gt; data &lt;- topTable(fit1,adjust=&#39;fdr&#39;,coef=&quot;group_listnormal&quot;,number=Inf)
&gt; dim(data)
[1] 22723     6
&gt; data$significant &lt;- as.factor(data$adj.P.Val&lt;0.05 &amp; abs(data$logFC) &gt; 1)
&gt; data$gene &lt;- rownames(data)
&gt; ggplot(data=data, aes(x=logFC, y =-log10(adj.P.Val),color=significant)) +
+     geom_point(alpha=0.8, size=1.2,col=&#39;black&#39;)+
+     geom_point(data=subset(data, logFC &gt; 1),alpha=0.8, size=1.2,col=&#39;red&#39;)+
+     geom_point(data=subset(data, logFC &lt; -1),alpha=0.6, size=1.2,col=&#39;blue&#39;)+
+     labs(x=&#39;log2 (fold change)&#39;,y=&#39;-log10 (adj.P.Val)&#39;)+
+     theme(plot.title = element_text(hjust = 0.4))+
+     geom_hline(yintercept = -log10(0.05),lty=4,lwd=0.6,alpha=0.8)+
+     geom_vline(xintercept = c(1,-1),lty=4,lwd=0.6,alpha=0.8)+
+     theme_bw()+
+     theme(panel.border = element_blank(),
+           panel.grid.major = element_blank(), 
+           panel.grid.mi
+           nor = element_blank(),   
+           axis.line = element_line(colour = &#39;black&#39;))</code></pre>
<p><img src="https://raw.githubusercontent.com/kevinQIAN1996/Figurebed/main/img/volcanoplot2.png"></p>
<p>感觉这个火山图变成这个样子有些奇怪，怀疑是数据原因本身造成的</p>
]]></content>
      <tags>
        <tag>GEO Database</tag>
      </tags>
  </entry>
</search>
