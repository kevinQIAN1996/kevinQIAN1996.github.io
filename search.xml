<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数值型向量及其运算</title>
    <url>/2020/10/31/R-%E6%95%B0%E5%80%BC%E5%9E%8B%E5%90%91%E9%87%8F%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="数值型向量"><a href="#数值型向量" class="headerlink" title="数值型向量"></a>数值型向量</h2><p><strong>向量</strong>是将若干个基础类型相同的值存储在一起， 各个元素可以按序号访问。 如果将若干个数值存储在一起可以用序号访问， 就叫做一个数值型向量。</p>
<p>用c()函数把多个元素或向量组合成一个向量。如</p>
<pre><code>&gt; marks &lt;- c(10, 6, 4, 7, 8)
&gt; x &lt;- c(1:3, 10:13)
&gt; x1 &lt;- c(1, 2)
&gt; x2 &lt;- c(3, 4)
&gt; x &lt;- c(x1, x2)
&gt; x

运行结果
## [1] 1 2 3 4</code></pre>
<p>10:13这样的写法表示从10到13的整数组成的向量。</p>
<p>用print()函数显示向量或在命令行中显示向量时， 每行显示的行首会有方括号和数字序号， 代表该行显示的第一个向量元素的下标。如</p>
<pre><code>&gt; 12345678901:12345678920

运行结果：
##  [1] 12345678901 12345678902 12345678903 12345678904 12345678905 12345678906
##  [7] 12345678907 12345678908 12345678909 12345678910 12345678911 12345678912
## [13] 12345678913 12345678914 12345678915 12345678916 12345678917 12345678918
## [19] 12345678919 12345678920</code></pre>
<p>length(x)可以求x的长度。 长度为零的向量表示为numeric(0)。 numeric()函数可以用来初始化一个指定元素个数而元素都等于零的数值型向量， 如numeric(10)会生成元素为10个零的向量。</p>
<pre><code>&gt; x &lt;- numeric(10)
&gt; x
## [1] 0 0 0 0 0 0 0 0 0 0</code></pre>
<h2 id="向量运算"><a href="#向量运算" class="headerlink" title="向量运算"></a>向量运算</h2><p>###标量和标量运算</p>
<p>单个数值称为标量， R没有单独的标量类型， 标量实际是长度为1的向量。</p>
<p>R中四则运算用+ - * / ^表示(加、减、乘、除、乘方)，如</p>
<pre><code>&gt; 1.5 + 2.3 - 0.6 + 2.1*1.2 - 1.5/0.5 + 2^3

## [1] 10.72</code></pre>
<p>R中四则运算仍遵从通常的优先级规则， 可以用圆括号()改变运算的先后次序。 如</p>
<pre><code>&gt; 1.5 + 2.3 - (0.6 + 2.1)*1.2 - 1.5/0.5 + 2^3
## [1] 5.56</code></pre>
<p>除了加、减、乘、除、乘方， R还支持整除运算和求余运算。 用%/%表示整除，用%%表示求余。如</p>
<pre><code>&gt; 5 %/% 3

## [1] 1


&gt; 5 %% 3
## [1] 2

&gt; 5.1 %/% 2.5
## [1] 2


&gt; 5.1 %% 2.5
## [1] 0.1</code></pre>
<p>向量与标量运算<br>向量与标量的运算为每个元素与标量的运算, 如</p>
<pre><code>&gt; x &lt;c(1, 10)
&gt; x + 2

## [1]  3 12


&gt; x - 2

## [1] -1  8



&gt; x * 2


## [1]  2 20


&gt; x / 2


## [1] 0.5 5.0


x ^ 2


## [1]   1 100


2 / x


## [1] 2.0 0.2



 2 ^ x


## [1]2 1024</code></pre>
<p>一个向量乘以一个标量， 就是线性代数中的数乘运算。</p>
<p>四则运算时如果有缺失值，缺失元素参加的运算相应结果元素仍缺失。 如</p>
<pre><code>&gt; c(1, NA, 3) + 10
## [1] 11 NA 13</code></pre>
<h3 id="等长向量运算"><a href="#等长向量运算" class="headerlink" title="等长向量运算"></a>等长向量运算</h3><p>等长向量的运算为对应元素两两运算。 如</p>
<pre><code>&gt; x1 &lt;- c(1, 10)
&gt; x2 &lt;- c(4, 2)
&gt; x1 + x2
## [1]  5 12
&gt; x1 - x2
## [1] -3  8
&gt; x1 * x2
## [1]  4 20
&gt; x1 / x2
## [1] 0.25 5.00</code></pre>
<p>两个等长向量的加、减运算就是线性代数中两个向量的加、减运算。</p>
<h3 id="不等长向量的运算"><a href="#不等长向量的运算" class="headerlink" title="不等长向量的运算"></a>不等长向量的运算</h3><p>两个不等长向量的四则运算， 如果其长度为倍数关系，规则是每次从头重复利用短的一个。 如</p>
<pre><code>&gt; x1 &lt;- c(10, 20)
&gt; x2 &lt;- c(1, 3, 5, 7)

&gt; x1 + x2
## [1] 11 23 15 27

&gt; x1 * x2
## [1]  10  60  50 140</code></pre>
<p>不仅是四则运算，R中有两个或多个向量按照元素一一对应参与某种运算或函数调用时， 如果向量长度不同，一般都采用这样的规则。</p>
<p>如果两个向量的长度不是倍数关系，会给出警告信息。如</p>
<pre><code>c(1,2) + c(1,2,3)

## Warning in c(1, 2) + c(1, 2, 3): 长的对象长度不是短的对象长度的整倍数
## [1] 2 4 4</code></pre>
<h2 id="向量函数"><a href="#向量函数" class="headerlink" title="向量函数"></a>向量函数</h2><h3 id="向量化的函数"><a href="#向量化的函数" class="headerlink" title="向量化的函数"></a>向量化的函数</h3><p>R中的函数一般都是向量化的: 在R中， 如果普通的一元函数以向量为自变量，一般会对每个元素计算。 这样的函数包括sqrt, log10, log, exp, sin, cos, tan等许多。 如</p>
<pre><code>&gt; sqrt(c(1, 4, 6.25))
## [1] 1.0 2.0 2.5</code></pre>
<p>为了查看这些基础的数学函数的列表，运行命令help.start()， 点击链接“Search Engine and Keywords”， 找到“Mathematics”栏目， 浏览其中的“arith”和“math”链接中的说明。 常用的数学函数有：</p>
<ul>
<li>舍入：ceiling, floor, round, signif, trunc, zapsmall</li>
<li>符号函数 sign</li>
<li>绝对值 abs</li>
<li>平方根 sqrt</li>
<li>对数与指数函数 log, exp, log10, log2</li>
<li>三角函数 sin, cos, tan</li>
<li>反三角函数 asin, acos, atan, atan2</li>
<li>双曲函数 sinh, cosh, tanh</li>
<li>反双曲函数 asinh, acosh, atanh</li>
</ul>
<p>有一些不太常用的数学函数：</p>
<ul>
<li>贝塔函数 beta, lbeta</li>
<li>伽玛函数 gamma, lgamma, digamma, trigamma, tetragamma, pentagamma</li>
<li>组合数 choose, lchoose</li>
<li>富利叶变换和卷积 fft, mvfft, convolve</li>
<li>正交多项式 poly</li>
<li>求根 polyroot, uniroot</li>
<li>最优化 optimize, optim</li>
<li>Bessel函数 besselI, besselK, besselJ, besselY</li>
<li>样条插值 spline, splinefun</li>
<li>简单的微分 deriv</li>
</ul>
<p>如果自己编写的函数没有考虑向量化问题， 可以用Vectorize()函数将其转换成向量化版本。</p>
<h2 id="排序函数"><a href="#排序函数" class="headerlink" title="排序函数"></a>排序函数</h2><p>sort(x)返回排序结果。 rev(x)返回把各元素排列次序反转后的结果。 order(x)返回排序用的下标。如</p>
<pre><code>&gt; x &lt;- c(33, 55, 11)

&gt; sort(x)
## [1] 11 33 55

&gt; rev(sort(x))
## [1] 55 33 11

&gt; order(x)
## [1] 3 1 2

&gt; x[order(x)]
## [1] 11 33 55</code></pre>
<p>例子中， order(x)结果中3是x的最小元素11所在的位置下标， 1是x的第二小元素33所在的位置下标， 2是x的最大元素55所在的位置下标。</p>
<h2 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h2><p>sum(求和), mean(求平均值), var(求样本方差), sd(求样本标准差), min(求最小值), max(求最大值), range(求最小值和最大值)等函数称为统计函数， 把输入向量看作样本，计算样本统计量。 prod求所有元素的乘积。</p>
<p>cumsum和cumprod计算累加和累乘积。如</p>
<pre><code>&gt; cumsum(1:5)
## [1]  1  3  6 10 15
&gt; cumprod(1:5)
## [1]   1   2   6  24 120</code></pre>
<p>其它一些类似函数有pmax, pmin, cummax, cummin等。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><strong>1. 显示1到100的整数的平方根和立方根（提示：立方根就是三分之一次方）。</strong></p>
<pre><code>计算平方根
&gt; sqrt(seq(1:100))
  [1]  1.000000  1.414214  1.732051  2.000000  2.236068  2.449490  2.645751  2.828427
  [9]  3.000000  3.162278  3.316625  3.464102  3.605551  3.741657  3.872983  4.000000
 [17]  4.123106  4.242641  4.358899  4.472136  4.582576  4.690416  4.795832  4.898979
 [25]  5.000000  5.099020  5.196152  5.291503  5.385165  5.477226  5.567764  5.656854
 [33]  5.744563  5.830952  5.916080  6.000000  6.082763  6.164414  6.244998  6.324555
 [41]  6.403124  6.480741  6.557439  6.633250  6.708204  6.782330  6.855655  6.928203
 [49]  7.000000  7.071068  7.141428  7.211103  7.280110  7.348469  7.416198  7.483315
 [57]  7.549834  7.615773  7.681146  7.745967  7.810250  7.874008  7.937254  8.000000
 [65]  8.062258  8.124038  8.185353  8.246211  8.306624  8.366600  8.426150  8.485281
 [73]  8.544004  8.602325  8.660254  8.717798  8.774964  8.831761  8.888194  8.944272
 [81]  9.000000  9.055385  9.110434  9.165151  9.219544  9.273618  9.327379  9.380832
 [89]  9.433981  9.486833  9.539392  9.591663  9.643651  9.695360  9.746794  9.797959
 [97]  9.848858  9.899495  9.949874 10.000000

#计算立方根
&gt; sqrtn &lt;- function(x,n) x^(1/n)
&gt; sqrtn(seq(1:100),3)
  [1] 1.000000 1.259921 1.442250 1.587401 1.709976 1.817121 1.912931 2.000000 2.080084
 [10] 2.154435 2.223980 2.289428 2.351335 2.410142 2.466212 2.519842 2.571282 2.620741
 [19] 2.668402 2.714418 2.758924 2.802039 2.843867 2.884499 2.924018 2.962496 3.000000
 [28] 3.036589 3.072317 3.107233 3.141381 3.174802 3.207534 3.239612 3.271066 3.301927
 [37] 3.332222 3.361975 3.391211 3.419952 3.448217 3.476027 3.503398 3.530348 3.556893
 [46] 3.583048 3.608826 3.634241 3.659306 3.684031 3.708430 3.732511 3.756286 3.779763
 [55] 3.802952 3.825862 3.848501 3.870877 3.892996 3.914868 3.936497 3.957892 3.979057
 [64] 4.000000 4.020726 4.041240 4.061548 4.081655 4.101566 4.121285 4.140818 4.160168
 [73] 4.179339 4.198336 4.217163 4.235824 4.254321 4.272659 4.290840 4.308869 4.326749
 [82] 4.344481 4.362071 4.379519 4.396830 4.414005 4.431048 4.447960 4.464745 4.481405
 [91] 4.497941 4.514357 4.530655 4.546836 4.562903 4.578857 4.594701 4.610436 4.626065
[100] 4.641589</code></pre>
<p><strong>2. 设有10个人的小测验成绩为:</strong></p>
<blockquote>
<p>77 60 91 73 85 82 83 100 66 75</p>
</blockquote>
<ol>
<li>把这10个成绩存入变量x;</li>
<li>从小到大排序；</li>
<li>计算order(x)，解释order(x)结果中第3项代表的意义。</li>
<li>计算这些成绩的平均值、标准差、最小值、最大值、中位数。</li>
<li>生成区间上等间隔的100个格子点存入变量x中。</li>
</ol>
<p>解答：</p>
<pre><code>    &gt; x &lt;- c(77,60,91,73,85,82,83,100,66,75)
    &gt; sort(x)
     [1]  60  66  73  75  77  82  83  85  91 100
    &gt; order(x)
     [1]  2  9  4 10  1  6  7  5  3  8
    #第三项为4，指代的是按从小到大排序的话排第三位的是之前排第4位的数字，即75
    &gt; mean(x)
    [1] 79.2
    &gt; sd(x)
    [1] 11.69805
    &gt; min(x)
    [1] 60
    &gt; max(x)
    [1] 100
    &gt; median(x)
    [1] 79.5
    #产生100个【0,1】之间的浮点数
    &gt; x &lt;- seq(0,1,length.out = 100)
    &gt; x
      [1] 0.00000000 0.01010101 0.02020202 0.03030303 0.04040404 0.05050505 0.06060606
      [8] 0.07070707 0.08080808 0.09090909 0.10101010 0.11111111 0.12121212 0.13131313
     [15] 0.14141414 0.15151515 0.16161616 0.17171717 0.18181818 0.19191919 0.20202020
     [22] 0.21212121 0.22222222 0.23232323 0.24242424 0.25252525 0.26262626 0.27272727
     [29] 0.28282828 0.29292929 0.30303030 0.31313131 0.32323232 0.33333333 0.34343434
     [36] 0.35353535 0.36363636 0.37373737 0.38383838 0.39393939 0.40404040 0.41414141
     [43] 0.42424242 0.43434343 0.44444444 0.45454545 0.46464646 0.47474747 0.48484848
     [50] 0.49494949 0.50505051 0.51515152 0.52525253 0.53535354 0.54545455 0.55555556
     [57] 0.56565657 0.57575758 0.58585859 0.59595960 0.60606061 0.61616162 0.62626263
     [64] 0.63636364 0.64646465 0.65656566 0.66666667 0.67676768 0.68686869 0.69696970
     [71] 0.70707071 0.71717172 0.72727273 0.73737374 0.74747475 0.75757576 0.76767677
     [78] 0.77777778 0.78787879 0.79797980 0.80808081 0.81818182 0.82828283 0.83838384
     [85] 0.84848485 0.85858586 0.86868687 0.87878788 0.88888889 0.89898990 0.90909091
     [92] 0.91919192 0.92929293 0.93939394 0.94949495 0.95959596 0.96969697 0.97979798
     [99] 0.98989899 1.00000000</code></pre>
]]></content>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>R向量下标和子集</title>
    <url>/2020/11/02/R%E5%90%91%E9%87%8F%E4%B8%8B%E6%A0%87%E5%92%8C%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<h2 id="正整数下标"><a href="#正整数下标" class="headerlink" title="正整数下标"></a>正整数下标</h2><p>对向量x, 在后面加方括号和下标可以访问向量的元素和子集。</p>
<p>设x &lt;- c(1, 4, 6.25)。 x[2]取出第二个元素； x[2] &lt;- 99修改第二个元素。 x[c(1,3)]取出第1、3号元素； x[c(1,3)] &lt;- c(11, 13)修改第1、3号元素。 下标可重复。 例如</p>
<pre><code>&gt; x &lt;- c(1, 4, 6.25)
&gt; x[2]
## [1] 4

&gt; x[2] &lt;- 99; x
## [1]  1.00 99.00  6.25

&gt; x[c(1,3)]
## [1] 1.00 6.25

&gt; x[c(1,3)] &lt;- c(11, 13); x
## [1] 11 99 13

&gt; x[c(1,3,1)]
## [1] 11 13 11</code></pre>
<h2 id="负整数下标"><a href="#负整数下标" class="headerlink" title="负整数下标"></a>负整数下标</h2><p>负下标表示扣除相应的元素后的子集，如</p>
<pre><code>&gt; x &lt;- c(1,4,6.25)
&gt; x[-2]
## [1] 1.00 6.25
&gt; x[-c(1,3)]
## [1] 4</code></pre>
<p>负整数下标不能与正整数下标同时用来从某一向量中取子集， 比如，x[c(1,-2)]没有意义。</p>
<h2 id="空下标与零下标"><a href="#空下标与零下标" class="headerlink" title="空下标与零下标"></a>空下标与零下标</h2><p>x[]表示取x的全部元素作为子集。 这与x本身不同，比如</p>
<pre><code>&gt; x &lt;- c(1,4,6.25)
&gt; x[] &lt;- 999
&gt; x
## [1] 999 999 999

&gt; x &lt;- c(1,4,6.25)
&gt; x &lt;- 999
&gt; x
## [1] 999</code></pre>
<p>x[0]是一种少见的做法， 结果返回类型相同、长度为零的向量， 如numeric(0)。 相当于空集。</p>
<p>当与正整数下标一起使用时会被忽略。 当0与负整数下标一起使用时也会被忽略。</p>
<h2 id="下标超界"><a href="#下标超界" class="headerlink" title="下标超界"></a>下标超界</h2><p>设向量x长度为, 则使用正整数下标时下标应在中取值。 如果使用大于的下标， 读取时返回缺失值，并不出错。 给超出的下标元素赋值， 则向量自动变长， 中间没有赋值的元素为缺失值。 例如</p>
<pre><code>&gt; x &lt;- c(1,4,6.25)
&gt; x[5]
## [1] NA

&gt; x
## [1] 1.00 4.00 6.25

&gt; x[5] &lt;- 9
&gt; x
## [1] 1.00 4.00 6.25   NA 9.00</code></pre>
<p>虽然R的语法对下标超界不视作错误， 但是这样的做法往往来自不良的程序思路， 而且对程序效率有影响， 所以实际编程中应避免下标超界。</p>
<h2 id="逻辑下标"><a href="#逻辑下标" class="headerlink" title="逻辑下标"></a>逻辑下标</h2><p>下标可以是与向量等长的逻辑表达式， 一般是关于本向量或者与本向量等长的其它向量的比较结果，如</p>
<pre><code>x &lt;- c(1,4,6.25)
x[x &gt; 3]
## [1] 4.00 6.25</code></pre>
<p>取出x的大于3的元素组成的子集。</p>
<p>要注意的是，如果逻辑下标中有缺失值， 对应结果也是缺失值。 所以，在用逻辑下标作子集选择时， 一定要考虑到缺失值问题。正确的做法是加上!is.na前提， 如</p>
<pre><code>&gt; x &lt;- c(1, 4, 6.25, NA)
&gt; x[x &gt; 2]
## [1] 4.00 6.25   NA

&gt; x[!is.na(x) &amp; x &gt; 2]
## [1] 4.00 6.25</code></pre>
<h2 id="which-、which-min-、which-max-函数"><a href="#which-、which-min-、which-max-函数" class="headerlink" title="which()、which.min()、which.max()函数"></a>which()、which.min()、which.max()函数</h2><p>函数<strong>which()**可以用来</strong>找到满足条件的下标**， 如</p>
<pre><code>&gt; x &lt;- c(3, 4, 3, 5, 7, 5, 9)
&gt; which(x &gt; 5)
## [1] 5 7

&gt; seq(along=x)[x &gt; 5]
## [1] 5 7</code></pre>
<p>这里seq(along=x)会生成由x的下标组成的向量。 用which.min()、which.max求最小值的下标和最大值的下标， 不唯一时只取第一个。如</p>
<pre><code>&gt; which.min(x)
## [1] 1

&gt; which.max(x)
## [1] 7</code></pre>
<h2 id="元素名"><a href="#元素名" class="headerlink" title="元素名"></a>元素名</h2><p>向量可以为每个元素命名。如</p>
<pre><code>&gt; ages &lt;- c(&quot;李明&quot;=25,&quot;田晓霞&quot;=21,&quot;孙少平&quot;=22)
&gt; ages
## 李明 田晓霞 孙少平 
    25     21     22</code></pre>
<p> 或者</p>
<pre><code>&gt; ages &lt;- c(25,21,22)
&gt; names(ages)&lt;- c(&quot;李明&quot;,&quot;田晓霞&quot;,&quot;孙少平&quot;)
&gt; ages
## 李明 田晓霞 孙少平 
    25     21     22 </code></pre>
<p>或者</p>
<pre><code>&gt; ages &lt;- setNames(c(25,21,22),c(&quot;李明&quot;,&quot;田晓霞&quot;,&quot;孙少平&quot;))
&gt; ages
## 李明 田晓霞 孙少平 
    25     21     22 </code></pre>
<p>这时可以用元素名或元素名向量作为向量的下标，如</p>
<pre><code>&gt; ages[&quot;李明&quot;]
## 李明 
  25

&gt; ages[&quot;李明&quot;] &lt;- 11
&gt; ages
## 李明 田晓霞 孙少平 
    11     21     22 </code></pre>
<p>这实际上建立了字符串到数值的映射表。</p>
<p>用字符串作为下标时， 如果该字符串不在向量的元素名中， 读取时返回缺失值结果， 赋值时该向量会增加一个元素并以该字符串为元素名。</p>
<p>带有元素名的向量也可以是字符型或其它基本类型，如</p>
<pre><code>&gt; sex &lt;- c(&quot;孙少平&quot;=&quot;男&quot;,&quot;田晓霞&quot;=&quot;女&quot;)
&gt; sex
## 孙少平 田晓霞 
  &quot;男&quot;   &quot;女&quot; </code></pre>
<p>除了给向量元素命名外， 在矩阵和数据框中还可以给行、列命名， 这会使得程序的扩展更为容易和安全。</p>
<p>R允许仅给部分元素命名， 这时其它元素名字为空字符串。 不同元素的元素名一般应该是不同的， 否则在使用元素作为下标时会发生误读， 但是R语法允许存在重名。</p>
<p>用unname(x)返回去掉了元素名的x的副本， 用names(x) &lt;- NULL可以去掉x的元素</p>
<pre><code>&gt; unname(ages)
## [1] 11 21 22

&gt; ages
## 李明 田晓霞 孙少平 
    11     21     22 

&gt; names(ages) &lt;- NULL
&gt; ages
## [1] 11 21 22</code></pre>
<h2 id="用R向量下标作映射"><a href="#用R向量下标作映射" class="headerlink" title="用R向量下标作映射"></a>用R向量下标作映射</h2><p>R在使用整数作为向量下标时，允许使用重复下标， 这样可以把数组x看成一个的整数到 x[1], x[2], , x[n]的一个映射表, 其中是x的长度。 比如，某商店有三种礼品，编号为1,2,3， 价格分别为68, 88和168。令</p>
<pre><code>&gt; price.map &lt;- c(68, 88, 168)</code></pre>
<p>设某个收银员在一天内分别售出礼品编号为3,2,1,1,2,2,3， 可以用如下的映射方式获得售出的这些礼品对应的价格：</p>
<pre><code>&gt; items &lt;- c(3,2,1,1,2,2,3)
&gt; y &lt;- price.map[items]; print(y)
## [1] 168  88  68  68  88  88 168</code></pre>
<p>R向量可以用字符型向量作下标， 字符型下标也允许重复， 所以可以把带有元素名的R向量看成是元素名到元素值的映射表。 比如，设sex为10个学生的性别（男、女）</p>
<pre><code>&gt; sex &lt;- c(&quot;男&quot;, &quot;男&quot;, &quot;女&quot;, &quot;女&quot;, &quot;男&quot;, &quot;女&quot;, &quot;女&quot;, &quot;女&quot;, &quot;女&quot;, &quot;男&quot;)</code></pre>
<p>希望把每个学生按照性别分别对应到蓝色和红色。 首先建立一个R向量当作映射</p>
<pre><code>&gt; sex.color &lt;- c(&quot;男&quot;=&quot;blue&quot;, &quot;女&quot;=&quot;red&quot;)</code></pre>
<p>用R向量sex.color当作映射，可以获得每个学生对应的颜色</p>
<pre><code>&gt; cols &lt;- sex.color[sex]; print(cols)
##     男     男     女     女     男     女     女     女     女     男 
## &quot;blue&quot; &quot;blue&quot;  &quot;red&quot;  &quot;red&quot; &quot;blue&quot;  &quot;red&quot;  &quot;red&quot;  &quot;red&quot;  &quot;red&quot; &quot;blue&quot;</code></pre>
<p>这样的映射结果中带有不必要的元素名， 用unname()函数可以去掉元素名，如</p>
<pre><code>&gt; unname(cols)
##  [1] &quot;blue&quot; &quot;blue&quot; &quot;red&quot;  &quot;red&quot;  &quot;blue&quot; &quot;red&quot;  &quot;red&quot;  &quot;red&quot;  &quot;red&quot;  &quot;blue&quot;</code></pre>
<h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><p>可以把向量x看成一个集合，但是其中的元素允许有重复。 用unique(x)可以获得x的所有不同值。如</p>
<pre><code>&gt; unique(c(1, 5, 2, 5))
## [1] 1 5 2</code></pre>
<p>用a %in% x判断a的每个元素是否属于向量x，如</p>
<pre><code>&gt; 5 %in% c(1,5,2)
## [1] TRUE

&gt; c(5,6) %in% c(1,5,2)
## [1]  TRUE FALSE</code></pre>
<p>与%in运算符类似， 函数match(x, table)对向量x的每个元素， 从向量table中查找其首次出现位置并返回这些位置。 没有匹配到的元素位置返回NA_integer_(整数型缺失值)。 如</p>
<pre><code>&gt; match(5, c(1,5,2))
## [1] 2

&gt; match(5, c(1,5,2,5))
## [1] 2

&gt; match(c(2,5), c(1,5,2,5))
## [1] 3 2

&gt; match(c(2,5,0), c(1,5,2,5))
## [1]  3  2 NA</code></pre>
<p>用intersect(x,y)求交集，结果中不含重复元素，如</p>
<pre><code>&gt; intersect(c(5, 7), c(1, 5, 2, 5))
## [1] 5</code></pre>
<p>用union(x,y)求并集，结果中不含重复元素，如</p>
<pre><code>&gt; union(c(5, 7), c(1, 5, 2, 5))
## [1] 5 7 1 2</code></pre>
<p>用setdiff(x,y)求差集，即x的元素中不属于y的元素组成的集合， 结果中不含重复元素，如</p>
<pre><code>&gt; setdiff(c(5, 7), c(1, 5, 2, 5))
## [1] 7</code></pre>
<p>用setequal(x,y)判断两个集合是否相等， 不受次序与重复元素的影响，如</p>
<pre><code>&gt; setequal(c(1,5,2), c(2,5,1))
## [1] TRUE

&gt; setequal(c(1,5,2), c(2,5,1,5))
## [1] TRUE</code></pre>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>设文件class.csv内容如下:</p>
<p>name,sex,age,height,weight<br>Alice,F,13,56.5,84<br>Becka,F,13,65.3,98<br>Gail,F,14,64.3,90<br>Karen,F,12,56.3,77<br>Kathy,F,12,59.8,84.5<br>Mary,F,15,66.5,112<br>Sandy,F,11,51.3,50.5<br>Sharon,F,15,62.5,112.5<br>Tammy,F,14,62.8,102.5<br>Alfred,M,14,69,112.5<br>Duke,M,14,63.5,102.5<br>Guido,M,15,67,133<br>James,M,12,57.3,83<br>Jeffrey,M,13,62.5,84<br>John,M,12,59,99.5<br>Philip,M,16,72,150<br>Robert,M,12,64.8,128<br>Thomas,M,11,57.5,85<br>William,M,15,66.5,112</p>
<p>用如下程序可以把上述文件读入为R数据框d.class, 并取出其中的name和age列到变量name和age中：</p>
<pre><code>&gt; d.class &lt;- read.csv(&quot;class.csv&quot;, header=TRUE, stringsAsFactors=FALSE)
&gt; name &lt;- d.class[,&quot;name&quot;]
&gt; age &lt;- d.class[,&quot;age&quot;]
&gt; age
 [1] 13 13 14 12 12 15 11 15 14 14 14 15 12 13 12 16 12 11 15
&gt; d.class
      name sex age height weight
1    Alice   F  13   56.5   84.0
2    Becka   F  13   65.3   98.0
3     Gail   F  14   64.3   90.0
4    Karen   F  12   56.3   77.0
5    Kathy   F  12   59.8   84.5
6     Mary   F  15   66.5  112.0
7    Sandy   F  11   51.3   50.5
8   Sharon   F  15   62.5  112.5
9    Tammy   F  14   62.8  102.5
10  Alfred   M  14   69.0  112.5
11    Duke   M  14   63.5  102.5
12   Guido   M  15   67.0  133.0
13   James   M  12   57.3   83.0
14 Jeffrey   M  13   62.5   84.0
15    John   M  12   59.0   99.5
16  Philip   M  16   72.0  150.0
17  Robert   M  12   64.8  128.0
18  Thomas   M  11   57.5   85.0
19 William   M  15   66.5  112.0</code></pre>
<ol>
<li><p>求出age中第3, 5, 7号的值；</p>
<pre><code> &gt; age[c(3,5,7)]
 ## [1] 14 12 11</code></pre>
</li>
<li><p>用变量age, 求出达到15岁及以上的那些值；</p>
<pre><code> &gt; age[age&gt;=15]
 ## [1] 15 15 15 16 15 </code></pre>
</li>
<li><p>用变量name和age, 求出Mary与James的年龄。</p>
<pre><code> &gt; set &lt;- setNames(age,name)
 &gt; set[match(c(&quot;Mary&quot;,&quot;James&quot;),name)]
  Mary James 
    15    12 </code></pre>
</li>
<li><p>求age中除Mary与James这两人之外的那些人的年龄值，保存到变量age1中。</p>
</li>
</ol>
<pre><code>    &gt; a &lt;- match(c(&quot;Mary&quot;,&quot;James&quot;),name)
    &gt; b &lt;- (1:length(name))

    &gt; a
    [1]  6 13
    &gt; b
     [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19

    &gt; age1 &lt;- set[setdiff(b,a)]
    &gt; age1
      Alice   Becka    Gail   Karen   Kathy   Sandy  Sharon   Tammy  Alfred    Duke   Guido 
         13      13      14      12      12      11      15      14      14      14      15 
    Jeffrey    John  Philip  Robert  Thomas William 
         13      12      16      12      11      15 </code></pre>
]]></content>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>R因子类型</title>
    <url>/2020/11/09/R%E5%9B%A0%E5%AD%90%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="R因子类型"><a href="#R因子类型" class="headerlink" title="R因子类型"></a>R因子类型</h2><h3 id="因子"><a href="#因子" class="headerlink" title="因子"></a>因子</h3><p>R中用<strong>因子代表数据中分类变量</strong>, 如性别、省份、职业。 有序因子代表有序量度，如打分结果，疾病严重程度等。</p>
<p>用factor()函数把字符型向量转换成因子，如</p>
<pre><code>&gt; x &lt;- c(&quot;男&quot;,&quot;女&quot;,&quot;女&quot;,&quot;男&quot;)
&gt; sex &lt;- factor(x)
&gt; sex
[1] 男 女 女 男
Levels: 男 女</code></pre>
<p>因子有class属性，取值为”factor”</p>
<pre><code>&gt; attributes(sex)
$levels
[1] &quot;男&quot; &quot;女&quot;

$class
[1] &quot;factor&quot;</code></pre>
<p>还有一个levels(水平值)属性， 此属性可以用levels()函数访问，如</p>
<pre><code>&gt; levels(sex)
[1] &quot;男&quot; &quot;女&quot;</code></pre>
<p>因子的levels属性可以看成是一个映射， 把整数值1,2,映射成这些水平值， 因子在保存时会保存成整数值1,2,等与水平值对应的编号。 这样可以节省存储空间， 在建模计算的程序中也比较有利于进行数学运算。</p>
<p>事实上， <strong>read.csv()**函数的默认操作会把输入文件的字符型列</strong>自动转换成因子**,这对于性别、职业、地名这样的列是合适的， 但是对于姓名、日期、详细地址这样的列则不合适。</p>
<p>所以，在read.csv()调用中经常加选项<strong>stringsAsFactors=FALSE</strong>选项禁止这样的自动转换，还可以用colClasses选项逐个指定每列的类型。</p>
<p>用**as.numeric()**可以把因子转换为纯粹的整数值，如</p>
<pre><code>&gt; as.numeric(sex)
[1] 1 2 2 1</code></pre>
<p>因为因子实际保存为整数值， 所以对因子进行一些字符型操作可能导致错误。 用as.character()可以把因子转换成原来的字符型，如</p>
<pre><code>&gt; as.character(sex)
[1] &quot;男&quot; &quot;女&quot; &quot;女&quot; &quot;男&quot;</code></pre>
<p>为了对因子执行字符型操作（如取子串）， 保险的做法是先用as.character()函数强制转换为字符型。</p>
<ul>
<li>factor()函数的一般形式为</li>
</ul>
<pre><code>    factor(x, levels = sort(unique(x), na.last = TRUE), 
           labels, exclude = NA, ordered = FALSE)</code></pre>
<p>可以用选项labels指定各水平的标签, 不指定时用各水平值的对应字符串。ordered取真值时表示因子水平是有次序的(按编码次序)。</p>
<p>在使用factor()函数定义因子时，如果知道自变量元素的所有可能取值，应尽可能使用levels=参数指定这些不同可能取值，这样，即使某个取值没有出现，此变量代表的含义和频数信息也是完整的。 自己指定levels=的另一好处是可以按正确的次序显示因子的分类统计值。</p>
<p>因为一个因子的levels属性是该因子独有的， 所以合并两个因子有可能造成错误。如</p>
<pre><code>&gt; li1 &lt;- factor(c(&#39;男&#39;, &#39;女&#39;))
&gt; li2 &lt;- factor(c(&#39;男&#39;, &#39;男&#39;))
&gt; c(li1, li2)
[1] 1 2 1 1</code></pre>
<p>结果不再是因子。 正确的做法是</p>
<pre><code>&gt; factor(c(as.character(li1), as.character(li2)))
[1] 男 女 男 男
Levels: 男 女</code></pre>
<p>即恢复成字符型后合并， 然后再转换为因子。 在合并两个数据框时也存在这样的问题。 当然，如果在定义li1和li2 时都用了levels=c(‘男’, ‘女’)选项， c(li1, li2)也能给出正确结果。</p>
<h2 id="tapply-函数"><a href="#tapply-函数" class="headerlink" title="tapply()函数"></a>tapply()函数</h2><p>可以按照因子分组然后每组计算另一变量的概括统计。 如</p>
<pre><code>&gt; h &lt;- c(165, 170, 168, 172)
&gt; tapply(h,sex,mean)
   男    女 
168.5 169.0 </code></pre>
<p>这里第一自变量h与与第二自变量sex是等长的， 对应元素分别为同一人的身高和性别， tapply()函数分男女两组计算了身高平均值。</p>
<h2 id="forcats包的因子函数"><a href="#forcats包的因子函数" class="headerlink" title="forcats包的因子函数"></a>forcats包的因子函数</h2><pre><code>&gt; library(forcats)</code></pre>
<p>在分类变量类数较多时，往往需要对因子水平另外排序、合并等， forcats包提供了一些针对因子的方便函数。</p>
<p>forcats::fct_reorder()可以根据不同因子水平分成的组中另一数值型变量的统计量值排序。 如：</p>
<pre><code>&gt; library(forcats)
&gt; set.seed(1)
&gt; fac &lt;- sample(c(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;),size = 30,replace = T)
&gt; fac
 [1] &quot;red&quot;   &quot;green&quot; &quot;blue&quot;  &quot;green&quot; &quot;blue&quot;  &quot;blue&quot; 
 [7] &quot;green&quot; &quot;blue&quot;  &quot;red&quot;   &quot;green&quot; &quot;red&quot;   &quot;red&quot;  
[13] &quot;red&quot;   &quot;red&quot;   &quot;red&quot;   &quot;red&quot;   &quot;green&quot; &quot;green&quot;
[19] &quot;red&quot;   &quot;green&quot; &quot;blue&quot;  &quot;green&quot; &quot;blue&quot;  &quot;green&quot;
[25] &quot;blue&quot;  &quot;red&quot;   &quot;blue&quot;  &quot;blue&quot;  &quot;green&quot; &quot;blue&quot; </code></pre>
<p>用 attribute() 函数查看此时fac的属性</p>
<pre><code>&gt; attributes(fac)
NULL</code></pre>
<p>显示，此时fac 并不是一个factor,利用factor函数对fac进行转化为factor</p>
<pre><code>&gt; fac &lt;- factor(x = fac,labels = c(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;))
&gt; attributes(fac)
$levels
[1] &quot;red&quot;   &quot;green&quot; &quot;blue&quot; 

$class
[1] &quot;factor&quot;</code></pre>
<p>转化完成之后，用rt()函数生成服从T分布生成伪随机数，并赋值给x</p>
<pre><code>&gt; x &lt;- round(100*(10+rt(30,2)))
&gt; res1 &lt;- tapply(x, fac, sd)
&gt; res1
##       red     green      blue 
##  370.9222  138.3185 1129.2587

&gt; barplot(res1)</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/prog-type-fact_files/figure-html/prog-type-fact22-1.png"></p>
<p>如果希望按照统计量次序对因子排序， 可以用forcats::fct_reorder()函数， 如</p>
<pre><code>&gt; fac2 &lt;- fct_reorder(fac,x,sd)
&gt; res2 &lt;- tapply(X = x,INDEX = fac2,FUN = sd)
&gt; barplot(res2)</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/prog-type-fact_files/figure-html/prog-type-fact23-1.png"></p>
<p>新的因子fac2的因子水平次序已经按照变量x的标准差从小到大排列。</p>
<p>有时在因子水平数较多时仅想将特定的一个或几个水平次序放到因子水平最前面， 可以用forcats::fct_relevel()函数， 如：</p>
<pre><code>&gt; fac3 &lt;- fct_relevel(fac,&quot;blue&quot;)

&gt; levels(fac3)
[1] &quot;blue&quot;  &quot;red&quot;   &quot;green&quot;</code></pre>
<p>fct_relevel()第一个参数是要修改次序的因子， 后续可以有多个字符型参数表示要提前的水平。</p>
<p>forcats::fct_recode()可以修改每个水平的名称， 如：</p>
<pre><code>&gt; fac4 &lt;- fct_recode(fac,&quot;红&quot;=&quot;red&quot;,&quot;蓝&quot;=&quot;blue&quot;,&quot;绿&quot;=&quot;green&quot;)
&gt; attributes(fac4)
$levels
[1] &quot;红&quot; &quot;绿&quot; &quot;蓝&quot;

$class
[1] &quot;factor&quot;</code></pre>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>设文件<a href="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/class.csv">class.csv</a>中包含如下内容:</p>
<pre><code>name,sex,age,height,weight
Alice,F,13,56.5,84
Becka,F,13,65.3,98
Gail,F,14,64.3,90
Karen,F,12,56.3,77
Kathy,F,12,59.8,84.5
Mary,F,15,66.5,112
Sandy,F,11,51.3,50.5
Sharon,F,15,62.5,112.5
Tammy,F,14,62.8,102.5
Alfred,M,14,69,112.5
Duke,M,14,63.5,102.5
Guido,M,15,67,133
James,M,12,57.3,83
Jeffrey,M,13,62.5,84
John,M,12,59,99.5
Philip,M,16,72,150
Robert,M,12,64.8,128
Thomas,M,11,57.5,85
William,M,15,66.5,112</code></pre>
<p>用如下程序把该文件读入为R数据框d.class, 其中的sex列已经自动转换为因子。 取出其中的sex和age列到变量sex和age中</p>
<pre><code>&gt; d.class &lt;- read.csv(&#39;class.csv&#39;, header=TRUE)
&gt; sex &lt;- d.class[,&#39;sex&#39;]
&gt; age &lt;- d.class[,&#39;age&#39;]</code></pre>
<ol>
<li><p>统计并显示列出sex的不同值频数；</p>
</li>
<li><p>分男女两组分别求年龄最大值；</p>
</li>
<li><p>把sex变量转换为一个新的因子，F显示成“Female”，M显示成“Male”。</p>
</li>
</ol>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>1.</p>
<pre><code>&gt; table(sex)
sex
 F  M 
 9 10 </code></pre>
<p>2.</p>
<pre><code>&gt; tapply(age, sex, max)
 F  M 
15 16 </code></pre>
<p>3.</p>
<pre><code>&gt; sex
 [1] F F F F F F F F F M M M M M M M M M M
Levels: F M
&gt; sex2 &lt;- fct_recode(sex,&quot;Female&quot;=&quot;F&quot;,&quot;Male&quot;=&quot;M&quot;)
&gt; sex2
 [1] Female Female Female Female Female Female Female
 [8] Female Female Male   Male   Male   Male   Male  
[15] Male   Male   Male   Male   Male  
Levels: Female Male</code></pre>
]]></content>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>R输入输出</title>
    <url>/2020/11/18/R%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h2 id="输入输出的简单方法"><a href="#输入输出的简单方法" class="headerlink" title="输入输出的简单方法"></a>输入输出的简单方法</h2><h3 id="简单的输出"><a href="#简单的输出" class="headerlink" title="简单的输出"></a>简单的输出</h3><p>用print()函数显示某个变量或表达式的值， 如</p>
<pre><code>&gt; x &lt;- 1.234
&gt; print(x)
## [1] 1.234

&gt; y &lt;- c(1,3,5)
&gt; print(y[2:3])
## [1] 3 5</code></pre>
<p>在命令行使用R时， 直接以变量名或表达式作为命令可以起到用print()函数显示的相同效果。</p>
<p><strong>用cat()函数把字符串、变量、表达式连接起来显示</strong>， 其中变量和表达式的类型一般是标量或向量，不能是矩阵、列表等复杂数据。 如</p>
<pre><code>&gt; cat(&quot;x =&quot;, x, &quot;\n&quot;)
x = 1.234</code></pre>
<p>注意cat()显示中需要换行需要在自变量中包含字符串”\n”， 即换行符。</p>
<p>cat()默认显示在命令行窗口， 为了写入指定文件中， 在cat()调用中用file=选项， 这时如果已有文件会把原有内容覆盖， 为了在已有文件时不覆盖原有内容而是在末尾添加， 在cat()中使用append=TRUE选项。 如:</p>
<pre><code>&gt; cat(&quot;=== 结果文件 ===\n&quot;, file=&quot;res.txt&quot;)
&gt; cat(&quot;x =&quot;, x, &quot;\n&quot;, file=&quot;res.txt&quot;, append=TRUE)</code></pre>
<p>R命令行环境中定义的变量、函数会保存在工作空间中，并在退出R会话时可以保存到硬盘文件中。 用save()命令要求把指定的若干个变量（直接用名字，不需要表示成字符串）保存到用file=指定的文件中， 随后可以用load()命令恢复到工作空间中。</p>
<p>虽然允许保存多个变量到同一文件中， 但尽可能仅保存一个变量， 而且使用变量名作为文件名。 用save()保存的R特殊格式的文件是通用的， 不依赖于硬件和操作系统。 如</p>
<pre><code>&gt; save(scores, file=&quot;scores.RData&quot;)
&gt; load(&quot;scores.RData&quot;)</code></pre>
<p>保存多个变量，如x, zeta，命令如：</p>
<pre><code>save(x, zeta, file=&quot;myvars20200315.RData&quot;)</code></pre>
<p>或</p>
<pre><code>save(list = c(&quot;x&quot;, &quot;zeta&quot;), file=&quot;myvars20200315.RData&quot;)</code></pre>
<p>对于一个数据框， 可以用**write.csv()或readr::write_csv()**将其保存为逗号分隔的文本文件， 这样的文件可以很容易地被其它软件识别访问， 如Microsoft Excel软件可以很容易地把这样的文件读成电子表格。 用如</p>
<pre><code>&gt; library(tidyverse)
&gt; da &lt;- tibble(&quot;name&quot;=c(&quot;李明&quot;, &quot;刘颖&quot;, &quot;张浩&quot;),
+              &quot;age&quot;=c(15, 17, 16))
&gt; da
# A tibble: 3 x 2
  name    age
  &lt;chr&gt; &lt;dbl&gt;
1 李明     15
2 刘颖     17
3 张浩     16
&gt; write_csv(da,&quot;mydata.csv&quot;)</code></pre>
<p>结果生成的mydata.csv文件内容如下：</p>
<pre><code>name,age
李明,15
刘颖,17
张浩,16</code></pre>
<p>但是，在Microsoft的中文版Windows操作系统中， 默认编码是GB编码， 用write_csv()生成的CSV文件总是使用UTF-8编码， 系统中的MS Office 软件不能自动识别这样编码的CSV文件， 可以改用write_csv_excel()函数； 基本R的write.csv()函数不存在这个问题。</p>
<h2 id="CSV格式"><a href="#CSV格式" class="headerlink" title="CSV格式"></a>CSV格式</h2><p>对于保存在文本文件中的电子表格数据， R可以用read.csv(), read.table(), read.delim(), read.fwf()等函数读入, 但是建议在readr包的支持下用**read_csv(), read_table2(), read_delim(), read_fwf()**等函数读入， 这些将读入的数据框保存为tibble类型， tibble是数据框的一个变种， 改善了数据框的一些不适当的设计。 readr的读入速度比基本R软件的read.csv()等函数的速度快得多， 速度可以相差10倍， 也不自动将字符型列转换成因子， 不自动修改变量名为合法变量名， 不设置行名。</p>
<p>对于中小规模的数据， CSV格式作为文件交换格式比较合适， 兼容性强， 各种数据管理软件与统计软件都可以很容易地读入和生成这样格式的文件， 但是特别大型的数据读入效率很低。</p>
<p>CSV格式的文件用逗号分隔开同一行的数据项， 一般第一行是各列的列名（变量名）。 对于数值型数据， 只要表示成数值常量形式即可。 对于字符型数据， 可以用双撇号包围起来， 也可以不用撇号包围。 但是， 如果数据项本身包含逗号， 就需要用双撇号包围。 例如，下面是一个名为testcsv.csv的文件内容， 其中演示了内容中有逗号、有双撇号的情况。</p>
<pre><code>id,words
1,&quot;PhD&quot;
2,Master&#39;s degree 
3,&quot;Bond,James&quot;
4,&quot;A &quot;&quot;special&quot;&quot; gift&quot;</code></pre>
<p>为读入上面的内容，只要用如下程序:</p>
<pre><code>&gt; d &lt;- read_csv(&quot;testcsv.csv&quot;)</code></pre>
<p>读入的数据框显示如下:</p>
<pre><code># A tibble: 4 × 2
     id            words
  &lt;int&gt;            &lt;chr&gt;
1     1              PhD
2     2  Master&#39;s degree
3     3       Bond,James
4     4 A &quot;special&quot; gift</code></pre>
<h2 id="从字符串读入"><a href="#从字符串读入" class="headerlink" title="从字符串读入"></a>从字符串读入</h2><p>read_csv()还可以从字符串读入一个数据框，如</p>
<pre><code>&gt; d.small &lt;- read_csv(&quot;name,x,y
John, 33, 95
Kim, 21, 64
Sandy, 49, 100
&quot;)

&gt; d.small

## # A tibble: 3 x 3
##   name      x     y
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 John     33    95
## 2 Kim      21    64
## 3 Sandy    49   100</code></pre>
<h2 id="read-csv选项"><a href="#read-csv选项" class="headerlink" title="read_csv选项"></a>read_csv选项</h2><p>read_csv()的skip=选项跳过开头的若干行。 当数据不包含列名时， 只要指定col_names=FALSE， 变量将自动命名为X1, X2, …， 也可以用col_names=指定各列的名字，如</p>
<pre><code>&gt; d.small &lt;- read_csv(&quot;John, 33, 95
Kim, 21, 64
Sandy, 49, 100
&quot;, col_names=c(&quot;name&quot;, &quot;x&quot;, &quot;y&quot;) )

&gt; d.small
## # A tibble: 3 x 3
##   name      x     y
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 John     33    95
## 2 Kim      21    64
## 3 Sandy    49   100</code></pre>
<h2 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a>文件访问</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>输入输出可以针对命令行，针对文件，R支持扩展的文件类型， 称为“连接(connection)”。</p>
<p>函数file()生成到一个普通文件的连接， 函数url()生成一个到指定的URL的连接， 函数gzfile, bzfile, xzfile, unz支持对 压缩过的文件的访问（不是压缩包，只对一个文件压缩）。这些函数大概的用法如下：</p>
<pre><code>file(&quot;path&quot;, open=&quot;&quot;, blocking=T,
     encoding = getOption(&quot;encoding&quot;), 
     raw = FALSE)

url(description, open = &quot;&quot;, blocking = TRUE,
    encoding = getOption(&quot;encoding&quot;))

textConnection(description, open=&quot;r&quot;, 
    local = FALSE,
    encoding = c(&quot;&quot;, &quot;bytes&quot;, &quot;UTF-8&quot;))

gzfile(description, open = &quot;&quot;, 
       encoding = getOption(&quot;encoding&quot;),
       compression = 6)

bzfile(description, open = &quot;&quot;, 
       encoding = getOption(&quot;encoding&quot;),
       compression = 9)

xzfile(description, open = &quot;&quot;, 
       encoding = getOption(&quot;encoding&quot;),
       compression = 6)

unz(description, filename, open = &quot;&quot;,
    encoding = getOption(&quot;encoding&quot;))</code></pre>
<p>生成连接的函数不自动打开连接。 给定一个未打开的连接， 读取函数从中读取时会自动打开连接， 函数结束时自动关闭连接。 用open()函数打开连接，返回一个句柄； 生成连接时可以用open参数要求打开连接。 要多次从一个连接读取时就应该先打开连接， 读取完毕用close函数关闭。</p>
<p>函数textConnection()打开一个字符串用于读写。</p>
<p>在生成连接与打开连接的函数中用open参数指定打开方式， 取值为：</p>
<ul>
<li>r—文本型只读;</li>
<li>w—文本型只写;</li>
<li>a—文本型末尾添加;</li>
<li>rb—二进制只读;</li>
<li>wb—二进制只写;</li>
<li>ab—二进制末尾添加;</li>
<li>r+或r+b—允许读和写;</li>
<li>w+或w+b—允许读和写，但刚打开时清空文件;</li>
<li>a+或a+b—末尾添加并允许读。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>列表</title>
    <url>/2020/11/11/%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>R中列表(list)类型来保存<strong>不同类型</strong>的数据。 一个主要目的是提供R分析结果输出包装： 输出一个变量， 这个变量包括回归系数、预测值、残差、检验结果等等一系列不能放到规则形状数据结构中的内容。 实际上，数据框也是列表的一种， 但是<u>数据框要求各列等长， 而列表不要求</u>。</p>
<p>列表可以有多个元素， 但是与向量不同的是， 列表的不同元素的类型可以不同， 比如， 一个元素是数值型向量， 一个元素是字符串， 一个元素是标量， 一个元素是另一个列表。</p>
<p>定义列表用函数list(), 如</p>
<pre><code>&gt; rec &lt;- list(name=&quot;李明&quot;, age=30,
+scores=c(85, 76, 90))
&gt; rec</code></pre>
<p><br>执行结果：</p>
<pre><code>$name
[1] &quot;李明&quot;

$age
[1] 30

$scores
[1] 85 76 90</code></pre>
<p>用typeof()函数判断一个列表， 返回结果为list。 可以用is.list()函数判断某个对象是否列表类型。</p>
<pre><code>&gt; typeof(rec)


[1] &quot;list&quot;</code></pre>
<h2 id="列表元素访问"><a href="#列表元素访问" class="headerlink" title="列表元素访问"></a>列表元素访问</h2><p>列表的一个元素也可以称为列表的一个“变量”， 单个列表元素必须用两重方括号格式访问，如</p>
<pre><code>&gt; rec[[3]][2]
[1] 76

&gt; rec[[&quot;age&quot;]]
[1] 30
&gt; rec[[&quot;scores&quot;]]
[1] 85 76 90</code></pre>
<p>列表的单个元素也可以用$格式访问，如</p>
<pre><code>&gt; rec$age
[1] 30</code></pre>
<p>如果使用单重方括号对列表取子集， 结果还是列表而不是列表元素，如</p>
<pre><code>&gt; rec[3]
$scores
[1] 85 76 90

&gt; typeof(rec[3])
[1] &quot;list&quot;</code></pre>
<p>列表一般都应该有元素名， 元素名可以看成是变量名， 列表中的每个元素看成一个变量。 用names()函数查看和修改元素名。 如</p>
<pre><code>&gt; names(rec)
[1] &quot;name&quot;   &quot;age&quot;    &quot;scores&quot;

&gt; typeof(names(rec))
[1] &quot;character&quot;

&gt; names(rec)[names(rec)==&quot;scores&quot;] &lt;- &quot;三科分数&quot;
&gt; names(rec)
[1] &quot;name&quot;     &quot;age&quot;      &quot;三科分数&quot;

&gt; rec[[&quot;三科分数&quot;]]
[1] 85 76 90</code></pre>
<p>可以修改列表元素内容。 如</p>
<pre><code>&gt; rec$三科分数[2] &lt;- 0
&gt; rec
$name
[1] &quot;李明&quot;

$age
[1] 30

$三科分数
[1] 85  0 90</code></pre>
<p>直接给列表<strong>不存在的元素名定义元素值就添加了新元素</strong>， 而且不同于使用向量，对于列表而言这是很正常的做法，比如</p>
<pre><code>&gt; rec[&quot;身高&quot;] &lt;- 183
&gt; rec
$name
[1] &quot;李明&quot;

$age
[1] 30

$三科分数
[1] 85  0 90

$身高
[1] 183</code></pre>
<p>把某个列表元素赋值为NULL就删掉这个元素。 如</p>
<pre><code>&gt; rec$三科分数 &lt;- NULL
&gt; rec
$name
[1] &quot;李明&quot;

$age
[1] 30

$身高
[1] 183</code></pre>
<p>在list()函数中允许定义元素为NULL，这样的元素是存在的，如：</p>
<pre><code>&gt; li &lt;- list(a=120, b=&quot;F&quot;, c=NULL)
&gt; li
$a
[1] 120

$b
[1] &quot;F&quot;

$c
NULL</code></pre>
<p>但是，要把已经存在的元素修改为NULL值而不是删除此元素， 或者给列表增加一个取值为NULL的元素， 这时需要用单重的方括号取子集， 这样的子集会保持其列表类型， 给这样的子列表赋值为list(NULL)，如：</p>
<pre><code>&gt; li[&quot;b&quot;] &lt;- list(NULL)
&gt; li
$a
[1] 120

$b
NULL

$c
NULL</code></pre>
<h2 id="列表类型转换"><a href="#列表类型转换" class="headerlink" title="列表类型转换"></a>列表类型转换</h2><p>用as.list()把一个其它类型的对象转换成列表； 如</p>
<pre><code>&gt; li1 &lt;- as.list(li1)

&gt; li1    </code></pre>
<br>

<pre><code>[[1]]
[1] 1

[[2]]
[1] 2

[[3]]
[1] 3</code></pre>
<p>用unlist()函数把列表转换成基本向量</p>
<pre><code>&gt; li2 &lt;- list(x=1, y=c(2,3))
&gt; li2
$x
[1] 1

$y
[1] 2 3

&gt; unlist(li2)
 x y1 y2 
 1  2  3 </code></pre>
<h2 id="返回列表的函数示例–-strsplit"><a href="#返回列表的函数示例–-strsplit" class="headerlink" title="返回列表的函数示例– strsplit()"></a>返回列表的函数示例– strsplit()</h2><p>strsplit()输入一个字符型向量并指定一个分隔符， 返回一个项数与字符型向量元素个数相同的列表， 列表每项对应于字符型向量中一个元素的拆分结果。 如</p>
<pre><code>&gt; x &lt;- c(&quot;10, 8, 7&quot;, &quot;5, 2, 2&quot;, &quot;3, 7, 8&quot;, &quot;8, 8, 9&quot;)
&gt; res &lt;- strsplit(x, &quot;,&quot;); res
[[1]]
[1] &quot;10&quot; &quot; 8&quot; &quot; 7&quot;

[[2]]
[1] &quot;5&quot;  &quot; 2&quot; &quot; 2&quot;

[[3]]
[1] &quot;3&quot;  &quot; 7&quot; &quot; 8&quot;

[[4]]
[1] &quot;8&quot;  &quot; 8&quot; &quot; 9&quot;</code></pre>
]]></content>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>字符型数据及处理</title>
    <url>/2020/11/01/%E5%AD%97%E7%AC%A6%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="字符型向量"><a href="#字符型向量" class="headerlink" title="字符型向量"></a>字符型向量</h2><p>字符型向量是元素为字符串的向量。 如</p>
<pre><code>&gt; s1 &lt;- c(&#39;abc&#39;, &#39;&#39;, &#39;a cat&#39;, NA, &#39;李明&#39;)</code></pre>
<p>注意空字符串并不能自动认为是缺失值， 字符型的缺失值仍用NA表示。</p>
<h2 id="paste-函数"><a href="#paste-函数" class="headerlink" title="paste()函数"></a>paste()函数</h2><p>针对字符型数据最常用的R函数是paste()函数。 paste()用来连接两个字符型向量， 元素一一对应连接， 默认用空格连接。 如paste(c(“ab”, “cd”), c(“ef”, “gh”)) 结果相当于c(“ab ef”, “cd gh”)。</p>
<p>paste()在连接两个字符型向量时采用R的一般向量间运算规则， 而且可以自动把数值型向量转换为字符型向量。 可以作一对多连接， 如paste(“x”, 1:3)结果相当于c(“x 1”, “x 2”, “x 3”)。</p>
<p>用sep=指定分隔符， 如paste(“x”, 1:3, sep=””)结果相当于c(“x1”, “x2”, “x3”)。</p>
<p>使用collapse=参数可以把字符型向量的各个元素连接成一个单一的字符串, 如paste(c(“a”, “b”, “c”), collapse=””)结果相当于”abc”。</p>
<h2 id="转换大小写"><a href="#转换大小写" class="headerlink" title="转换大小写"></a>转换大小写</h2><p>toupper()函数把字符型向量内容转为大写， tolower()函数转为小写。 比如，toupper(‘aB cd’)结果为”AB CD”， tolower(c(‘aB’, ‘cd’))结果相当于c(“ab” “cd”)。 这两个函数可以用于不区分大小写的比较， 比如，不论x的值是’JAN’, ‘Jan’还是’jan’， toupper(x)==’JAN’的结果都为TRUE。</p>
<h2 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h2><p>用nchar(x, type=’bytes’)计算字符型向量x中每个字符串的以字节为单位的长度，这一点对中英文是有差别的， 中文通常一个汉字占两个字节，英文字母、数字、标点占一个字节。 用nchar(x, type=’chars’)计算字符型向量x中每个字符串的以字符个数为单位的长度，这时一个汉字算一个单位。</p>
<p>在画图时可以用strwidth()函数计算某个字符串或表达式占用的空间大小。</p>
<h2 id="取子串"><a href="#取子串" class="headerlink" title="取子串"></a>取子串</h2><p>substr(x, start, stop)从字符串x中取出从第start个到第stop个的子串， 如</p>
<pre><code>&gt; substr(&#39;JAN07&#39;, 1, 3)
## [1] &quot;JAN&quot;</code></pre>
<p>如果x是一个字符型向量，substr将对每个元素取子串。如</p>
<pre><code>&gt; substr(c(&#39;JAN07&#39;, &#39;MAR66&#39;), 1, 3)
## [1] &quot;JAN&quot; &quot;MAR&quot;</code></pre>
<p>用substring(x, start)可以从字符串x中取出从第start个到末尾的子串。如</p>
<pre><code>&gt; substring(c(&#39;JAN07&#39;, &#39;MAR66&#39;), 4)
## [1] &quot;07&quot; &quot;66&quot;</code></pre>
<p>##类型转换##</p>
<p>用as.numeric()把内容是数字的字符型值转换为数值，如</p>
<pre><code>&gt; substr(&#39;JAN07&#39;, 4, 5)
## [1] &quot;07&quot;

&gt; substr(&#39;JAN07&#39;, 4, 5) + 2000
## Error in substr(&quot;JAN07&quot;, 4, 5) + 2000 : 
##   non-numeric argument to binary operator

&gt; as.numeric(substr(&#39;JAN07&#39;, 4, 5)) + 2000
## [1] 2007

&gt; as.numeric(substr(c(&#39;JAN07&#39;, &#39;MAR66&#39;), 4, 5))
## [1]  7 66</code></pre>
<p>as.numeric()是向量化的， 可以转换一个向量的每个元素为数值型。</p>
<p>用as.character()函数把数值型转换为字符型，如</p>
<pre><code>&gt; as.character((1:5)*5)
## [1] &quot;5&quot;  &quot;10&quot; &quot;15&quot; &quot;20&quot; &quot;25&quot;</code></pre>
<p>如果自变量本来已经是字符型则结果不变。</p>
<p>为了用指定的格式数值型转换成字符型， 可以使用sprintf()函数， 其用法与C语言的sprintf()函数相似， 只不过是向量化的。例如</p>
<pre><code>&gt; sprintf(&#39;file%03d.txt&#39;, c(1, 99, 100))
## [1] &quot;file001.txt&quot; &quot;file099.txt&quot; &quot;file100.txt&quot;</code></pre>
<h2 id="字符串拆分"><a href="#字符串拆分" class="headerlink" title="字符串拆分"></a>字符串拆分</h2><p>用strsplit()函数可以把一个字符串按照某种分隔符拆分开，例如</p>
<pre><code>&gt; x &lt;- &#39;10,8,7&#39;
&gt; strsplit(x, &#39;,&#39;, fixed=TRUE)[[1]]
## [1] &quot;10&quot; &quot;8&quot;  &quot;7&quot;

&gt; sum(as.numeric(strsplit(x, &#39;,&#39;, fixed=TRUE)[[1]]))
## [1] 25</code></pre>
<p>因为strsplit()的结果是一个列表， 这个函数延后再详细讲。</p>
<h2 id="字符串替换功能"><a href="#字符串替换功能" class="headerlink" title="字符串替换功能"></a>字符串替换功能</h2><p>用gsub()可以替换字符串中的子串， 这样的功能经常用在数据清理中。 比如，把数据中的中文标点改为英文标点， 去掉空格，等等。 如</p>
<pre><code>&gt; x &lt;- &#39;1, 3; 5&#39;
&gt; gsub(&#39;;&#39;, &#39;,&#39;, x, fixed=TRUE)
## [1] &quot;1, 3, 5&quot;

&gt; strsplit(gsub(&#39;;&#39;, &#39;,&#39;, x, fixed=TRUE), &#39;,&#39;)[[1]]
## [1] &quot;1&quot;  &quot; 3&quot; &quot; 5&quot;</code></pre>
<p>字符串x中分隔符既有逗号又有分号， 上面的程序用gsub()把分号都换成逗号。</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式(regular expression)是一种匹配某种字符串模式的方法。 用这样的方法，可以从字符串中查找某种模式的出现位置， 替换某种模式，等等。 这样的技术可以用于文本数据的预处理， 比如用网络爬虫下载的大量网页文本数据。 R中支持perl语言格式的正则表达式， grep()和grepl()函数从字符串中查询某个模式， sub()和gsub()替换某模式。 比如， 下面的程序把多于一个空格替换成一个空格</p>
<pre><code>&gt; gsub(&#39;[[:space:]]+&#39;, &#39; &#39;, &#39;a   cat  in a box&#39;, perl=TRUE)
## [1] &quot;a cat in a box&quot;</code></pre>
]]></content>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>数据框</title>
    <url>/2020/11/15/%E6%95%B0%E6%8D%AE%E6%A1%86/</url>
    <content><![CDATA[<h2 id="数据框"><a href="#数据框" class="headerlink" title="数据框"></a>数据框</h2><p>统计分析中最常见的原始数据形式是类似于数据库表或Excel数据表的形式。 这样形式的数据在R中叫做数据框(data.frame)。 数据框类似于一个矩阵，有n行、p列， 但各列允许有不同类型：数值型向量、因子、字符型向量、日期时间向量。 同一列的数据类型相同。 在R中数据框是一个特殊的列表， 其每个列表元素都是一个长度相同的向量。 事实上，数据框还允许一个元素是一个矩阵， 但这样会使得某些读入数据框的函数发生错误。</p>
<p>函数data.frame()可以生成数据框，如</p>
<pre><code>&gt; d &lt;- data.frame(
+     name=c(&quot;李明&quot;, &quot;张聪&quot;, &quot;王建&quot;), 
+     age=c(30, 35, 28), 
+     height=c(180, 162, 175),
+     stringsAsFactors=FALSE)

&gt; d
  name age height
1 李明  30    180
2 张聪  35    162
3 王建  28    175</code></pre>
<p>data.frame()函数会将字符型列转换成因子， 加选项<strong>stringsAsFactors=FALSE</strong>可以避免这样的转换.</p>
<pre><code>&gt; nrow(d)
[1] 3

&gt; names(d)
[1] &quot;name&quot;   &quot;age&quot;    &quot;height&quot;</code></pre>
<p>用as.data.frame(x)可以把x转换成数据框。 如果x是一个向量， 转换结果是以x为唯一一列的数据框。 如果x是一个列表并且列表元素都是长度相同的向量， 转换结果中每个列表变成数据框的一列。 如果x是一个矩阵，转换结果把矩阵的每列变成数据框的一列。</p>
<h2 id="数据框内容访问"><a href="#数据框内容访问" class="headerlink" title="数据框内容访问"></a>数据框内容访问</h2><p>数据框可以用矩阵格式访问，如</p>
<pre><code>&gt; d[2,3]
[1] 162</code></pre>
<p>访问单个元素。</p>
<pre><code>&gt; d[[2]]
[1] 30 35 28</code></pre>
<p>访问第二列，结果为向量。</p>
<pre><code>&gt; class(d[,2])
[1] &quot;numeric&quot;

&gt; d[[&quot;age&quot;]]
[1] 30 35 28

&gt; d[,&quot;age&quot;]
[1] 30 35 28

&gt; d$age
[1] 30 35 28</code></pre>
<p>因为数据框的一行不一定是相同数据类型， 所以数据框的一行作为子集， 结果还是数据框，而不是向量。如</p>
<pre><code>&gt; d[2,]
  name age height
2 张聪  35    162

&gt; class(d[2,])
[1] &quot;data.frame&quot;</code></pre>
<p>可以同时取行子集和列子集，如</p>
<pre><code>&gt; d[1:2, &quot;age&quot;]
[1] 30 35

&gt; d[1:2, c(&quot;age&quot;, &quot;height&quot;)]
  age height
1  30    180
2  35    162

&gt; d[d[&quot;height&quot;]&gt;=170,]
  name age height
1 李明  30    180
3 王建  28    175</code></pre>
<p>与矩阵类似地是， 用如d[,”age”], d[,2]这样的方法取出的数据框的单个列是向量而不再是数据框。 但是，如果取出两列或者两列以上， 结果则是数据框。 如果取列子集时不能预先知道取出的列个数， 则子集结果有可能是向量也有可能是数据框， 容易造成后续程序错误。 对一般的数据框， 可以在取子集的方括号内加上drop=FALSE选项， 确保取列子集的结果总是数据框。 数据框的改进类型tibble在取出列子集时保持为tibble格式。</p>
<p>对数据框变量名按照字符串与集合进行操作可以实现复杂的列子集筛选。</p>
<h2 id="数据框的行名"><a href="#数据框的行名" class="headerlink" title="数据框的行名"></a>数据框的行名</h2><p>数据框每一行可以有行名， 这在原始的S语言和传统的R语言中是重要的技术， 但是在改进类型tibble中则取消了行名， 需要用列名实现功能一般改用left_join()函数实现。</p>
<p>比如，每一行定义行名为身份证号，则可以唯一识别各行。 下面的例子以姓名作为行名:</p>
<pre><code>&gt; rownames(d) &lt;- d$name
&gt; d$name &lt;- NULL
&gt; d
     age height
李明  30    180
张聪  35    162
王建  28    17</code></pre>
<p>用数据框的行名可以建立一个值到多个值的对应表。 比如，有如下的数据框：</p>
<pre><code>&gt; dm &lt;- data.frame(
+     &quot;年级&quot;=1:6,
+     &quot;出游&quot;=c(0, 2, 2, 2, 2, 1),
+     &quot;疫苗&quot;=c(T, F, F, F, T, F)
+ )

&gt; dm
  年级 出游  疫苗
1    1    0  TRUE
2    2    2 FALSE
3    3    2 FALSE
4    4    2 FALSE
5    5    2  TRUE
6    6    1 FALSE</code></pre>
<p>其中“出游”是每个年级安排的出游次数， “疫苗”是该年级有全体无计划免疫注射。 把年级变成行名，可以建立年级到出游次数与疫苗注射的对应表：</p>
<pre><code>&gt; dm[[&quot;年级&quot;]] &lt;- NULL
&gt; dm
  出游  疫苗
1    0  TRUE
2    2 FALSE
3    2 FALSE
4    2 FALSE
5    2  TRUE
6    1 FALSE</code></pre>
<p>这样，假设某个社区的小学中抽取的4个班的年级为 c(2,1,3)， 其对应的出游和疫苗注射信息可查询如下：</p>
<pre><code>&gt; ind &lt;- c(2,1,3)
&gt; dm[as.character(ind),]
  出游  疫苗
2    2 FALSE
1    0  TRUE
3    2 FALSE</code></pre>
<p>实际上，这个例子可以不用行名而是用match()函数实现。 match(x, table)对x的每个元素返回其在table中出现的位置序号。 找不到的元素返回NA。 如：</p>
<pre><code>&gt; match(c(12, 15), 11:14)
[1]  2 NA</code></pre>
<p>对于上面的学校年级信息查询的例子， 可以首先查找每个班对应的年级在数据框中的行序号， 然后再返回这些行组成的数据框：</p>
<pre><code>&gt; dm &lt;- data.frame(
+   &quot;年级&quot;=1:6,
+   &quot;出游&quot;=c(0, 2, 2, 2, 2, 1),
+   &quot;疫苗&quot;=c(T, F, F, F, T, F)
+ )

&gt; ind &lt;- match(c(2,1,3),dm[[&quot;年级&quot;]])
&gt; ind
[1] 2 1 3

&gt; dm[ind,]
  年级 出游  疫苗
2    2    2 FALSE
1    1    0  TRUE
3    3    2 FALSE</code></pre>
<p>实际上，这个例子可以不用行名而是用match()函数实现。 match(x, table)对x的每个元素返回其在table中出现的位置序号。 找不到的元素返回NA。 如：</p>
<pre><code>&gt; match(c(12, 15), 11:14)
[1]  2 NA</code></pre>
<p>对于上面的学校年级信息查询的例子， 可以首先查找每个班对应的年级在数据框中的行序号， 然后再返回这些行组成的数据框：</p>
<pre><code>&gt; dm &lt;- data.frame(
+   &quot;年级&quot;=1:6,
+   &quot;出游&quot;=c(0, 2, 2, 2, 2, 1),
+   &quot;疫苗&quot;=c(T, F, F, F, T, F)
+ )

&gt; ind &lt;- match(c(2,1,3),dm[[&quot;年级&quot;]])
&gt; ind
[1] 2 1 3

&gt; dm[ind,]
  年级 出游  疫苗
2    2    2 FALSE
1    1    0  TRUE
3    3    2 FALSE</code></pre>
<p>对于代替数据框的tibble类型， 如果要实现行名的功能， 可以将行名作为单独的一列， 然后用dplyr包的inner_join()、left_join()、full_join()等函数横向合并数据集。</p>
<h2 id="数据框与矩阵的区别"><a href="#数据框与矩阵的区别" class="headerlink" title="数据框与矩阵的区别"></a>数据框与矩阵的区别</h2><p>数据框不能作为矩阵参加矩阵运算。 需要时，可以用as.matrix()函数转换数据框或数据框的子集为矩阵。 如</p>
<pre><code>&gt; d2 &lt;- as.matrix(d[,c(&quot;height&quot;,&quot;age&quot;)])
&gt; d2
     height age
[1,]    180  30
[2,]    162  35
[3,]    175  28

&gt; d4 &lt;- tidyr::expand_grid(
+     group=1:3,
+     subgroup=1:2,
+     obs=1:2)</code></pre>
<p>结果的数据框d有三个变量: group是大组，共分3个大组，每组4个观测； subgroup是子组，在每个大组内分为2个子组，每个子组2个观测。 共有个观测3x2x2=12（行）。</p>
<pre><code>&gt; print(d4)
# A tibble: 12 x 3
   group subgroup   obs
   &lt;int&gt;    &lt;int&gt; &lt;int&gt;
 1     1        1     1
 2     1        1     2
 3     1        2     1
 4     1        2     2
 5     2        1     1
 6     2        1     2
 7     2        2     1
 8     2        2     2
 9     3        1     1
10     3        1     2
11     3        2     1
12     3        2     2</code></pre>
<h2 id="tibble类型"><a href="#tibble类型" class="headerlink" title="tibble类型"></a>tibble类型</h2><p>tibble类型是一种改进的数据框。 readr包的read_csv()函数是read.csv()函数的一个改进版本， 它将CSV文件读入为tibble类型，如文件<a href="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/class.csv">class.csv</a>的读入:</p>
<pre><code>&gt; library(tibble)

载入程辑包：&#39;tibble&#39;

The following object is masked from &#39;package:ShortRead&#39;:

    view

&gt; library(readr)
&gt; t.class &lt;- read_csv(&quot;class.csv&quot;)

-- Column specification --------------------------------
cols(
  name = col_character(),
  sex = col_character(),
  age = col_double(),
  height = col_double(),
  weight = col_double()
)

&gt; t.class
# A tibble: 19 x 5
   name    sex     age height weight
   &lt;chr&gt;   &lt;chr&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
 1 Alice   F        13   56.5   84  
 2 Becka   F        13   65.3   98  
 3 Gail    F        14   64.3   90  
 4 Karen   F        12   56.3   77  
 5 Kathy   F        12   59.8   84.5
 6 Mary    F        15   66.5  112  
 7 Sandy   F        11   51.3   50.5
 8 Sharon  F        15   62.5  112. 
 9 Tammy   F        14   62.8  102. 
10 Alfred  M        14   69    112. 
11 Duke    M        14   63.5  102. 
12 Guido   M        15   67    133  
13 James   M        12   57.3   83  
14 Jeffrey M        13   62.5   84  
15 John    M        12   59     99.5
16 Philip  M        16   72    150  
17 Robert  M        12   64.8  128  
18 Thomas  M        11   57.5   85  
19 William M        15   66.5  112 </code></pre>
<p>tibble类型的类属依次为tbl_df, tbl, data.frame：</p>
<pre><code>&gt; class(t.class)
[1] &quot;spec_tbl_df&quot; &quot;tbl_df&quot;      &quot;tbl&quot;        
[4] &quot;data.frame&quot; </code></pre>
<p>实际上，旧式数据框支持行名，有如下的缺点：</p>
<ol>
<li><p>行名本身往往也是有效的数据，如身份证号， 将有效数据以数据框中的列和行名两种不同形式保存， 增加了复杂度；</p>
</li>
<li><p>为了使用某些变量辨识不同的行（观测）， 行名也具有局限性： 行名必须是相互不同的， 必须是字符型， 而用来区分各个观测的变量有可能有多个， 也可能不是字符型。</p>
</li>
<li><p>行名要求互不相同是有局限性的， 如果用来辨识各行的变量有重复值， 就可以构成对各行的一种自然的分组。</p>
</li>
</ol>
<p>tibble类型允许其中的列是列表类型， 这样， 该列的每个元素就可以是复杂类型， 比如建模结果（列表）， 元素之间可以保存不等长的值。 如：</p>
<pre><code>&gt; tibble(x = 1:3,
+        y = list(1, 1:2, 1:3))
# A tibble: 3 x 2
      x y        
  &lt;int&gt; &lt;list&gt;   
1     1 &lt;dbl [1]&gt;
2     2 &lt;int [2]&gt;
3     3 &lt;int [3]&gt;</code></pre>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>假设<a href="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/class.csv">class.csv</a>已经读入为R数据框d.class, 其中的sex列已经自动转换为因子。</p>
<ol>
<li><p>显示d.class中年龄至少为15的行子集；</p>
</li>
<li><p>显示女生且年龄至少为15的学生姓名和年龄；</p>
</li>
<li><p>取出数据框中的age变量赋给变量x。</p>
</li>
</ol>
<h2 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h2><p>###1.</p>
<pre><code>&gt; d.class[d.class[[&quot;age&quot;]]&gt;=15,]
      name sex age height weight
6     Mary   F  15   66.5  112.0
8   Sharon   F  15   62.5  112.5
12   Guido   M  15   67.0  133.0
16  Philip   M  16   72.0  150.0
19 William   M  15   66.5  112.0</code></pre>
<p>###2.</p>
<p>我采取的办法有些笨，相当于一步一步来解决这个问题。首先因为第二题是在第一题的基础上来解决的。所以我先将上一题筛选的子集独立保存为一个data frame,命名为fliter_d.class,接着依旧安装上一题的思路，再增加一个筛选项。</p>
<pre><code>&gt; fliter_d.class &lt;- d.class[d.class[[&quot;age&quot;]]&gt;=15,]
&gt; fliter_d.class
      name sex age height weight
6     Mary   F  15   66.5  112.0
8   Sharon   F  15   62.5  112.5
12   Guido   M  15   67.0  133.0
16  Philip   M  16   72.0  150.0
19 William   M  15   66.5  112.0

&gt; fliter_d.class[fliter_d.class[[&quot;sex&quot;]]==&quot;F&quot;,]
    name sex age height weight
6   Mary   F  15   66.5  112.0
8 Sharon   F  15   62.5  112.5</code></pre>
<p>最后因为要看只姓名和年龄</p>
<pre><code>&gt; fliter_d.class[fliter_d.class[[&quot;sex&quot;]]==&quot;F&quot;,][,c(1,3)]
    name age
6   Mary  15
8 Sharon  15</code></pre>
<p>当然也可以直接使用dplyr包下的fliter()函数</p>
<pre><code>&gt; d.class %&gt;%
+     filter(sex==&quot;F&quot;, age&gt;=15) %&gt;%
+     knitr::kable()


|name   |sex | age| height| weight|
|:------|:---|---:|------:|------:|
|Mary   |F   |  15|   66.5|  112.0|
|Sharon |F   |  15|   62.5|  112.5|</code></pre>
<p>或者更加直接一点</p>
<pre><code>&gt; filter(d.class,sex == &quot;F&quot;, age &gt;= 15)
    name sex age height weight
1   Mary   F  15   66.5  112.0
2 Sharon   F  15   62.5  112.5</code></pre>
<p>###3.</p>
<pre><code>&gt; x &lt;- d.class[[&quot;age&quot;]]
&gt; x
 [1] 13 13 14 12 12 15 11 15 14 14 14 15 12 13 12 16 12
[18] 11 15</code></pre>
]]></content>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型及性质</title>
    <url>/2020/11/05/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%80%A7%E8%B4%A8/</url>
    <content><![CDATA[<h2 id="存储模式与基本类型"><a href="#存储模式与基本类型" class="headerlink" title="存储模式与基本类型"></a>存储模式与基本类型</h2><p>R的变量可以存储多种不同的数据类型， 可以用typeof()函数来返回一个变量或表达式的类型。比如</p>
<pre><code>&gt; typeof(1:3)
## [1] &quot;integer&quot;

&gt; typeof(c(1,2,3))
## [1] &quot;double&quot;

&gt; typeof(c(1, 2.1, 3))
## [1] &quot;double&quot;

&gt; typeof(c(TRUE, NA, FALSE))
## [1] &quot;logical&quot;

&gt; typeof(&#39;Abc&#39;)
## [1] &quot;character&quot;

&gt; typeof(factor(c(&#39;F&#39;, &#39;M&#39;, &#39;M&#39;, &#39;F&#39;)))
## [1] &quot;integer&quot;</code></pre>
<p>*<em>注意**</em>因子的结果是integer而不是因子。*</p>
<p>R还有两个函数mode()和storage.mode()起到与typeof()类似的作用， 这是为了提供与S语言兼容所遗留的， 应停止使用。</p>
<p>R中数据的最基本的类型包括logical, integer, double, character, complex, raw, 其它数据类型都是由基本类型组合或转变得到的。 character类型就是字符串类型， raw类型是直接使用其二进制内容的类型。 为了判断某个向量x保存的基本类型， 可以用is.xxx()类函数， 如is.integer(x), is.double(x), is.numeric(x), is.logical(x), is.character(x), is.complex(x), is.raw(x)。 其中<strong>is.numeric(x)对integer和double内容都返回真值。</strong></p>
<p>在R语言中数值一般看作double, 如果需要明确表明某些数值是整数， 可以在数值后面附加字母L，如</p>
<pre><code>&gt; is.integer(c(1, -3))
## [1] FALSE

&gt; is.integer(c(1L, -3L))
## [1] TRUE</code></pre>
<p>整数型的缺失值是NA， 而double型的特殊值除了NA外， 还包括Inf, -Inf和NaN， 其中NaN也算是缺失值, Inf和-Inf不算是缺失值。 如:</p>
<pre><code>&gt; c(-1, 0, 1)/0
## [1] -Inf  NaN  Inf

&gt; is.na(c(-1, 0, 1)/0)
## [1] FALSE  TRUE FALSE</code></pre>
<p>对double类型，可以用<strong>is.finite()判断是否有限值</strong>， NA、Inf, -Inf和NaN都不是有限值； 用is.infinite()判断是否Inf或-Inf； is.na()判断是否NA或NaN； is.nan()判断是否NaN。</p>
<p>严格说来， NA表示逻辑型缺失值， 但是当作其它类型缺失值时一般能自动识别。 NA_integer_是整数型缺失值， NA_real是double型缺失值， NA_character_是字符型缺失值。</p>
<p>在R的向量类型中， integer类型、double类型、logical类型、character类型、还有complex类型和raw类型称为原子类型(atomic types)， 原子类型的向量中元素都是同一基本类型的。 比如， double型向量的元素都是double或者缺失值。</p>
<p>除了原子类型的向量， 在R语言的定义中， 向量还包括后面要讲到的列表（list）， 列表的元素不需要属于相同的基本类型， 而且列表的元素可以不是单一基本类型元素。 用typeof()函数可以返回向量的类型， 列表返回结果为”list”:</p>
<pre><code>&gt; typeof(list(&quot;a&quot;, 1L, 1.5))
## [1] &quot;list&quot;</code></pre>
<p>原子类型的各个元素除了基本类型相同， 还不包含任何嵌套结构，如：</p>
<pre><code>&gt; c(1, c(2,3, c(4,5)))
## [1] 1 2 3 4 5</code></pre>
<p>R有一个特殊的NULL类型， 这个类型只有唯一的一个NULL值， 表示不存在。 <strong>NULL长度为0， 不能有任何属性值</strong>。 用is.null()函数判断某个变量是否取NULL。</p>
<p><strong>NULL值可以用来表示类型未知的零长度向量</strong>， 如c()没有自变量时返回值就是NULL； 也经常用作函数缺省值， 在函数内用is.null()判断其缺省后再用一定的计算逻辑得到真正的缺省情况下的数值。</p>
<p>要把NULL与NA区分开来， <strong>NA是有类型的（integer、double、logical、character等)</strong>, <strong>NA表示存在但是未知</strong>。 数据库管理系统中的NULL值相当于R中的NA值。</p>
<h2 id="类型转换与类型升档"><a href="#类型转换与类型升档" class="headerlink" title="类型转换与类型升档"></a>类型转换与类型升档</h2><p>可以用as.xxx()类的函数在不同类型之间进行强制转换。 如</p>
<pre><code>&gt; as.numeric(c(FALSE, TRUE))
## [1] 0 1

&gt; as.character(sqrt(1:4))
## [1] &quot;1&quot;                &quot;1.4142135623731&quot;  &quot;1.73205080756888&quot; &quot;2&quot;</code></pre>
<p>类型转换也可能是隐含的，比如， <strong>四则运算中数值会被统一转换为double类型</strong>， 逻辑运算中运算元素会被统一转换为logical类型。 逻辑值转换成数值时，TRUE转换成1， FALSE转换成0。</p>
<p>在用c()函数合并若干元素时， <strong>如果元素基本类型不同， 将统一转换成最复杂的一个</strong>，复杂程度从简单到复杂依次为： <strong>logical&lt;integer&lt;double&lt;character</strong>。 这种做法称为类型升档，如</p>
<pre><code>&gt; c(FALSE, 1L, 2.5, &quot;3.6&quot;)
## [1] &quot;FALSE&quot; &quot;1&quot;     &quot;2.5&quot;   &quot;3.6&quot;</code></pre>
<p>不同类型参与要求类型相同的运算时， 也会统一转换为最复杂的类型， 也称为类型升档， 如：</p>
<pre><code>&gt; TRUE + 10
## [1] 11

&gt; paste(&quot;abc&quot;, 1)
## [1] &quot;abc 1&quot;</code></pre>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>除了NULL以外， R的变量都可以看成是对象， 都可以有属性。 在R语言中， 属性是把变量看成对象后， 除了其存储内容（如元素）之外的其它附加信息， 如维数、类属等。 R对象一般都有length和mode两个属性。</p>
<p>常用属性有<strong>names, dim，class</strong>等。</p>
<h3 id="attributes函数"><a href="#attributes函数" class="headerlink" title="attributes函数"></a>attributes函数</h3><p>对象x的所有属性可以用attributes()读取， 如</p>
<pre><code>&gt; x &lt;- table(c(1,2,1,3,2,1)); print(x)
## 
## 1 2 3 
## 3 2 1

&gt; attributes(x)
## $dim
## [1] 3
## 
## $dimnames
## $dimnames[[1]]
## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot;
## 
## 
## $class
## [1] &quot;table&quot;</code></pre>
<p><em>table()</em> 函数用了输出其自变量中每个不同值的出现次数，称为<strong>频数</strong>。 从上例可以看出， table()函数的结果有三个属性，前两个是dim和dimnames, 这是数组(array)具有的属性； 另一个是class属性，值为”table”。 因为x是数组，可以访问如</p>
<pre><code>&gt; x[1]
## 1 
## 3

&gt; x[&quot;3&quot;]
## 3 
## 1</code></pre>
<p>也可以用attributes()函数修改属性， 如</p>
<pre><code>&gt; attributes(x) &lt;- NULL
&gt; x
## [1] 3 2 1</code></pre>
<p>如上修改后x不再是数组，也不是table。</p>
<h3 id="attr函数"><a href="#attr函数" class="headerlink" title="attr函数"></a>attr函数</h3><p>可以用attr(x, “属性名”)的格式读取或定义x的属性。 如：</p>
<pre><code>&gt; x &lt;- c(1,3,5)
&gt; attr(x, &quot;theta&quot;) &lt;- c(0, 1)
&gt; print(x)

## [1] 1 3 5
## attr(,&quot;theta&quot;)
## [1] 0 1</code></pre>
<p>可以让向量x额外地保存一个theta属性， 这样的属性常常成为“元数据”(meta data)， 比如， 用来保存数据的说明、模拟数据的真实模型参数，等等。</p>
<h3 id="names属性"><a href="#names属性" class="headerlink" title="names属性"></a>names属性</h3><p>有元素名的向量、列表、数据框等都有names属性， 许多R函数的输出本质上也是列表， 所以也有names属性。 用names(x)的格式读取或设定。 如：</p>
<pre><code>&gt; x &lt;- 1:5
&gt; y &lt;- x^2
&gt; lmr &lt;- lm(y ~ x)
&gt; print(names(lmr))

##  [1] &quot;coefficients&quot;  &quot;residuals&quot;     &quot;effects&quot;       &quot;rank&quot;         
##  [5] &quot;fitted.values&quot; &quot;assign&quot;        &quot;qr&quot;            &quot;df.residual&quot;  
##  [9] &quot;xlevels&quot;       &quot;call&quot;          &quot;terms&quot;         &quot;model&quot;</code></pre>
<p>对于没有元素名的向量x，names(x)的返回值是NULL。</p>
<h3 id="dim属性"><a href="#dim属性" class="headerlink" title="dim属性"></a>dim属性</h3><p>dim属性的存在表明对象是矩阵或一维、多维数组。 如：</p>
<pre><code>&gt; x &lt;- matrix(1:12, nrow=3, ncol=4)
&gt; attr(x, &quot;dim&quot;) # 等同于dim(x)

## [1] 3 4</code></pre>
<p>修改dim属性就将向量转换成矩阵（数组）， 或修改了矩阵的性质， 元素按列次序重排填入新的矩阵。如：</p>
<pre><code>&gt; x &lt;- 1:10
&gt; dim(x) &lt;- c(2,5)
&gt; x

##   [,1] [,2] [,3] [,4] [,5]
[1,]    1    3    5    7    9
[2,]    2    4    6    8   10</code></pre>
<p>R允许dim仅有一个元素， 这对应于一维向量， 与普通的没有dim属性的向量有区别。 另外要注意， <strong>取矩阵子集时如果结果仅有一列或一行， 除非用了drop=FALSE选项， 结果不再有dim属性， 退化成了普通向量</strong>。</p>
<h3 id="str-函数"><a href="#str-函数" class="headerlink" title="str()函数"></a>str()函数</h3><p>用print()函数可以显示对象内容。 如果内容很多， 显示行数可能也很多。 用str()函数可以显示对象的类型和主要结构及典型内容。例如</p>
<pre><code>&gt; s &lt;- 101:200
&gt; attr(s,&#39;author&#39;) &lt;- &#39;李小明&#39;
&gt; attr(s,&#39;date&#39;) &lt;- &#39;2016-09-12&#39;

&gt; str(s)

## int [1:100] 101 102 103 104 105 106 107 108 109 110 ...
 - attr(*, &quot;author&quot;)= chr &quot;李小明&quot;
 - attr(*, &quot;date&quot;)= chr &quot;2016-09-12&quot;

&gt; print(s)

## [1] 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120
 [21] 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140
 [41] 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160
 [61] 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180
 [81] 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200
attr(,&quot;author&quot;)
[1] &quot;李小明&quot;
attr(,&quot;date&quot;)
[1] &quot;2016-09-12&quot;</code></pre>
]]></content>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵和数组</title>
    <url>/2020/11/14/%E7%9F%A9%E9%98%B5%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="R矩阵"><a href="#R矩阵" class="headerlink" title="R矩阵"></a>R矩阵</h2><p>矩阵用matrix函数定义，实际存储成一个向量，根据保存的行数和列数对应到矩阵的元素， 存储次序为按列存储。 定义如</p>
<pre><code>&gt; A &lt;- matrix(11:16, nrow=3, ncol=2)
&gt; print(A)
     [,1] [,2]
[1,]   11   14
[2,]   12   15
[3,]   13   16

&gt; B &lt;- matrix(c(1,-1, 1,1), nrow=2, ncol=2, byrow=TRUE)
&gt; B
     [,1] [,2]
[1,]    1   -1
[2,]    1    1</code></pre>
<p>matrix()函数把矩阵元素以一个<strong>向量的形式输入</strong>， 用nrow和ncol规定行数和列数，向量元素填入矩阵的缺省次序是按列填入， 用byrow=TRUE选项可以转换成按行填入。</p>
<pre><code>&gt; nrow(A)
[1] 3
&gt; ncol(A)
[1] 2</code></pre>
<p>矩阵有一个dim属性，内容是两个元素的向量， 两个元素分别为矩阵的行数和列数。dim属性可以用dim()函数访问。如</p>
<pre><code>&gt; attributes(A)
$dim
[1] 3 2

&gt; dim(A)
[1] 3 2</code></pre>
<p>函数<strong>t(A)**返回</strong>A的转置**。</p>
<pre><code>&gt; t(A)
     [,1] [,2] [,3]
[1,]   11   12   13
[2,]   14   15   16</code></pre>
<h2 id="矩阵子集"><a href="#矩阵子集" class="headerlink" title="矩阵子集"></a>矩阵子集</h2><p>用A[1,]取出A的第一行，变成一个普通向量。 用A[,1]取出A的第一列，变成一个普通向量。 用A[c(1,3),1:2]取出指定行、列对应的子矩阵。 如</p>
<pre><code>&gt; A[1,1:2]
[1] 11 14

&gt; A[c(1,3),1:2]
     [,1] [,2]
[1,]   11   14
[2,]   13   16</code></pre>
<p>用colnames()函数可以给矩阵每列命名， 也可以访问矩阵列名， 用rownames()函数可以给矩阵每行命名， 也可以访问矩阵行名。如</p>
<pre><code>&gt; colnames(A) &lt;- c(&quot;A&quot;,&quot;C&quot;)
&gt; rownames(A)&lt;- c(&quot;B&quot;,&quot;D&quot;,&quot;F&quot;)
&gt; A
   A  C
B 11 14
D 12 15
F 13 16</code></pre>
<p>有了列名、行名后，矩阵下标可以用字符型向量， 如</p>
<pre><code>&gt; A[,&quot;A&quot;]
 B  D  F 
11 12 13 

&gt; A[&quot;B&quot;,]
 A  C 
11 14

&gt; A[c(&quot;B&quot;,&quot;D&quot;),&quot;A&quot;]
 B  D 
11 12 </code></pre>
<p>注意在对矩阵取子集时， 如果<strong>取出的子集仅有一行或仅有一列， 结果就不再是矩阵而是变成了R向量</strong>， R向量既不是行向量也不是列向量。 如果想避免这样的规则起作用，需要在方括号下标中加选项<strong>drop=FALSE</strong>， 如</p>
<pre><code>&gt; A[A[,1]&gt;=12,&#39;C&#39;]
 D  F 
15 16 </code></pre>
<p>矩阵本质上是一个向量添加了dim属性， 实际保存还是保存成一个向量， 其中元素的保存次序是<strong>按列填入</strong>，所以也可以向对一个向量取子集那样， 仅用一个正整数向量的矩阵取子集。如</p>
<pre><code>&gt; A[c(1,3,5)]
[1] 11 13 15</code></pre>
<p>用c(A)或A[]返回矩阵A的所有元素。 如果要修改矩阵A的所有元素， 可以对A[]赋值。</p>
<pre><code>#c(A)返回所有元素的方式是以列表的形式
&gt; c(A)
[1] 11 12 13 14 15 16

# A[]的返回所有元素的方式是以矩阵的形式
&gt; A[]
   A  C
B 11 14
D 12 15
F 13 16</code></pre>
<p>对矩阵A，diag(A)访问A的主对角线元素组成的向量。 另外，若x为正整数值标量，diag(x)返回x阶单位阵； 若x为长度大于1的向量， diag(x)返回以x的元素为主对角线元素的对角矩阵。</p>
<pre><code>&gt; diag(A)
[1] 11 15</code></pre>
<h2 id="cbind-和rbind-函数"><a href="#cbind-和rbind-函数" class="headerlink" title="cbind()和rbind()函数"></a>cbind()和rbind()函数</h2><p>若x是向量，<strong>cbind(x)把x变成列向量</strong>， 即列数为1的矩阵， <strong>rbind(x)把x变成行向量</strong>。</p>
<p>若x1, x2, x3是等长的向量， cbind(x1, x2, x3)把它们看成列向量并在一起组成一个矩阵。 cbind()的自变量可以同时包含向量与矩阵，向量的长度必须与矩阵行数相等。 如</p>
<pre><code>&gt; cbind(c(1,2), c(3,4), c(5,6))
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6


&gt; cbind(A, c(1,-1,10))
   A  C   
B 11 14  1
D 12 15 -1
F 13 16 10</code></pre>
<p>**cbind()**的自变量中也允许有标量， 这时此标量被重复使用。 如</p>
<pre><code>&gt; cbind(1,c(1,-1,10))
     [,1] [,2]
[1,]    1    1
[2,]    1   -1
[3,]    1   10</code></pre>
<p>**rbind()**用法类似， 可以等长的向量看成行向量上下摞在一起， 可以是矩阵与长度等于矩阵列数的向量上下摞在一起， 向量长度为1也可以。</p>
<pre><code>&gt; rbind(c(1,2), c(3,4), c(5,6))
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6</code></pre>
<h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><p>矩阵可以与标量作四则运算，结果<strong>为每个元素进行相应运算</strong>，如</p>
<pre><code>&gt; c1 &lt;- A-1
&gt; c1
   A  C
B 10 13
D 11 14
F 12 15

&gt; c2 &lt;- A / 2
&gt; c2
    A   C
B 5.5 7.0
D 6.0 7.5
F 6.5 8.0</code></pre>
<p>两个同形状的矩阵进行加、减运算， 即对应元素相加、相减， 用A + B，A - B表示，如</p>
<pre><code>&gt; c1+c2
     A    C
B 15.5 20.0
D 17.0 21.5
F 18.5 23.0</code></pre>
<p>这就是线性代数中矩阵的加、减运算。</p>
<p>对两个同形状的矩阵， 用*表示两个矩阵对应元素相乘(注意这不是线性代数中的矩阵乘法)， 用/表示两个矩阵对应元素相除。 如</p>
<pre><code>&gt; c1 * c2
   A   C
B 55  91
D 66 105
F 78 120</code></pre>
<h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p>用<code>%*%</code>表示矩阵乘法而不是用<code>*</code>表示， 注意矩阵乘法要求左边的矩阵的列数等于右边的矩阵的行数。 如</p>
<pre><code>&gt; B &lt;- cbind(c(1,1),c(-1,1))
&gt; A%*%B
  [,1] [,2]
B   25    3
D   27    3
F   29    3</code></pre>
<h2 id="向量与矩阵相乘"><a href="#向量与矩阵相乘" class="headerlink" title="向量与矩阵相乘"></a>向量与矩阵相乘</h2><p>矩阵与向量进行乘法运算时， 向量按需要解释成列向量或行向量。 当向量左乘矩阵时，看成行向量； 当向量右乘矩阵时，看成列向量。 如</p>
<pre><code>&gt; B
     [,1] [,2]
[1,]    1   -1
[2,]    1    1

&gt; c(1,1) %*% B
     [,1] [,2]
[1,]    2    0

&gt; B %*% c(1,1)
     [,1]
[1,]    0
[2,]    2</code></pre>
<p><strong>apply()函数</strong></p>
<p>apply(A, 2, FUN)把矩阵A的每一列分别输入到函数FUN中， 得到对应于每一列的结果，如</p>
<pre><code>&gt; D &lt;- matrix(c(6,2,3,5,4,1), nrow=3, ncol=2)
&gt; D
     [,1] [,2]
[1,]    6    5
[2,]    2    4
[3,]    3    1

&gt; apply(D, 2, sum)
[1] 11 10</code></pre>
<p>apply(A, 1, FUN)把矩阵A的每一行分别输入到函数FUN中， 得到与每一行对应的结果，如</p>
<pre><code>&gt; apply(D, 1, mean)
[1] 5.5 3.0 2.0</code></pre>
<p>如果函数FUN返回多个结果， 则apply(A, 2, FUN)结果为矩阵， 矩阵的每一列是输入矩阵相应列输入到FUN的结果， 结果列数等于A的列数。如</p>
<pre><code>&gt; apply(D, 2, range)
     [,1] [,2]
[1,]    2    1
[2,]    6    5</code></pre>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组的一般定义语法为</p>
<blockquote>
<p>数组名 &lt;- array(数组元素,<br>  dim=c(第一下标个数, 第二下标个数, …, 第s下标个数))</p>
</blockquote>
<p>其中数组元素的填入次序是第一下标变化最快， 第二下标次之， 最后一个下标是变化最慢的。 这种次序称为FORTRAN次序。</p>
<p>下面是一个三维数组定义例子。</p>
<pre><code>&gt; ara &lt;- array(1:24, dim=c(2,3,4))
&gt; ara
, , 1

     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6

, , 2

     [,1] [,2] [,3]
[1,]    7    9   11
[2,]    8   10   12

, , 3

     [,1] [,2] [,3]
[1,]   13   15   17
[2,]   14   16   18

, , 4

     [,1] [,2] [,3]
[1,]   19   21   23
[2,]   20   22   24</code></pre>
<p>三维数组ara可以看成是4个2x3矩阵。 取出其中一个如ara[,,2]<br>(取出第二个矩阵)</p>
<pre><code>&gt; ara[,,2]
     [,1] [,2] [,3]
[1,]    7    9   11
[2,]    8   10   12</code></pre>
<p>多维数组可以利用下标进行一般的子集操作</p>
<pre><code>&gt; ara[,2,2:3]
     [,1] [,2]
[1,]    9   15
[2,]   10   16</code></pre>
<p>多维数组在取子集时如果某一维下标是标量， 则结果维数会减少， 可以在方括号内用drop=FALSE选项避免这样的规则发生作用。</p>
<pre><code>&gt; ara[,2,2:3,drop=FALSE]
, , 1

     [,1]
[1,]    9
[2,]   10

, , 2

     [,1]
[1,]   15
[2,]   16</code></pre>
<p>类似于矩阵， 多维数组可以用一个矩阵作为下标， 如果是三维数组，矩阵就需要有3列， 四维数组需要用4列矩阵。 下标矩阵的每行对应于一个数组元素。</p>
]]></content>
  </entry>
  <entry>
    <title>逻辑型向量及其运算</title>
    <url>/2020/10/31/%E9%80%BB%E8%BE%91%E5%9E%8B%E5%90%91%E9%87%8F%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>逻辑型是R的基本数据类型之一，只有两个值TRUE和FALSE, 缺失时为NA。逻辑值一般产生自比较，如</p>
<pre><code>&gt; sele &lt;- (log10(15) &lt; 2)
&gt; print(sele)

## [1] TRUE</code></pre>
<p>向量比较结果为逻辑型向量。如</p>
<pre><code>&gt; c(1, 3, 5) &gt; 2
## [1] FALSE  TRUE  TRUE

&gt; (1:4) &gt;= (4:1)    
## [1] FALSE FALSE  TRUE  TRUE</code></pre>
<p>从例子可以看出，向量比较也遵从R的向量间运算的一般规则： 向量与标量的运算是向量每个元素与标量都分别运算一次， 等长向量的运算时对应元素的运算， 不等长但长度为倍数关系的向量运算是把短的从头重复利用。</p>
<p>与NA比较产生NA，如</p>
<pre><code>&gt; c(1, NA, 3) &gt; 2
## [1] FALSE    NA  TRUE

&gt; NA == NA
## [1] NA</code></pre>
<p>为了判断向量每个元素是否NA， 用is.na()函数，如</p>
<pre><code>&gt; is.na(c(1, NA, 3) &gt; 2)
## [1] FALSE  TRUE FALSE</code></pre>
<p>用**is.finite()**判断向量每个元素是否Inf值。</p>
<p>比较运算符包括</p>
<blockquote>
<p>&lt;   &lt;=  &gt;  &gt;=  ==  !=  %in%<br>分别表示小于、小于等于、大于、大于等于、等于、不等于、属于。 要注意等于比较用了两个等号。</p>
</blockquote>
<p>%in%是比较特殊的比较， x %in% y的运算把向量y看成集合， 运算结果是一个逻辑型向量， 第个元素的值为x的第元素是否属于y的逻辑型值。 如</p>
<pre><code>&gt; c(1,3) %in% c(2,3,4)
## [1] FALSE  TRUE

&gt; c(NA,3) %in% c(2,3,4)
## [1] FALSE  TRUE

&gt; c(1,3) %in% c(NA, 3, 4)
## [1] FALSE  TRUE

&gt; c(NA,3) %in% c(NA, 3, 4)
## [1] TRUE TRUE</code></pre>
<p>函数match(x, y)起到和x %in% y运算类似的作用， 但是其返回结果不是找到与否， 而是对x的每个元素， 找到其在y中首次出现的下标，找不到时取缺失值，如</p>
<pre><code>&gt; match(c(1, 3), c(2,3,4,3))
## [1] NA  2</code></pre>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><p>为了表达如“而且”, “或者”之类的复合比较， 需要使用逻辑运算把两个比较连接起来。 逻辑运算符为&amp;, |和!, 分别表示“同时成立”、“两者至少其一成立”、“条件的反面”。 比如，设age&lt;=3表示婴儿，sex==’女’表示女性，则 age&lt;=3 &amp; sex==’女’表示女婴, age&lt;=3 | sex==’女’表示婴儿或妇女, !(age&lt;=3 | sex==’女’)表示既非婴儿也非妇女。 为了确定运算的先后次序可以用圆括号()指定。</p>
<p>用xor(x, y)表示x与y的异或运算， 即值不相等时为真值，相等时为假值， 有缺失值参加运算时为缺失值。</p>
<p>逻辑向量与逻辑标量之间的逻辑运算， 两个逻辑向量之间的逻辑运算规则遵从一般R向量间运算规则。</p>
<p>在右运算符是缺失值时， 如果左运算符能够确定结果真假， 可以得到非缺失的结果。 例如，TRUE | NA为TRUE, FALSE &amp; NA为FALSE。 不能确定结果时返回NA， 比如， TRUE &amp; NA为NA, FALSE | NA为NA。</p>
<p>&amp;&amp;和||分别为短路的标量逻辑与和短路的标量逻辑或， 仅对两个标量进行运算，如果有向量也仅使用第一个元素。 一般用在if语句、while语句中， 且只要第一个比较已经决定最终结果就不计算第二个比较。 例如</p>
<pre><code>&gt; if(TRUE || sqrt(-1)&gt;0) 3+2 

## [1] 5</code></pre>
<p>其中的sqrt(-1)部分不会执行。</p>
<p>这里结果为TRUE, 第二部分没有参加计算， 否则第二部分的计算会发生函数自变量范围错误。</p>
<h2 id="逻辑运算函数"><a href="#逻辑运算函数" class="headerlink" title="逻辑运算函数"></a>逻辑运算函数</h2><p>因为R中比较与逻辑运算都支持向量之间、向量与标量之间的运算， 所以在需要一个标量结果时要特别注意， 后面讲到的if结构、while结构都需要逻辑标量而且不能是缺失值。 这时，应该对缺失值结果单独考虑。</p>
<p>若cond是逻辑向量， 用all(cond)测试cond的所有元素为真； 用any(cond)测试cond至少一个元素为真。 cond中允许有缺失值，结果可能为缺失值。 如</p>
<pre><code>&gt; c(1, NA, 3) &gt; 2
## [1] FALSE    NA  TRUE

&gt; all(c(1, NA, 3) &gt; 2)
## [1] FALSE

&gt; any(c(1, NA, 3) &gt; 2)
## [1] TRUE

&gt; all(NA)
## [1] NA

&gt; any(NA)
## [1] NA</code></pre>
<p>函数which()返回真值对应的所有下标，如</p>
<pre><code>&gt; which(c(FALSE, TRUE, TRUE, FALSE, NA))
## [1] 2 3

&gt; which((11:15) &gt; 12)
## [1] 3 4 5</code></pre>
<p>函数identical(x,y)比较两个R对象x与y的内容是否完全相同， 结果只会取标量TRUE与FALSE两种。 如</p>
<pre><code>&gt; identical(c(1,2,3), c(1,2,NA))
## [1] FALSE

&gt; identical(c(1L,2L,3L), c(1,2,3))
## [1] FALSE</code></pre>
<p>其中第二个结果假值是因为前一向量是整数型， 后一向量是实数型。</p>
<p>函数all.equal()与identical()类似， 但是在比较数值型时不区分整数型与实数型， 而且相同时返回标量TRUE， 但是不同时会返回一个说明有何不同的字符串。如</p>
<pre><code>&gt; all.equal(c(1,2,3), c(1,2,NA))
## [1] &quot;&#39;is.NA&#39; value mismatch: 1 in current 0 in target&quot;

&gt; all.equal(c(1L,2L,3L), c(1,2,3))
## [1] TRUE</code></pre>
<p>函数duplicated()返回每个元素是否为重复值的结果，如：</p>
<pre><code>&gt; duplicated(c(1,2,1,3,NA,4,NA))
## [1] FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE</code></pre>
<p>用函数unique()可以返回去掉重复值的结果。</p>
]]></content>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>ggplot2可视化入门及作图一般原则</title>
    <url>/2020/11/20/ggplot2%E5%8F%AF%E8%A7%86%E5%8C%96%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Hadley Wickem的ggplot2包是R的一个作图用的扩展包， 它实现了“图形的语法”， 将一个作图任务分解为若干个子任务， 只要完成各个子任务就可以完成作图。 在作常用的图形时， 只需要两个步骤：</p>
<blockquote>
<p> <strong>首先将图形所展现的数据输入到ggplot()函数中， 然后调用某个geom_xxx()函数， 指定图形类型，如散点图、曲线图、盒形图等。</strong></p>
</blockquote>
<p>如果需要进一步控制图形细节， 只要继续调用其它函数， 就可以控制变量值的表现方式(scale)、图例、配色等。 这使得我们很容易做出基本的图形， 在有需要时再深入学习， 做出更为满意的图形。</p>
<p>与基本R中的作图系统相比， ggplot2的作图有规律可循， 作图结果直接达到出版印刷质量， 除了可以按照一些既定模式做出常见种类的图形， 也很容易将不同图形种类组合在一起， 或者设计新颖的图形。 基本R的作图结果通常不够美观， 如果要将不同种类图形组合在一起比较困难， 对设计新的图形类型支持也不够好。</p>
<h2 id="ggplot2的作图一般步骤为："><a href="#ggplot2的作图一般步骤为：" class="headerlink" title="ggplot2的作图一般步骤为："></a>ggplot2的作图一般步骤为：</h2><ul>
<li>准备数据，一般为数据框， 且一般为长表， 即每个观测时间占一行， 每个观测变量占一列。</li>
</ul>
<ul>
<li>将数据输入到ggplot()函数中， 并指定参与作图的每个变量分别映射到哪些图形特性， 比如映射为x坐标、y坐标、颜色、形状等。 这些映射称为aesthetic mappings或aesthetics。</li>
</ul>
<ul>
<li>选择一个合适的图形类型， 函数名以geom_开头， 如geom_point()表示散点图。 图形类型简称为geom。 将ggplot()部分与geom_xxx()部分用加号连接。 到此已经可以作图，下面的步骤是进一步的细化设定。</li>
</ul>
<ul>
<li>设定适当的坐标系统， 如coord_cartesian(), scale_x_log10()等。 仍用加号连接。<br>设定标题和图例位置等，如labs()。 仍用加号连接。</li>
</ul>
<p><strong>这个流程的一个大致的模板为</strong>：</p>
<pre><code>p &lt;- ggplot(data=&lt;输入数据框&gt;,
  mapping=aes(&lt;维度&gt;=&lt;变量名&gt;,
    &lt;维度&gt;=&lt;变量名&gt;, &lt;...&gt;))
p + geom_&lt;图形类型&gt;(&lt;...&gt;) + 
  scale_&lt;映射&gt;_&lt;类型&gt;(&lt;...&gt;) +
  coord_&lt;类型&gt;(&lt;...&gt;) +
  labs(&lt;...&gt;)</code></pre>
<p>其中&lt;…&gt;表示额外的选项。 变量p包含做出的图形的所有数据与设定， 变量名可以任意取。</p>
<p>Wickham的书主要需要安装tidyverse扩展包， 安装时会自动安装其它一些有关扩展包。 Healy的的书需要通过如下程序安装socviz软件包：</p>
<pre><code>&gt; devtools::install_github(&quot;kjhealy/socviz&quot;)</code></pre>
<p>后续的例子中用到一些数据集:</p>
<ul>
<li>来自gapminder扩展包的gapminder数据集， 有若干个国家不同年份的一些数据， 包括所属洲、期望寿命、人口数、人均GDP。 有1704个观测和6个变量。</li>
</ul>
<ul>
<li>socviz包的gss_sm数据集，是2016年美国一般社会调查数据的部分内容。 有2867个观测，32个变量。 社会调查数据的变量主要取属性值， 比如无序分类、有序分类、分组的数值、整数值等。</li>
</ul>
<ul>
<li>socviz包的organdata数据集， 是17个OECD国家历年的器官捐献情况以及一些其它记录。</li>
</ul>
<ul>
<li>socviz扩展包的elections_historic数据集。 包括美国历次总统大选当选人、所属党派、支持比例等。</li>
</ul>
<ul>
<li>socviz扩展包的asasec数据集。 这是美国社会学学会(ASA)的各分会2005年到2015年的一些数据。</li>
</ul>
<ul>
<li>ggplot2包中的midwest数据集包含了美国中西部的一些县的统计数据， 如面积等。<br>来自ggplot2包的钻石数据集。</li>
</ul>
<h2 id="作图时应考虑的一些因素："><a href="#作图时应考虑的一些因素：" class="headerlink" title="作图时应考虑的一些因素："></a>作图时应考虑的一些因素：</h2><p>1.数值型变量的不同值可以表示为：</p>
<ul>
<li>同一坐标轴上的不同位置、</li>
<li>不同轴上的位置、</li>
<li>不同长度、</li>
<li>不同角度或者斜率、</li>
<li>不同面积、</li>
<li>三维空间中的不同位置、</li>
<li>颜色的不同明暗度、</li>
<li>不同颜色饱和度、</li>
<li>曲线的不同曲率、</li>
<li>三维体积，</li>
</ul>
<p>这些表示的选择项越往后越难以被读者正确辨识。 使用颜色时，应该使用渐变的明暗度或者渐变色。</p>
<p>2.分类变量的不同值可以表示为：</p>
<ul>
<li>不同分组、</li>
<li>不同颜色、</li>
<li>三维动态、</li>
<li>不同符号。</li>
</ul>
<p>这些表示的选择项越往后越难辨识。 使用颜色时，应该使用明显不同的颜色而不应该使用渐变色。</p>
<p>对于最少是零的变量， 是否应该以零作为坐标轴的最低值需要考虑， 但没有一定的规则。 同一组数据在不同的坐标范围或者长宽比下曲线的斜率会有很大差别。</p>
]]></content>
      <tags>
        <tag>数据可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>ggplot2散点图</title>
    <url>/2020/11/20/ggplot2%E6%95%A3%E7%82%B9%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="基本的散点图"><a href="#基本的散点图" class="headerlink" title="基本的散点图"></a>基本的散点图</h2><p>以gapminder数据集作为输入数据， 做出简单的散点图， 并逐步进行改善。 这个数据集有多个国家在多个年份的期望寿命与人均GDP值， 作期望寿命对人均GDP的散点图， 每个国家的每个年份作为一个点。 散点图最重要的映射是x轴与y轴两个维度。</p>
<p>首先调用ggplot()函数， 指定数据集， 将人均GDP映射到x轴， 将期望寿命映射到y轴， 结果保存为一个R变量：</p>
<pre><code>&gt; install.packages(&quot;gapminder&quot;)

&gt; library(gapminder)

&gt; head(gapminder,20)
# A tibble: 20 x 6
   country     continent  year lifeExp     pop gdpPercap
   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;
 1 Afghanistan Asia       1952    28.8  8.43e6      779.
 2 Afghanistan Asia       1957    30.3  9.24e6      821.
 3 Afghanistan Asia       1962    32.0  1.03e7      853.
 4 Afghanistan Asia       1967    34.0  1.15e7      836.
 5 Afghanistan Asia       1972    36.1  1.31e7      740.
 6 Afghanistan Asia       1977    38.4  1.49e7      786.
 7 Afghanistan Asia       1982    39.9  1.29e7      978.
 8 Afghanistan Asia       1987    40.8  1.39e7      852.
 9 Afghanistan Asia       1992    41.7  1.63e7      649.
10 Afghanistan Asia       1997    41.8  2.22e7      635.
11 Afghanistan Asia       2002    42.1  2.53e7      727.
12 Afghanistan Asia       2007    43.8  3.19e7      975.
13 Albania     Europe     1952    55.2  1.28e6     1601.
14 Albania     Europe     1957    59.3  1.48e6     1942.
15 Albania     Europe     1962    64.8  1.73e6     2313.
16 Albania     Europe     1967    66.2  1.98e6     2760.
17 Albania     Europe     1972    67.7  2.26e6     3313.
18 Albania     Europe     1977    68.9  2.51e6     3533.
19 Albania     Europe     1982    70.4  2.78e6     3631.
20 Albania     Europe     1987    72    3.08e6     3739.

&gt; p &lt;- ggplot(data = gapminder,
+             mapping = aes(
+                 x = gdpPercap,
+                 y = lifeExp))</code></pre>
<p>ggplot()的调用中， 可以省略data =, mapping =, x =, y =， 写成：</p>
<pre><code>&gt; p &lt;- ggplot(gapminder, aes(gdpPercap, lifeExp))</code></pre>
<p>在如上指定了数据和映射后， 只要用geom_xxx()指定一个图形类型， 并与ggplot()的结果用加号连接就可以作图了，如：</p>
<pre><code>&gt; p + geom_point()</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/ggplot_files/figure-html/ggplot2-start-gapminder-point01b-1.png"></p>
<p>实际上，上面的程序等同于调用<code>print(p + geom_point())</code>。 在R函数中或者在循环中需要显式地调用print()， 否则不会显示结果。 当载入了tidyverse系统时可以写成 <code>(p + geom_point()) %&gt;% print()</code>。</p>
<h2 id="逐步改善"><a href="#逐步改善" class="headerlink" title="逐步改善"></a>逐步改善</h2><p>指定数据集、指定映射、选择适当的图形类型就可以做出基本的图形， 随后可以逐步对坐标系、坐标系刻度、标签与图例、配色等进行改善。 实际上，ggplot2包已经提供了十分合理的预设值， 用户只要进行一些必要的改动即可。</p>
<p><strong>作图步骤之间用加号连接</strong>，这是ggplot包特有的语法。 例如， 用相同的映射做出拟合曲线图：</p>
<pre><code>&gt; p + geom_smooth()
`geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39;</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/ggplot_files/figure-html/ggplot2-start-gapminder-point01c-1.png"></p>
<pre><code>&gt; p + geom_smooth() + geom_point()
`geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39;</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/ggplot_files/figure-html/ggplot2-start-gapminder-point01d-1.png"></p>
<pre><code>&gt; p + geom_point() + geom_smooth(method=&quot;lm&quot;)
`geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/ggplot_files/figure-html/ggplot2-start-gapminder-point01e-1.png"></p>
<p>注意geom_xxx()函数计算所需的变量值是从ggplot()函数保存在变量p中的信息提取的。</p>
<p>在以上的所有图形中， x轴变量（人均GDP）分布非正态，严重右偏， 使得大多数散点重叠地分布在直角坐标系的左下角。 将x轴用对数刻度可以改善， 函数为scale_x_log10():</p>
<pre><code>&gt; p + geom_point() + geom_smooth() + scale_x_log10(labels=scales::dollar)


## `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39;</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/ggplot_files/figure-html/ggplot2-start-gapminder-point01g-1.png"></p>
<p>scale_xxx()的labels选项指定如何标出坐标刻度数字， 参数值是一个函数对象， 如果scales包中找不到适当的功能， 可以自定义一个函数将数值转换为字符串。 scales包提供了comma, date, dollar, math, number, ordinal, pvalue, scientific, time等坐标刻度值转换函数。</p>
<h2 id="颜色、符号、线型等映射"><a href="#颜色、符号、线型等映射" class="headerlink" title="颜色、符号、线型等映射"></a>颜色、符号、线型等映射</h2><p>在ggplot()函数的mapping参数的aes()设定中将变量映射到x、y轴， 颜色、符号、线型等图形元素类型， 也可以作为图形设置将某些图形元素设置为固定值。</p>
<p>例如， 用不同颜色表示不同大洲， 就是将continent变量映射到color:</p>
<pre><code>&gt; p &lt;- ggplot(data=gapminder,
+             mapping = aes(
+                 x = gdpPercap,
+                 y = lifeExp,
+                 color = continent))</code></pre>
<p>程序中仅指定了将大洲映射到颜色维， 并不具体指定所用的颜色。</p>
<p>作带有局部多项式曲线拟合的散点图：</p>
<pre><code>&gt; p + geom_point() + geom_smooth(method =&quot;loess&quot;) + scale_x_log10(labels=scales::dollar)

`geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/ggplot_files/figure-html/ggplot2-start-gapminder-point02b-1.png"></p>
<p>可以看出， 不同散点用了不同颜色表示其continent变量的值， 五个大洲分别进行了曲线拟合， 曲线使用了不同颜色但置信域颜色相同， 使得难以认读。 在图形右侧自动生成了颜色与continent变量值的对应关系图例。</p>
<p>下面的图形仍分不同大洲作曲线拟合， 并将置信区间阴影的颜色也用不同大洲区分， 方法是在aes()中将color和fill都指定为变量continent:</p>
<pre><code>&gt; p &lt;- ggplot(data=gapminder,
+             mapping = aes(
+                 x = gdpPercap,
+                 y = lifeExp,
+                 color = continent,
+                 fill = continent))

&gt; p + geom_point() + geom_smooth(method =&quot;loess&quot;) + scale_x_log10(labels=scales::dollar)

`geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/ggplot_files/figure-html/ggplot2-start-gapminder-point03-1.png"></p>
<pre><code>&gt; p &lt;- ggplot(data=gapminder,
+             mapping = aes(
+                 x = gdpPercap,
+                 y = lifeExp,
+                 color = &quot;chartreuse4&quot;))

&gt; p + geom_point() +
+     geom_smooth(method=&quot;loess&quot;) +
+     scale_x_log10(labels=scales::dollar)</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/ggplot_files/figure-html/ggplot2-start-gapminder-point04-bad-1.png"></p>
<p>我们发现，散点并没有使用草绿色，而且图形右侧有一个chartreuse4图例。 这是因为， aes()仅用来指定变量与图形元素类型的映射，所以实际上是生成了一个仅有一个常数值”chartreuse4”的新变量， 用颜色表示这个新变量。 为了指定固定颜色， 应将color=作为geom_xxx()函数的选项， 而不是放在aes()映射中，如：</p>
<pre><code>&gt; p &lt;- ggplot(data=gapminder,
  mapping = aes(
    x = gdpPercap,
    y = lifeExp))

&gt; p + geom_point(color=&quot;chartreuse4&quot;) +
+ geom_smooth(method=&quot;loess&quot;) +
+     scale_x_log10(labels=scales::dollar)

`geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/ggplot_files/figure-html/ggplot2-start-gapminder-point05-1.png"></p>
<p>geom_xxx()函数接受许多关于颜色、透明度、符号、线型的设置参数。 比如， 下面的程序指定了散点的透明度， 以及拟合直线的粗细：</p>
<pre><code>&gt; p + geom_point(alpha=0.5) +
+ geom_smooth(method = &quot;lm&quot;,color=&quot;cadetblue1&quot;,se=FALSE,size=4,alpha=0.3) + scale_x_log10(labels=scales::dollar)

## `geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/ggplot_files/figure-html/ggplot2-start-gapminder-point05b-1.png"></p>
<p>程序中size指定了线的以毫米为单位的粗细， se = FALSE关闭了置信区间显示。 用alpha =设置了透明度， 取0和1之间的值， 数值越小越透明。</p>
<p>下面用labs()函数给图形加上适当的标题：</p>
<pre><code>&gt; p + geom_point(alpha=0.5) + 
+     geom_smooth(method = &quot;gam&quot;) +
+     scale_x_log10(labels=scales::dollar) + 
+     labs(
+         x=&quot;人均GDP&quot;,
+         y=&quot;期望寿命(年数)&quot;,
+         title = &quot;经济增长与期望寿命&quot;,
+         subtitle = &quot;数据点为每个国家每年&quot;,
+         caption = &quot;数据来源：gapminder&quot;)</code></pre>
<p><img src="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/ggplot_files/figure-html/ggplot2-start-gapminder-point06-1.png"></p>
<p>可以看出， labs()规定了上方的标题、小标题， x轴、y轴的标题， 右下方的标注(caption)。 坐标轴刻度数值的规定则需要在scale_xxx()函数中给出</p>
]]></content>
  </entry>
</search>
